/*! For license information please see main.js.LICENSE.txt */
(()=>{var e={268:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>o});var a=n(81),i=n.n(a),s=n(645),r=n.n(s)()(i());r.push([e.id,"@import url(https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;500;600;700&display=swap);"]),r.push([e.id,"\nhtml,\nbody {\n  font-family: 'Source Code Pro', monospace;\n}\n",""]);const o=r},645:e=>{"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",a=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),a&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),a&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,a,i,s){"string"==typeof e&&(e=[[null,e,void 0]]);var r={};if(a)for(var o=0;o<this.length;o++){var u=this[o][0];null!=u&&(r[u]=!0)}for(var p=0;p<e.length;p++){var d=[].concat(e[p]);a&&r[d[0]]||(void 0!==s&&(void 0===d[5]||(d[1]="@layer".concat(d[5].length>0?" ".concat(d[5]):""," {").concat(d[1],"}")),d[5]=s),n&&(d[2]?(d[1]="@media ".concat(d[2]," {").concat(d[1],"}"),d[2]=n):d[2]=n),i&&(d[4]?(d[1]="@supports (".concat(d[4],") {").concat(d[1],"}"),d[4]=i):d[4]="".concat(i)),t.push(d))}},t}},81:e=>{"use strict";e.exports=function(e){return e[1]}},267:(e,t,n)=>{"use strict";var a=Object.freeze({});function i(e){return null==e}function s(e){return null!=e}function r(e){return!0===e}function o(e){return"string"==typeof e||"number"==typeof e||"symbol"==typeof e||"boolean"==typeof e}function u(e){return null!==e&&"object"==typeof e}var p=Object.prototype.toString;function d(e){return"[object Object]"===p.call(e)}function y(e){var t=parseFloat(String(e));return t>=0&&Math.floor(t)===t&&isFinite(e)}function l(e){return s(e)&&"function"==typeof e.then&&"function"==typeof e.catch}function m(e){return null==e?"":Array.isArray(e)||d(e)&&e.toString===p?JSON.stringify(e,null,2):String(e)}function c(e){var t=parseFloat(e);return isNaN(t)?e:t}function f(e,t){for(var n=Object.create(null),a=e.split(","),i=0;i<a.length;i++)n[a[i]]=!0;return t?function(e){return n[e.toLowerCase()]}:function(e){return n[e]}}var h=f("slot,component",!0),T=f("key,ref,slot,slot-scope,is");function b(e,t){if(e.length){var n=e.indexOf(t);if(n>-1)return e.splice(n,1)}}var v=Object.prototype.hasOwnProperty;function w(e,t){return v.call(e,t)}function g(e){var t=Object.create(null);return function(n){return t[n]||(t[n]=e(n))}}var k=/-(\w)/g,M=g((function(e){return e.replace(k,(function(e,t){return t?t.toUpperCase():""}))})),A=g((function(e){return e.charAt(0).toUpperCase()+e.slice(1)})),_=/\B([A-Z])/g,C=g((function(e){return e.replace(_,"-$1").toLowerCase()})),x=Function.prototype.bind?function(e,t){return e.bind(t)}:function(e,t){function n(n){var a=arguments.length;return a?a>1?e.apply(t,arguments):e.call(t,n):e.call(t)}return n._length=e.length,n};function I(e,t){t=t||0;for(var n=e.length-t,a=new Array(n);n--;)a[n]=e[n+t];return a}function P(e,t){for(var n in t)e[n]=t[n];return e}function R(e){for(var t={},n=0;n<e.length;n++)e[n]&&P(t,e[n]);return t}function S(e,t,n){}var E=function(e,t,n){return!1},O=function(e){return e};function U(e,t){if(e===t)return!0;var n=u(e),a=u(t);if(!n||!a)return!n&&!a&&String(e)===String(t);try{var i=Array.isArray(e),s=Array.isArray(t);if(i&&s)return e.length===t.length&&e.every((function(e,n){return U(e,t[n])}));if(e instanceof Date&&t instanceof Date)return e.getTime()===t.getTime();if(i||s)return!1;var r=Object.keys(e),o=Object.keys(t);return r.length===o.length&&r.every((function(n){return U(e[n],t[n])}))}catch(e){return!1}}function V(e,t){for(var n=0;n<e.length;n++)if(U(e[n],t))return n;return-1}function D(e){var t=!1;return function(){t||(t=!0,e.apply(this,arguments))}}var L="data-server-rendered",B=["component","directive","filter"],q=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],N={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:E,isReservedAttr:E,isUnknownElement:E,getTagNamespace:S,parsePlatformTagName:O,mustUseProp:E,async:!0,_lifecycleHooks:q},F=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function z(e){var t=(e+"").charCodeAt(0);return 36===t||95===t}function H(e,t,n,a){Object.defineProperty(e,t,{value:n,enumerable:!!a,writable:!0,configurable:!0})}var $,j=new RegExp("[^"+F.source+".$_\\d]"),W="__proto__"in{},X="undefined"!=typeof window,G="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,Q=G&&WXEnvironment.platform.toLowerCase(),Y=X&&window.navigator.userAgent.toLowerCase(),J=Y&&/msie|trident/.test(Y),K=Y&&Y.indexOf("msie 9.0")>0,Z=Y&&Y.indexOf("edge/")>0,ee=(Y&&Y.indexOf("android"),Y&&/iphone|ipad|ipod|ios/.test(Y)||"ios"===Q),te=(Y&&/chrome\/\d+/.test(Y),Y&&/phantomjs/.test(Y),Y&&Y.match(/firefox\/(\d+)/)),ne={}.watch,ae=!1;if(X)try{var ie={};Object.defineProperty(ie,"passive",{get:function(){ae=!0}}),window.addEventListener("test-passive",null,ie)}catch(e){}var se=function(){return void 0===$&&($=!X&&!G&&void 0!==n.g&&n.g.process&&"server"===n.g.process.env.VUE_ENV),$},re=X&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function oe(e){return"function"==typeof e&&/native code/.test(e.toString())}var ue,pe="undefined"!=typeof Symbol&&oe(Symbol)&&"undefined"!=typeof Reflect&&oe(Reflect.ownKeys);ue="undefined"!=typeof Set&&oe(Set)?Set:function(){function e(){this.set=Object.create(null)}return e.prototype.has=function(e){return!0===this.set[e]},e.prototype.add=function(e){this.set[e]=!0},e.prototype.clear=function(){this.set=Object.create(null)},e}();var de=S,ye=0,le=function(){this.id=ye++,this.subs=[]};le.prototype.addSub=function(e){this.subs.push(e)},le.prototype.removeSub=function(e){b(this.subs,e)},le.prototype.depend=function(){le.target&&le.target.addDep(this)},le.prototype.notify=function(){for(var e=this.subs.slice(),t=0,n=e.length;t<n;t++)e[t].update()},le.target=null;var me=[];function ce(e){me.push(e),le.target=e}function fe(){me.pop(),le.target=me[me.length-1]}var he=function(e,t,n,a,i,s,r,o){this.tag=e,this.data=t,this.children=n,this.text=a,this.elm=i,this.ns=void 0,this.context=s,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=t&&t.key,this.componentOptions=r,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=o,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},Te={child:{configurable:!0}};Te.child.get=function(){return this.componentInstance},Object.defineProperties(he.prototype,Te);var be=function(e){void 0===e&&(e="");var t=new he;return t.text=e,t.isComment=!0,t};function ve(e){return new he(void 0,void 0,void 0,String(e))}function we(e){var t=new he(e.tag,e.data,e.children&&e.children.slice(),e.text,e.elm,e.context,e.componentOptions,e.asyncFactory);return t.ns=e.ns,t.isStatic=e.isStatic,t.key=e.key,t.isComment=e.isComment,t.fnContext=e.fnContext,t.fnOptions=e.fnOptions,t.fnScopeId=e.fnScopeId,t.asyncMeta=e.asyncMeta,t.isCloned=!0,t}var ge=Array.prototype,ke=Object.create(ge);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(e){var t=ge[e];H(ke,e,(function(){for(var n=[],a=arguments.length;a--;)n[a]=arguments[a];var i,s=t.apply(this,n),r=this.__ob__;switch(e){case"push":case"unshift":i=n;break;case"splice":i=n.slice(2)}return i&&r.observeArray(i),r.dep.notify(),s}))}));var Me=Object.getOwnPropertyNames(ke),Ae=!0;function _e(e){Ae=e}var Ce=function(e){this.value=e,this.dep=new le,this.vmCount=0,H(e,"__ob__",this),Array.isArray(e)?(W?function(e,t){e.__proto__=t}(e,ke):function(e,t,n){for(var a=0,i=n.length;a<i;a++){var s=n[a];H(e,s,t[s])}}(e,ke,Me),this.observeArray(e)):this.walk(e)};function xe(e,t){var n;if(u(e)&&!(e instanceof he))return w(e,"__ob__")&&e.__ob__ instanceof Ce?n=e.__ob__:Ae&&!se()&&(Array.isArray(e)||d(e))&&Object.isExtensible(e)&&!e._isVue&&(n=new Ce(e)),t&&n&&n.vmCount++,n}function Ie(e,t,n,a,i){var s=new le,r=Object.getOwnPropertyDescriptor(e,t);if(!r||!1!==r.configurable){var o=r&&r.get,u=r&&r.set;o&&!u||2!==arguments.length||(n=e[t]);var p=!i&&xe(n);Object.defineProperty(e,t,{enumerable:!0,configurable:!0,get:function(){var t=o?o.call(e):n;return le.target&&(s.depend(),p&&(p.dep.depend(),Array.isArray(t)&&Se(t))),t},set:function(t){var a=o?o.call(e):n;t===a||t!=t&&a!=a||o&&!u||(u?u.call(e,t):n=t,p=!i&&xe(t),s.notify())}})}}function Pe(e,t,n){if(Array.isArray(e)&&y(t))return e.length=Math.max(e.length,t),e.splice(t,1,n),n;if(t in e&&!(t in Object.prototype))return e[t]=n,n;var a=e.__ob__;return e._isVue||a&&a.vmCount?n:a?(Ie(a.value,t,n),a.dep.notify(),n):(e[t]=n,n)}function Re(e,t){if(Array.isArray(e)&&y(t))e.splice(t,1);else{var n=e.__ob__;e._isVue||n&&n.vmCount||w(e,t)&&(delete e[t],n&&n.dep.notify())}}function Se(e){for(var t=void 0,n=0,a=e.length;n<a;n++)(t=e[n])&&t.__ob__&&t.__ob__.dep.depend(),Array.isArray(t)&&Se(t)}Ce.prototype.walk=function(e){for(var t=Object.keys(e),n=0;n<t.length;n++)Ie(e,t[n])},Ce.prototype.observeArray=function(e){for(var t=0,n=e.length;t<n;t++)xe(e[t])};var Ee=N.optionMergeStrategies;function Oe(e,t){if(!t)return e;for(var n,a,i,s=pe?Reflect.ownKeys(t):Object.keys(t),r=0;r<s.length;r++)"__ob__"!==(n=s[r])&&(a=e[n],i=t[n],w(e,n)?a!==i&&d(a)&&d(i)&&Oe(a,i):Pe(e,n,i));return e}function Ue(e,t,n){return n?function(){var a="function"==typeof t?t.call(n,n):t,i="function"==typeof e?e.call(n,n):e;return a?Oe(a,i):i}:t?e?function(){return Oe("function"==typeof t?t.call(this,this):t,"function"==typeof e?e.call(this,this):e)}:t:e}function Ve(e,t){var n=t?e?e.concat(t):Array.isArray(t)?t:[t]:e;return n?function(e){for(var t=[],n=0;n<e.length;n++)-1===t.indexOf(e[n])&&t.push(e[n]);return t}(n):n}function De(e,t,n,a){var i=Object.create(e||null);return t?P(i,t):i}Ee.data=function(e,t,n){return n?Ue(e,t,n):t&&"function"!=typeof t?e:Ue(e,t)},q.forEach((function(e){Ee[e]=Ve})),B.forEach((function(e){Ee[e+"s"]=De})),Ee.watch=function(e,t,n,a){if(e===ne&&(e=void 0),t===ne&&(t=void 0),!t)return Object.create(e||null);if(!e)return t;var i={};for(var s in P(i,e),t){var r=i[s],o=t[s];r&&!Array.isArray(r)&&(r=[r]),i[s]=r?r.concat(o):Array.isArray(o)?o:[o]}return i},Ee.props=Ee.methods=Ee.inject=Ee.computed=function(e,t,n,a){if(!e)return t;var i=Object.create(null);return P(i,e),t&&P(i,t),i},Ee.provide=Ue;var Le=function(e,t){return void 0===t?e:t};function Be(e,t,n){if("function"==typeof t&&(t=t.options),function(e,t){var n=e.props;if(n){var a,i,s={};if(Array.isArray(n))for(a=n.length;a--;)"string"==typeof(i=n[a])&&(s[M(i)]={type:null});else if(d(n))for(var r in n)i=n[r],s[M(r)]=d(i)?i:{type:i};e.props=s}}(t),function(e,t){var n=e.inject;if(n){var a=e.inject={};if(Array.isArray(n))for(var i=0;i<n.length;i++)a[n[i]]={from:n[i]};else if(d(n))for(var s in n){var r=n[s];a[s]=d(r)?P({from:s},r):{from:r}}}}(t),function(e){var t=e.directives;if(t)for(var n in t){var a=t[n];"function"==typeof a&&(t[n]={bind:a,update:a})}}(t),!t._base&&(t.extends&&(e=Be(e,t.extends,n)),t.mixins))for(var a=0,i=t.mixins.length;a<i;a++)e=Be(e,t.mixins[a],n);var s,r={};for(s in e)o(s);for(s in t)w(e,s)||o(s);function o(a){var i=Ee[a]||Le;r[a]=i(e[a],t[a],n,a)}return r}function qe(e,t,n,a){if("string"==typeof n){var i=e[t];if(w(i,n))return i[n];var s=M(n);if(w(i,s))return i[s];var r=A(s);return w(i,r)?i[r]:i[n]||i[s]||i[r]}}function Ne(e,t,n,a){var i=t[e],s=!w(n,e),r=n[e],o=$e(Boolean,i.type);if(o>-1)if(s&&!w(i,"default"))r=!1;else if(""===r||r===C(e)){var u=$e(String,i.type);(u<0||o<u)&&(r=!0)}if(void 0===r){r=function(e,t,n){if(w(t,"default")){var a=t.default;return e&&e.$options.propsData&&void 0===e.$options.propsData[n]&&void 0!==e._props[n]?e._props[n]:"function"==typeof a&&"Function"!==ze(t.type)?a.call(e):a}}(a,i,e);var p=Ae;_e(!0),xe(r),_e(p)}return r}var Fe=/^\s*function (\w+)/;function ze(e){var t=e&&e.toString().match(Fe);return t?t[1]:""}function He(e,t){return ze(e)===ze(t)}function $e(e,t){if(!Array.isArray(t))return He(t,e)?0:-1;for(var n=0,a=t.length;n<a;n++)if(He(t[n],e))return n;return-1}function je(e,t,n){ce();try{if(t)for(var a=t;a=a.$parent;){var i=a.$options.errorCaptured;if(i)for(var s=0;s<i.length;s++)try{if(!1===i[s].call(a,e,t,n))return}catch(e){Xe(e,a,"errorCaptured hook")}}Xe(e,t,n)}finally{fe()}}function We(e,t,n,a,i){var s;try{(s=n?e.apply(t,n):e.call(t))&&!s._isVue&&l(s)&&!s._handled&&(s.catch((function(e){return je(e,a,i+" (Promise/async)")})),s._handled=!0)}catch(e){je(e,a,i)}return s}function Xe(e,t,n){if(N.errorHandler)try{return N.errorHandler.call(null,e,t,n)}catch(t){t!==e&&Ge(t)}Ge(e)}function Ge(e,t,n){if(!X&&!G||"undefined"==typeof console)throw e;console.error(e)}var Qe,Ye=!1,Je=[],Ke=!1;function Ze(){Ke=!1;var e=Je.slice(0);Je.length=0;for(var t=0;t<e.length;t++)e[t]()}if("undefined"!=typeof Promise&&oe(Promise)){var et=Promise.resolve();Qe=function(){et.then(Ze),ee&&setTimeout(S)},Ye=!0}else if(J||"undefined"==typeof MutationObserver||!oe(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Qe="undefined"!=typeof setImmediate&&oe(setImmediate)?function(){setImmediate(Ze)}:function(){setTimeout(Ze,0)};else{var tt=1,nt=new MutationObserver(Ze),at=document.createTextNode(String(tt));nt.observe(at,{characterData:!0}),Qe=function(){tt=(tt+1)%2,at.data=String(tt)},Ye=!0}function it(e,t){var n;if(Je.push((function(){if(e)try{e.call(t)}catch(e){je(e,t,"nextTick")}else n&&n(t)})),Ke||(Ke=!0,Qe()),!e&&"undefined"!=typeof Promise)return new Promise((function(e){n=e}))}var st=new ue;function rt(e){ot(e,st),st.clear()}function ot(e,t){var n,a,i=Array.isArray(e);if(!(!i&&!u(e)||Object.isFrozen(e)||e instanceof he)){if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(i)for(n=e.length;n--;)ot(e[n],t);else for(n=(a=Object.keys(e)).length;n--;)ot(e[a[n]],t)}}var ut=g((function(e){var t="&"===e.charAt(0),n="~"===(e=t?e.slice(1):e).charAt(0),a="!"===(e=n?e.slice(1):e).charAt(0);return{name:e=a?e.slice(1):e,once:n,capture:a,passive:t}}));function pt(e,t){function n(){var e=arguments,a=n.fns;if(!Array.isArray(a))return We(a,null,arguments,t,"v-on handler");for(var i=a.slice(),s=0;s<i.length;s++)We(i[s],null,e,t,"v-on handler")}return n.fns=e,n}function dt(e,t,n,a,s,o){var u,p,d,y;for(u in e)p=e[u],d=t[u],y=ut(u),i(p)||(i(d)?(i(p.fns)&&(p=e[u]=pt(p,o)),r(y.once)&&(p=e[u]=s(y.name,p,y.capture)),n(y.name,p,y.capture,y.passive,y.params)):p!==d&&(d.fns=p,e[u]=d));for(u in t)i(e[u])&&a((y=ut(u)).name,t[u],y.capture)}function yt(e,t,n){var a;e instanceof he&&(e=e.data.hook||(e.data.hook={}));var o=e[t];function u(){n.apply(this,arguments),b(a.fns,u)}i(o)?a=pt([u]):s(o.fns)&&r(o.merged)?(a=o).fns.push(u):a=pt([o,u]),a.merged=!0,e[t]=a}function lt(e,t,n,a,i){if(s(t)){if(w(t,n))return e[n]=t[n],i||delete t[n],!0;if(w(t,a))return e[n]=t[a],i||delete t[a],!0}return!1}function mt(e){return o(e)?[ve(e)]:Array.isArray(e)?ft(e):void 0}function ct(e){return s(e)&&s(e.text)&&!1===e.isComment}function ft(e,t){var n,a,u,p,d=[];for(n=0;n<e.length;n++)i(a=e[n])||"boolean"==typeof a||(p=d[u=d.length-1],Array.isArray(a)?a.length>0&&(ct((a=ft(a,(t||"")+"_"+n))[0])&&ct(p)&&(d[u]=ve(p.text+a[0].text),a.shift()),d.push.apply(d,a)):o(a)?ct(p)?d[u]=ve(p.text+a):""!==a&&d.push(ve(a)):ct(a)&&ct(p)?d[u]=ve(p.text+a.text):(r(e._isVList)&&s(a.tag)&&i(a.key)&&s(t)&&(a.key="__vlist"+t+"_"+n+"__"),d.push(a)));return d}function ht(e,t){if(e){for(var n=Object.create(null),a=pe?Reflect.ownKeys(e):Object.keys(e),i=0;i<a.length;i++){var s=a[i];if("__ob__"!==s){for(var r=e[s].from,o=t;o;){if(o._provided&&w(o._provided,r)){n[s]=o._provided[r];break}o=o.$parent}if(!o&&"default"in e[s]){var u=e[s].default;n[s]="function"==typeof u?u.call(t):u}}}return n}}function Tt(e,t){if(!e||!e.length)return{};for(var n={},a=0,i=e.length;a<i;a++){var s=e[a],r=s.data;if(r&&r.attrs&&r.attrs.slot&&delete r.attrs.slot,s.context!==t&&s.fnContext!==t||!r||null==r.slot)(n.default||(n.default=[])).push(s);else{var o=r.slot,u=n[o]||(n[o]=[]);"template"===s.tag?u.push.apply(u,s.children||[]):u.push(s)}}for(var p in n)n[p].every(bt)&&delete n[p];return n}function bt(e){return e.isComment&&!e.asyncFactory||" "===e.text}function vt(e){return e.isComment&&e.asyncFactory}function wt(e,t,n){var i,s=Object.keys(t).length>0,r=e?!!e.$stable:!s,o=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(r&&n&&n!==a&&o===n.$key&&!s&&!n.$hasNormal)return n;for(var u in i={},e)e[u]&&"$"!==u[0]&&(i[u]=gt(t,u,e[u]))}else i={};for(var p in t)p in i||(i[p]=kt(t,p));return e&&Object.isExtensible(e)&&(e._normalized=i),H(i,"$stable",r),H(i,"$key",o),H(i,"$hasNormal",s),i}function gt(e,t,n){var a=function(){var e=arguments.length?n.apply(null,arguments):n({}),t=(e=e&&"object"==typeof e&&!Array.isArray(e)?[e]:mt(e))&&e[0];return e&&(!t||1===e.length&&t.isComment&&!vt(t))?void 0:e};return n.proxy&&Object.defineProperty(e,t,{get:a,enumerable:!0,configurable:!0}),a}function kt(e,t){return function(){return e[t]}}function Mt(e,t){var n,a,i,r,o;if(Array.isArray(e)||"string"==typeof e)for(n=new Array(e.length),a=0,i=e.length;a<i;a++)n[a]=t(e[a],a);else if("number"==typeof e)for(n=new Array(e),a=0;a<e;a++)n[a]=t(a+1,a);else if(u(e))if(pe&&e[Symbol.iterator]){n=[];for(var p=e[Symbol.iterator](),d=p.next();!d.done;)n.push(t(d.value,n.length)),d=p.next()}else for(r=Object.keys(e),n=new Array(r.length),a=0,i=r.length;a<i;a++)o=r[a],n[a]=t(e[o],o,a);return s(n)||(n=[]),n._isVList=!0,n}function At(e,t,n,a){var i,s=this.$scopedSlots[e];s?(n=n||{},a&&(n=P(P({},a),n)),i=s(n)||("function"==typeof t?t():t)):i=this.$slots[e]||("function"==typeof t?t():t);var r=n&&n.slot;return r?this.$createElement("template",{slot:r},i):i}function _t(e){return qe(this.$options,"filters",e)||O}function Ct(e,t){return Array.isArray(e)?-1===e.indexOf(t):e!==t}function xt(e,t,n,a,i){var s=N.keyCodes[t]||n;return i&&a&&!N.keyCodes[t]?Ct(i,a):s?Ct(s,e):a?C(a)!==t:void 0===e}function It(e,t,n,a,i){if(n&&u(n)){var s;Array.isArray(n)&&(n=R(n));var r=function(r){if("class"===r||"style"===r||T(r))s=e;else{var o=e.attrs&&e.attrs.type;s=a||N.mustUseProp(t,o,r)?e.domProps||(e.domProps={}):e.attrs||(e.attrs={})}var u=M(r),p=C(r);u in s||p in s||(s[r]=n[r],i&&((e.on||(e.on={}))["update:"+r]=function(e){n[r]=e}))};for(var o in n)r(o)}return e}function Pt(e,t){var n=this._staticTrees||(this._staticTrees=[]),a=n[e];return a&&!t||St(a=n[e]=this.$options.staticRenderFns[e].call(this._renderProxy,null,this),"__static__"+e,!1),a}function Rt(e,t,n){return St(e,"__once__"+t+(n?"_"+n:""),!0),e}function St(e,t,n){if(Array.isArray(e))for(var a=0;a<e.length;a++)e[a]&&"string"!=typeof e[a]&&Et(e[a],t+"_"+a,n);else Et(e,t,n)}function Et(e,t,n){e.isStatic=!0,e.key=t,e.isOnce=n}function Ot(e,t){if(t&&d(t)){var n=e.on=e.on?P({},e.on):{};for(var a in t){var i=n[a],s=t[a];n[a]=i?[].concat(i,s):s}}return e}function Ut(e,t,n,a){t=t||{$stable:!n};for(var i=0;i<e.length;i++){var s=e[i];Array.isArray(s)?Ut(s,t,n):s&&(s.proxy&&(s.fn.proxy=!0),t[s.key]=s.fn)}return a&&(t.$key=a),t}function Vt(e,t){for(var n=0;n<t.length;n+=2){var a=t[n];"string"==typeof a&&a&&(e[t[n]]=t[n+1])}return e}function Dt(e,t){return"string"==typeof e?t+e:e}function Lt(e){e._o=Rt,e._n=c,e._s=m,e._l=Mt,e._t=At,e._q=U,e._i=V,e._m=Pt,e._f=_t,e._k=xt,e._b=It,e._v=ve,e._e=be,e._u=Ut,e._g=Ot,e._d=Vt,e._p=Dt}function Bt(e,t,n,i,s){var o,u=this,p=s.options;w(i,"_uid")?(o=Object.create(i))._original=i:(o=i,i=i._original);var d=r(p._compiled),y=!d;this.data=e,this.props=t,this.children=n,this.parent=i,this.listeners=e.on||a,this.injections=ht(p.inject,i),this.slots=function(){return u.$slots||wt(e.scopedSlots,u.$slots=Tt(n,i)),u.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return wt(e.scopedSlots,this.slots())}}),d&&(this.$options=p,this.$slots=this.slots(),this.$scopedSlots=wt(e.scopedSlots,this.$slots)),p._scopeId?this._c=function(e,t,n,a){var s=jt(o,e,t,n,a,y);return s&&!Array.isArray(s)&&(s.fnScopeId=p._scopeId,s.fnContext=i),s}:this._c=function(e,t,n,a){return jt(o,e,t,n,a,y)}}function qt(e,t,n,a,i){var s=we(e);return s.fnContext=n,s.fnOptions=a,t.slot&&((s.data||(s.data={})).slot=t.slot),s}function Nt(e,t){for(var n in t)e[M(n)]=t[n]}Lt(Bt.prototype);var Ft={init:function(e,t){if(e.componentInstance&&!e.componentInstance._isDestroyed&&e.data.keepAlive){var n=e;Ft.prepatch(n,n)}else(e.componentInstance=function(e,t){var n={_isComponent:!0,_parentVnode:e,parent:t},a=e.data.inlineTemplate;return s(a)&&(n.render=a.render,n.staticRenderFns=a.staticRenderFns),new e.componentOptions.Ctor(n)}(e,tn)).$mount(t?e.elm:void 0,t)},prepatch:function(e,t){var n=t.componentOptions;!function(e,t,n,i,s){var r=i.data.scopedSlots,o=e.$scopedSlots,u=!!(r&&!r.$stable||o!==a&&!o.$stable||r&&e.$scopedSlots.$key!==r.$key||!r&&e.$scopedSlots.$key),p=!!(s||e.$options._renderChildren||u);if(e.$options._parentVnode=i,e.$vnode=i,e._vnode&&(e._vnode.parent=i),e.$options._renderChildren=s,e.$attrs=i.data.attrs||a,e.$listeners=n||a,t&&e.$options.props){_e(!1);for(var d=e._props,y=e.$options._propKeys||[],l=0;l<y.length;l++){var m=y[l],c=e.$options.props;d[m]=Ne(m,c,t,e)}_e(!0),e.$options.propsData=t}n=n||a;var f=e.$options._parentListeners;e.$options._parentListeners=n,en(e,n,f),p&&(e.$slots=Tt(s,i.context),e.$forceUpdate())}(t.componentInstance=e.componentInstance,n.propsData,n.listeners,t,n.children)},insert:function(e){var t,n=e.context,a=e.componentInstance;a._isMounted||(a._isMounted=!0,on(a,"mounted")),e.data.keepAlive&&(n._isMounted?((t=a)._inactive=!1,pn.push(t)):sn(a,!0))},destroy:function(e){var t=e.componentInstance;t._isDestroyed||(e.data.keepAlive?rn(t,!0):t.$destroy())}},zt=Object.keys(Ft);function Ht(e,t,n,o,p){if(!i(e)){var d=n.$options._base;if(u(e)&&(e=d.extend(e)),"function"==typeof e){var y;if(i(e.cid)&&(e=function(e,t){if(r(e.error)&&s(e.errorComp))return e.errorComp;if(s(e.resolved))return e.resolved;var n=Gt;if(n&&s(e.owners)&&-1===e.owners.indexOf(n)&&e.owners.push(n),r(e.loading)&&s(e.loadingComp))return e.loadingComp;if(n&&!s(e.owners)){var a=e.owners=[n],o=!0,p=null,d=null;n.$on("hook:destroyed",(function(){return b(a,n)}));var y=function(e){for(var t=0,n=a.length;t<n;t++)a[t].$forceUpdate();e&&(a.length=0,null!==p&&(clearTimeout(p),p=null),null!==d&&(clearTimeout(d),d=null))},m=D((function(n){e.resolved=Qt(n,t),o?a.length=0:y(!0)})),c=D((function(t){s(e.errorComp)&&(e.error=!0,y(!0))})),f=e(m,c);return u(f)&&(l(f)?i(e.resolved)&&f.then(m,c):l(f.component)&&(f.component.then(m,c),s(f.error)&&(e.errorComp=Qt(f.error,t)),s(f.loading)&&(e.loadingComp=Qt(f.loading,t),0===f.delay?e.loading=!0:p=setTimeout((function(){p=null,i(e.resolved)&&i(e.error)&&(e.loading=!0,y(!1))}),f.delay||200)),s(f.timeout)&&(d=setTimeout((function(){d=null,i(e.resolved)&&c(null)}),f.timeout)))),o=!1,e.loading?e.loadingComp:e.resolved}}(y=e,d),void 0===e))return function(e,t,n,a,i){var s=be();return s.asyncFactory=e,s.asyncMeta={data:t,context:n,children:a,tag:i},s}(y,t,n,o,p);t=t||{},In(e),s(t.model)&&function(e,t){var n=e.model&&e.model.prop||"value",a=e.model&&e.model.event||"input";(t.attrs||(t.attrs={}))[n]=t.model.value;var i=t.on||(t.on={}),r=i[a],o=t.model.callback;s(r)?(Array.isArray(r)?-1===r.indexOf(o):r!==o)&&(i[a]=[o].concat(r)):i[a]=o}(e.options,t);var m=function(e,t,n){var a=t.options.props;if(!i(a)){var r={},o=e.attrs,u=e.props;if(s(o)||s(u))for(var p in a){var d=C(p);lt(r,u,p,d,!0)||lt(r,o,p,d,!1)}return r}}(t,e);if(r(e.options.functional))return function(e,t,n,i,r){var o=e.options,u={},p=o.props;if(s(p))for(var d in p)u[d]=Ne(d,p,t||a);else s(n.attrs)&&Nt(u,n.attrs),s(n.props)&&Nt(u,n.props);var y=new Bt(n,u,r,i,e),l=o.render.call(null,y._c,y);if(l instanceof he)return qt(l,n,y.parent,o);if(Array.isArray(l)){for(var m=mt(l)||[],c=new Array(m.length),f=0;f<m.length;f++)c[f]=qt(m[f],n,y.parent,o);return c}}(e,m,t,n,o);var c=t.on;if(t.on=t.nativeOn,r(e.options.abstract)){var f=t.slot;t={},f&&(t.slot=f)}!function(e){for(var t=e.hook||(e.hook={}),n=0;n<zt.length;n++){var a=zt[n],i=t[a],s=Ft[a];i===s||i&&i._merged||(t[a]=i?$t(s,i):s)}}(t);var h=e.options.name||p;return new he("vue-component-"+e.cid+(h?"-"+h:""),t,void 0,void 0,void 0,n,{Ctor:e,propsData:m,listeners:c,tag:p,children:o},y)}}}function $t(e,t){var n=function(n,a){e(n,a),t(n,a)};return n._merged=!0,n}function jt(e,t,n,a,i,p){return(Array.isArray(n)||o(n))&&(i=a,a=n,n=void 0),r(p)&&(i=2),function(e,t,n,a,i){if(s(n)&&s(n.__ob__))return be();if(s(n)&&s(n.is)&&(t=n.is),!t)return be();var r,o,p;(Array.isArray(a)&&"function"==typeof a[0]&&((n=n||{}).scopedSlots={default:a[0]},a.length=0),2===i?a=mt(a):1===i&&(a=function(e){for(var t=0;t<e.length;t++)if(Array.isArray(e[t]))return Array.prototype.concat.apply([],e);return e}(a)),"string"==typeof t)?(o=e.$vnode&&e.$vnode.ns||N.getTagNamespace(t),r=N.isReservedTag(t)?new he(N.parsePlatformTagName(t),n,a,void 0,void 0,e):n&&n.pre||!s(p=qe(e.$options,"components",t))?new he(t,n,a,void 0,void 0,e):Ht(p,n,e,a,t)):r=Ht(t,n,e,a);return Array.isArray(r)?r:s(r)?(s(o)&&Wt(r,o),s(n)&&function(e){u(e.style)&&rt(e.style),u(e.class)&&rt(e.class)}(n),r):be()}(e,t,n,a,i)}function Wt(e,t,n){if(e.ns=t,"foreignObject"===e.tag&&(t=void 0,n=!0),s(e.children))for(var a=0,o=e.children.length;a<o;a++){var u=e.children[a];s(u.tag)&&(i(u.ns)||r(n)&&"svg"!==u.tag)&&Wt(u,t,n)}}var Xt,Gt=null;function Qt(e,t){return(e.__esModule||pe&&"Module"===e[Symbol.toStringTag])&&(e=e.default),u(e)?t.extend(e):e}function Yt(e){if(Array.isArray(e))for(var t=0;t<e.length;t++){var n=e[t];if(s(n)&&(s(n.componentOptions)||vt(n)))return n}}function Jt(e,t){Xt.$on(e,t)}function Kt(e,t){Xt.$off(e,t)}function Zt(e,t){var n=Xt;return function a(){var i=t.apply(null,arguments);null!==i&&n.$off(e,a)}}function en(e,t,n){Xt=e,dt(t,n||{},Jt,Kt,Zt,e),Xt=void 0}var tn=null;function nn(e){var t=tn;return tn=e,function(){tn=t}}function an(e){for(;e&&(e=e.$parent);)if(e._inactive)return!0;return!1}function sn(e,t){if(t){if(e._directInactive=!1,an(e))return}else if(e._directInactive)return;if(e._inactive||null===e._inactive){e._inactive=!1;for(var n=0;n<e.$children.length;n++)sn(e.$children[n]);on(e,"activated")}}function rn(e,t){if(!(t&&(e._directInactive=!0,an(e))||e._inactive)){e._inactive=!0;for(var n=0;n<e.$children.length;n++)rn(e.$children[n]);on(e,"deactivated")}}function on(e,t){ce();var n=e.$options[t],a=t+" hook";if(n)for(var i=0,s=n.length;i<s;i++)We(n[i],e,null,e,a);e._hasHookEvent&&e.$emit("hook:"+t),fe()}var un=[],pn=[],dn={},yn=!1,ln=!1,mn=0,cn=0,fn=Date.now;if(X&&!J){var hn=window.performance;hn&&"function"==typeof hn.now&&fn()>document.createEvent("Event").timeStamp&&(fn=function(){return hn.now()})}function Tn(){var e,t;for(cn=fn(),ln=!0,un.sort((function(e,t){return e.id-t.id})),mn=0;mn<un.length;mn++)(e=un[mn]).before&&e.before(),t=e.id,dn[t]=null,e.run();var n=pn.slice(),a=un.slice();mn=un.length=pn.length=0,dn={},yn=ln=!1,function(e){for(var t=0;t<e.length;t++)e[t]._inactive=!0,sn(e[t],!0)}(n),function(e){for(var t=e.length;t--;){var n=e[t],a=n.vm;a._watcher===n&&a._isMounted&&!a._isDestroyed&&on(a,"updated")}}(a),re&&N.devtools&&re.emit("flush")}var bn=0,vn=function(e,t,n,a,i){this.vm=e,i&&(e._watcher=this),e._watchers.push(this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=n,this.id=++bn,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new ue,this.newDepIds=new ue,this.expression="","function"==typeof t?this.getter=t:(this.getter=function(e){if(!j.test(e)){var t=e.split(".");return function(e){for(var n=0;n<t.length;n++){if(!e)return;e=e[t[n]]}return e}}}(t),this.getter||(this.getter=S)),this.value=this.lazy?void 0:this.get()};vn.prototype.get=function(){var e;ce(this);var t=this.vm;try{e=this.getter.call(t,t)}catch(e){if(!this.user)throw e;je(e,t,'getter for watcher "'+this.expression+'"')}finally{this.deep&&rt(e),fe(),this.cleanupDeps()}return e},vn.prototype.addDep=function(e){var t=e.id;this.newDepIds.has(t)||(this.newDepIds.add(t),this.newDeps.push(e),this.depIds.has(t)||e.addSub(this))},vn.prototype.cleanupDeps=function(){for(var e=this.deps.length;e--;){var t=this.deps[e];this.newDepIds.has(t.id)||t.removeSub(this)}var n=this.depIds;this.depIds=this.newDepIds,this.newDepIds=n,this.newDepIds.clear(),n=this.deps,this.deps=this.newDeps,this.newDeps=n,this.newDeps.length=0},vn.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(e){var t=e.id;if(null==dn[t]){if(dn[t]=!0,ln){for(var n=un.length-1;n>mn&&un[n].id>e.id;)n--;un.splice(n+1,0,e)}else un.push(e);yn||(yn=!0,it(Tn))}}(this)},vn.prototype.run=function(){if(this.active){var e=this.get();if(e!==this.value||u(e)||this.deep){var t=this.value;if(this.value=e,this.user){var n='callback for watcher "'+this.expression+'"';We(this.cb,this.vm,[e,t],this.vm,n)}else this.cb.call(this.vm,e,t)}}},vn.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},vn.prototype.depend=function(){for(var e=this.deps.length;e--;)this.deps[e].depend()},vn.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||b(this.vm._watchers,this);for(var e=this.deps.length;e--;)this.deps[e].removeSub(this);this.active=!1}};var wn={enumerable:!0,configurable:!0,get:S,set:S};function gn(e,t,n){wn.get=function(){return this[t][n]},wn.set=function(e){this[t][n]=e},Object.defineProperty(e,n,wn)}var kn={lazy:!0};function Mn(e,t,n){var a=!se();"function"==typeof n?(wn.get=a?An(t):_n(n),wn.set=S):(wn.get=n.get?a&&!1!==n.cache?An(t):_n(n.get):S,wn.set=n.set||S),Object.defineProperty(e,t,wn)}function An(e){return function(){var t=this._computedWatchers&&this._computedWatchers[e];if(t)return t.dirty&&t.evaluate(),le.target&&t.depend(),t.value}}function _n(e){return function(){return e.call(this,this)}}function Cn(e,t,n,a){return d(n)&&(a=n,n=n.handler),"string"==typeof n&&(n=e[n]),e.$watch(t,n,a)}var xn=0;function In(e){var t=e.options;if(e.super){var n=In(e.super);if(n!==e.superOptions){e.superOptions=n;var a=function(e){var t,n=e.options,a=e.sealedOptions;for(var i in n)n[i]!==a[i]&&(t||(t={}),t[i]=n[i]);return t}(e);a&&P(e.extendOptions,a),(t=e.options=Be(n,e.extendOptions)).name&&(t.components[t.name]=e)}}return t}function Pn(e){this._init(e)}function Rn(e){return e&&(e.Ctor.options.name||e.tag)}function Sn(e,t){return Array.isArray(e)?e.indexOf(t)>-1:"string"==typeof e?e.split(",").indexOf(t)>-1:(n=e,!("[object RegExp]"!==p.call(n))&&e.test(t));var n}function En(e,t){var n=e.cache,a=e.keys,i=e._vnode;for(var s in n){var r=n[s];if(r){var o=r.name;o&&!t(o)&&On(n,s,a,i)}}}function On(e,t,n,a){var i=e[t];!i||a&&i.tag===a.tag||i.componentInstance.$destroy(),e[t]=null,b(n,t)}!function(e){e.prototype._init=function(e){var t=this;t._uid=xn++,t._isVue=!0,e&&e._isComponent?function(e,t){var n=e.$options=Object.create(e.constructor.options),a=t._parentVnode;n.parent=t.parent,n._parentVnode=a;var i=a.componentOptions;n.propsData=i.propsData,n._parentListeners=i.listeners,n._renderChildren=i.children,n._componentTag=i.tag,t.render&&(n.render=t.render,n.staticRenderFns=t.staticRenderFns)}(t,e):t.$options=Be(In(t.constructor),e||{},t),t._renderProxy=t,t._self=t,function(e){var t=e.$options,n=t.parent;if(n&&!t.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(e)}e.$parent=n,e.$root=n?n.$root:e,e.$children=[],e.$refs={},e._watcher=null,e._inactive=null,e._directInactive=!1,e._isMounted=!1,e._isDestroyed=!1,e._isBeingDestroyed=!1}(t),function(e){e._events=Object.create(null),e._hasHookEvent=!1;var t=e.$options._parentListeners;t&&en(e,t)}(t),function(e){e._vnode=null,e._staticTrees=null;var t=e.$options,n=e.$vnode=t._parentVnode,i=n&&n.context;e.$slots=Tt(t._renderChildren,i),e.$scopedSlots=a,e._c=function(t,n,a,i){return jt(e,t,n,a,i,!1)},e.$createElement=function(t,n,a,i){return jt(e,t,n,a,i,!0)};var s=n&&n.data;Ie(e,"$attrs",s&&s.attrs||a,null,!0),Ie(e,"$listeners",t._parentListeners||a,null,!0)}(t),on(t,"beforeCreate"),function(e){var t=ht(e.$options.inject,e);t&&(_e(!1),Object.keys(t).forEach((function(n){Ie(e,n,t[n])})),_e(!0))}(t),function(e){e._watchers=[];var t=e.$options;t.props&&function(e,t){var n=e.$options.propsData||{},a=e._props={},i=e.$options._propKeys=[];e.$parent&&_e(!1);var s=function(s){i.push(s);var r=Ne(s,t,n,e);Ie(a,s,r),s in e||gn(e,"_props",s)};for(var r in t)s(r);_e(!0)}(e,t.props),t.methods&&function(e,t){for(var n in e.$options.props,t)e[n]="function"!=typeof t[n]?S:x(t[n],e)}(e,t.methods),t.data?function(e){var t=e.$options.data;d(t=e._data="function"==typeof t?function(e,t){ce();try{return e.call(t,t)}catch(e){return je(e,t,"data()"),{}}finally{fe()}}(t,e):t||{})||(t={});for(var n=Object.keys(t),a=e.$options.props,i=(e.$options.methods,n.length);i--;){var s=n[i];a&&w(a,s)||z(s)||gn(e,"_data",s)}xe(t,!0)}(e):xe(e._data={},!0),t.computed&&function(e,t){var n=e._computedWatchers=Object.create(null),a=se();for(var i in t){var s=t[i],r="function"==typeof s?s:s.get;a||(n[i]=new vn(e,r||S,S,kn)),i in e||Mn(e,i,s)}}(e,t.computed),t.watch&&t.watch!==ne&&function(e,t){for(var n in t){var a=t[n];if(Array.isArray(a))for(var i=0;i<a.length;i++)Cn(e,n,a[i]);else Cn(e,n,a)}}(e,t.watch)}(t),function(e){var t=e.$options.provide;t&&(e._provided="function"==typeof t?t.call(e):t)}(t),on(t,"created"),t.$options.el&&t.$mount(t.$options.el)}}(Pn),function(e){Object.defineProperty(e.prototype,"$data",{get:function(){return this._data}}),Object.defineProperty(e.prototype,"$props",{get:function(){return this._props}}),e.prototype.$set=Pe,e.prototype.$delete=Re,e.prototype.$watch=function(e,t,n){var a=this;if(d(t))return Cn(a,e,t,n);(n=n||{}).user=!0;var i=new vn(a,e,t,n);if(n.immediate){var s='callback for immediate watcher "'+i.expression+'"';ce(),We(t,a,[i.value],a,s),fe()}return function(){i.teardown()}}}(Pn),function(e){var t=/^hook:/;e.prototype.$on=function(e,n){var a=this;if(Array.isArray(e))for(var i=0,s=e.length;i<s;i++)a.$on(e[i],n);else(a._events[e]||(a._events[e]=[])).push(n),t.test(e)&&(a._hasHookEvent=!0);return a},e.prototype.$once=function(e,t){var n=this;function a(){n.$off(e,a),t.apply(n,arguments)}return a.fn=t,n.$on(e,a),n},e.prototype.$off=function(e,t){var n=this;if(!arguments.length)return n._events=Object.create(null),n;if(Array.isArray(e)){for(var a=0,i=e.length;a<i;a++)n.$off(e[a],t);return n}var s,r=n._events[e];if(!r)return n;if(!t)return n._events[e]=null,n;for(var o=r.length;o--;)if((s=r[o])===t||s.fn===t){r.splice(o,1);break}return n},e.prototype.$emit=function(e){var t=this,n=t._events[e];if(n){n=n.length>1?I(n):n;for(var a=I(arguments,1),i='event handler for "'+e+'"',s=0,r=n.length;s<r;s++)We(n[s],t,a,t,i)}return t}}(Pn),function(e){e.prototype._update=function(e,t){var n=this,a=n.$el,i=n._vnode,s=nn(n);n._vnode=e,n.$el=i?n.__patch__(i,e):n.__patch__(n.$el,e,t,!1),s(),a&&(a.__vue__=null),n.$el&&(n.$el.__vue__=n),n.$vnode&&n.$parent&&n.$vnode===n.$parent._vnode&&(n.$parent.$el=n.$el)},e.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},e.prototype.$destroy=function(){var e=this;if(!e._isBeingDestroyed){on(e,"beforeDestroy"),e._isBeingDestroyed=!0;var t=e.$parent;!t||t._isBeingDestroyed||e.$options.abstract||b(t.$children,e),e._watcher&&e._watcher.teardown();for(var n=e._watchers.length;n--;)e._watchers[n].teardown();e._data.__ob__&&e._data.__ob__.vmCount--,e._isDestroyed=!0,e.__patch__(e._vnode,null),on(e,"destroyed"),e.$off(),e.$el&&(e.$el.__vue__=null),e.$vnode&&(e.$vnode.parent=null)}}}(Pn),function(e){Lt(e.prototype),e.prototype.$nextTick=function(e){return it(e,this)},e.prototype._render=function(){var e,t=this,n=t.$options,a=n.render,i=n._parentVnode;i&&(t.$scopedSlots=wt(i.data.scopedSlots,t.$slots,t.$scopedSlots)),t.$vnode=i;try{Gt=t,e=a.call(t._renderProxy,t.$createElement)}catch(n){je(n,t,"render"),e=t._vnode}finally{Gt=null}return Array.isArray(e)&&1===e.length&&(e=e[0]),e instanceof he||(e=be()),e.parent=i,e}}(Pn);var Un=[String,RegExp,Array],Vn={name:"keep-alive",abstract:!0,props:{include:Un,exclude:Un,max:[String,Number]},methods:{cacheVNode:function(){var e=this,t=e.cache,n=e.keys,a=e.vnodeToCache,i=e.keyToCache;if(a){var s=a.tag,r=a.componentInstance,o=a.componentOptions;t[i]={name:Rn(o),tag:s,componentInstance:r},n.push(i),this.max&&n.length>parseInt(this.max)&&On(t,n[0],n,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var e in this.cache)On(this.cache,e,this.keys)},mounted:function(){var e=this;this.cacheVNode(),this.$watch("include",(function(t){En(e,(function(e){return Sn(t,e)}))})),this.$watch("exclude",(function(t){En(e,(function(e){return!Sn(t,e)}))}))},updated:function(){this.cacheVNode()},render:function(){var e=this.$slots.default,t=Yt(e),n=t&&t.componentOptions;if(n){var a=Rn(n),i=this.include,s=this.exclude;if(i&&(!a||!Sn(i,a))||s&&a&&Sn(s,a))return t;var r=this.cache,o=this.keys,u=null==t.key?n.Ctor.cid+(n.tag?"::"+n.tag:""):t.key;r[u]?(t.componentInstance=r[u].componentInstance,b(o,u),o.push(u)):(this.vnodeToCache=t,this.keyToCache=u),t.data.keepAlive=!0}return t||e&&e[0]}},Dn={KeepAlive:Vn};!function(e){var t={get:function(){return N}};Object.defineProperty(e,"config",t),e.util={warn:de,extend:P,mergeOptions:Be,defineReactive:Ie},e.set=Pe,e.delete=Re,e.nextTick=it,e.observable=function(e){return xe(e),e},e.options=Object.create(null),B.forEach((function(t){e.options[t+"s"]=Object.create(null)})),e.options._base=e,P(e.options.components,Dn),function(e){e.use=function(e){var t=this._installedPlugins||(this._installedPlugins=[]);if(t.indexOf(e)>-1)return this;var n=I(arguments,1);return n.unshift(this),"function"==typeof e.install?e.install.apply(e,n):"function"==typeof e&&e.apply(null,n),t.push(e),this}}(e),function(e){e.mixin=function(e){return this.options=Be(this.options,e),this}}(e),function(e){e.cid=0;var t=1;e.extend=function(e){e=e||{};var n=this,a=n.cid,i=e._Ctor||(e._Ctor={});if(i[a])return i[a];var s=e.name||n.options.name,r=function(e){this._init(e)};return(r.prototype=Object.create(n.prototype)).constructor=r,r.cid=t++,r.options=Be(n.options,e),r.super=n,r.options.props&&function(e){var t=e.options.props;for(var n in t)gn(e.prototype,"_props",n)}(r),r.options.computed&&function(e){var t=e.options.computed;for(var n in t)Mn(e.prototype,n,t[n])}(r),r.extend=n.extend,r.mixin=n.mixin,r.use=n.use,B.forEach((function(e){r[e]=n[e]})),s&&(r.options.components[s]=r),r.superOptions=n.options,r.extendOptions=e,r.sealedOptions=P({},r.options),i[a]=r,r}}(e),function(e){B.forEach((function(t){e[t]=function(e,n){return n?("component"===t&&d(n)&&(n.name=n.name||e,n=this.options._base.extend(n)),"directive"===t&&"function"==typeof n&&(n={bind:n,update:n}),this.options[t+"s"][e]=n,n):this.options[t+"s"][e]}}))}(e)}(Pn),Object.defineProperty(Pn.prototype,"$isServer",{get:se}),Object.defineProperty(Pn.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Pn,"FunctionalRenderContext",{value:Bt}),Pn.version="2.6.14";var Ln=f("style,class"),Bn=f("input,textarea,option,select,progress"),qn=function(e,t,n){return"value"===n&&Bn(e)&&"button"!==t||"selected"===n&&"option"===e||"checked"===n&&"input"===e||"muted"===n&&"video"===e},Nn=f("contenteditable,draggable,spellcheck"),Fn=f("events,caret,typing,plaintext-only"),zn=f("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Hn="http://www.w3.org/1999/xlink",$n=function(e){return":"===e.charAt(5)&&"xlink"===e.slice(0,5)},jn=function(e){return $n(e)?e.slice(6,e.length):""},Wn=function(e){return null==e||!1===e};function Xn(e,t){return{staticClass:Gn(e.staticClass,t.staticClass),class:s(e.class)?[e.class,t.class]:t.class}}function Gn(e,t){return e?t?e+" "+t:e:t||""}function Qn(e){return Array.isArray(e)?function(e){for(var t,n="",a=0,i=e.length;a<i;a++)s(t=Qn(e[a]))&&""!==t&&(n&&(n+=" "),n+=t);return n}(e):u(e)?function(e){var t="";for(var n in e)e[n]&&(t&&(t+=" "),t+=n);return t}(e):"string"==typeof e?e:""}var Yn={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Jn=f("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Kn=f("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Zn=function(e){return Jn(e)||Kn(e)};function ea(e){return Kn(e)?"svg":"math"===e?"math":void 0}var ta=Object.create(null),na=f("text,number,password,search,email,tel,url");function aa(e){return"string"==typeof e?document.querySelector(e)||document.createElement("div"):e}var ia=Object.freeze({createElement:function(e,t){var n=document.createElement(e);return"select"!==e||t.data&&t.data.attrs&&void 0!==t.data.attrs.multiple&&n.setAttribute("multiple","multiple"),n},createElementNS:function(e,t){return document.createElementNS(Yn[e],t)},createTextNode:function(e){return document.createTextNode(e)},createComment:function(e){return document.createComment(e)},insertBefore:function(e,t,n){e.insertBefore(t,n)},removeChild:function(e,t){e.removeChild(t)},appendChild:function(e,t){e.appendChild(t)},parentNode:function(e){return e.parentNode},nextSibling:function(e){return e.nextSibling},tagName:function(e){return e.tagName},setTextContent:function(e,t){e.textContent=t},setStyleScope:function(e,t){e.setAttribute(t,"")}}),sa={create:function(e,t){ra(t)},update:function(e,t){e.data.ref!==t.data.ref&&(ra(e,!0),ra(t))},destroy:function(e){ra(e,!0)}};function ra(e,t){var n=e.data.ref;if(s(n)){var a=e.context,i=e.componentInstance||e.elm,r=a.$refs;t?Array.isArray(r[n])?b(r[n],i):r[n]===i&&(r[n]=void 0):e.data.refInFor?Array.isArray(r[n])?r[n].indexOf(i)<0&&r[n].push(i):r[n]=[i]:r[n]=i}}var oa=new he("",{},[]),ua=["create","activate","update","remove","destroy"];function pa(e,t){return e.key===t.key&&e.asyncFactory===t.asyncFactory&&(e.tag===t.tag&&e.isComment===t.isComment&&s(e.data)===s(t.data)&&function(e,t){if("input"!==e.tag)return!0;var n,a=s(n=e.data)&&s(n=n.attrs)&&n.type,i=s(n=t.data)&&s(n=n.attrs)&&n.type;return a===i||na(a)&&na(i)}(e,t)||r(e.isAsyncPlaceholder)&&i(t.asyncFactory.error))}function da(e,t,n){var a,i,r={};for(a=t;a<=n;++a)s(i=e[a].key)&&(r[i]=a);return r}var ya={create:la,update:la,destroy:function(e){la(e,oa)}};function la(e,t){(e.data.directives||t.data.directives)&&function(e,t){var n,a,i,s=e===oa,r=t===oa,o=ca(e.data.directives,e.context),u=ca(t.data.directives,t.context),p=[],d=[];for(n in u)a=o[n],i=u[n],a?(i.oldValue=a.value,i.oldArg=a.arg,ha(i,"update",t,e),i.def&&i.def.componentUpdated&&d.push(i)):(ha(i,"bind",t,e),i.def&&i.def.inserted&&p.push(i));if(p.length){var y=function(){for(var n=0;n<p.length;n++)ha(p[n],"inserted",t,e)};s?yt(t,"insert",y):y()}if(d.length&&yt(t,"postpatch",(function(){for(var n=0;n<d.length;n++)ha(d[n],"componentUpdated",t,e)})),!s)for(n in o)u[n]||ha(o[n],"unbind",e,e,r)}(e,t)}var ma=Object.create(null);function ca(e,t){var n,a,i=Object.create(null);if(!e)return i;for(n=0;n<e.length;n++)(a=e[n]).modifiers||(a.modifiers=ma),i[fa(a)]=a,a.def=qe(t.$options,"directives",a.name);return i}function fa(e){return e.rawName||e.name+"."+Object.keys(e.modifiers||{}).join(".")}function ha(e,t,n,a,i){var s=e.def&&e.def[t];if(s)try{s(n.elm,e,n,a,i)}catch(a){je(a,n.context,"directive "+e.name+" "+t+" hook")}}var Ta=[sa,ya];function ba(e,t){var n=t.componentOptions;if(!(s(n)&&!1===n.Ctor.options.inheritAttrs||i(e.data.attrs)&&i(t.data.attrs))){var a,r,o=t.elm,u=e.data.attrs||{},p=t.data.attrs||{};for(a in s(p.__ob__)&&(p=t.data.attrs=P({},p)),p)r=p[a],u[a]!==r&&va(o,a,r,t.data.pre);for(a in(J||Z)&&p.value!==u.value&&va(o,"value",p.value),u)i(p[a])&&($n(a)?o.removeAttributeNS(Hn,jn(a)):Nn(a)||o.removeAttribute(a))}}function va(e,t,n,a){a||e.tagName.indexOf("-")>-1?wa(e,t,n):zn(t)?Wn(n)?e.removeAttribute(t):(n="allowfullscreen"===t&&"EMBED"===e.tagName?"true":t,e.setAttribute(t,n)):Nn(t)?e.setAttribute(t,function(e,t){return Wn(t)||"false"===t?"false":"contenteditable"===e&&Fn(t)?t:"true"}(t,n)):$n(t)?Wn(n)?e.removeAttributeNS(Hn,jn(t)):e.setAttributeNS(Hn,t,n):wa(e,t,n)}function wa(e,t,n){if(Wn(n))e.removeAttribute(t);else{if(J&&!K&&"TEXTAREA"===e.tagName&&"placeholder"===t&&""!==n&&!e.__ieph){var a=function(t){t.stopImmediatePropagation(),e.removeEventListener("input",a)};e.addEventListener("input",a),e.__ieph=!0}e.setAttribute(t,n)}}var ga={create:ba,update:ba};function ka(e,t){var n=t.elm,a=t.data,r=e.data;if(!(i(a.staticClass)&&i(a.class)&&(i(r)||i(r.staticClass)&&i(r.class)))){var o=function(e){for(var t=e.data,n=e,a=e;s(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(t=Xn(a.data,t));for(;s(n=n.parent);)n&&n.data&&(t=Xn(t,n.data));return i=t.staticClass,r=t.class,s(i)||s(r)?Gn(i,Qn(r)):"";var i,r}(t),u=n._transitionClasses;s(u)&&(o=Gn(o,Qn(u))),o!==n._prevClass&&(n.setAttribute("class",o),n._prevClass=o)}}var Ma,Aa,_a,Ca,xa,Ia,Pa={create:ka,update:ka},Ra=/[\w).+\-_$\]]/;function Sa(e){var t,n,a,i,s,r=!1,o=!1,u=!1,p=!1,d=0,y=0,l=0,m=0;for(a=0;a<e.length;a++)if(n=t,t=e.charCodeAt(a),r)39===t&&92!==n&&(r=!1);else if(o)34===t&&92!==n&&(o=!1);else if(u)96===t&&92!==n&&(u=!1);else if(p)47===t&&92!==n&&(p=!1);else if(124!==t||124===e.charCodeAt(a+1)||124===e.charCodeAt(a-1)||d||y||l){switch(t){case 34:o=!0;break;case 39:r=!0;break;case 96:u=!0;break;case 40:l++;break;case 41:l--;break;case 91:y++;break;case 93:y--;break;case 123:d++;break;case 125:d--}if(47===t){for(var c=a-1,f=void 0;c>=0&&" "===(f=e.charAt(c));c--);f&&Ra.test(f)||(p=!0)}}else void 0===i?(m=a+1,i=e.slice(0,a).trim()):h();function h(){(s||(s=[])).push(e.slice(m,a).trim()),m=a+1}if(void 0===i?i=e.slice(0,a).trim():0!==m&&h(),s)for(a=0;a<s.length;a++)i=Ea(i,s[a]);return i}function Ea(e,t){var n=t.indexOf("(");if(n<0)return'_f("'+t+'")('+e+")";var a=t.slice(0,n),i=t.slice(n+1);return'_f("'+a+'")('+e+(")"!==i?","+i:i)}function Oa(e,t){console.error("[Vue compiler]: "+e)}function Ua(e,t){return e?e.map((function(e){return e[t]})).filter((function(e){return e})):[]}function Va(e,t,n,a,i){(e.props||(e.props=[])).push($a({name:t,value:n,dynamic:i},a)),e.plain=!1}function Da(e,t,n,a,i){(i?e.dynamicAttrs||(e.dynamicAttrs=[]):e.attrs||(e.attrs=[])).push($a({name:t,value:n,dynamic:i},a)),e.plain=!1}function La(e,t,n,a){e.attrsMap[t]=n,e.attrsList.push($a({name:t,value:n},a))}function Ba(e,t,n,a,i,s,r,o){(e.directives||(e.directives=[])).push($a({name:t,rawName:n,value:a,arg:i,isDynamicArg:s,modifiers:r},o)),e.plain=!1}function qa(e,t,n){return n?"_p("+t+',"'+e+'")':e+t}function Na(e,t,n,i,s,r,o,u){var p;(i=i||a).right?u?t="("+t+")==='click'?'contextmenu':("+t+")":"click"===t&&(t="contextmenu",delete i.right):i.middle&&(u?t="("+t+")==='click'?'mouseup':("+t+")":"click"===t&&(t="mouseup")),i.capture&&(delete i.capture,t=qa("!",t,u)),i.once&&(delete i.once,t=qa("~",t,u)),i.passive&&(delete i.passive,t=qa("&",t,u)),i.native?(delete i.native,p=e.nativeEvents||(e.nativeEvents={})):p=e.events||(e.events={});var d=$a({value:n.trim(),dynamic:u},o);i!==a&&(d.modifiers=i);var y=p[t];Array.isArray(y)?s?y.unshift(d):y.push(d):p[t]=y?s?[d,y]:[y,d]:d,e.plain=!1}function Fa(e,t,n){var a=za(e,":"+t)||za(e,"v-bind:"+t);if(null!=a)return Sa(a);if(!1!==n){var i=za(e,t);if(null!=i)return JSON.stringify(i)}}function za(e,t,n){var a;if(null!=(a=e.attrsMap[t]))for(var i=e.attrsList,s=0,r=i.length;s<r;s++)if(i[s].name===t){i.splice(s,1);break}return n&&delete e.attrsMap[t],a}function Ha(e,t){for(var n=e.attrsList,a=0,i=n.length;a<i;a++){var s=n[a];if(t.test(s.name))return n.splice(a,1),s}}function $a(e,t){return t&&(null!=t.start&&(e.start=t.start),null!=t.end&&(e.end=t.end)),e}function ja(e,t,n){var a=n||{},i=a.number,s="$$v";a.trim&&(s="(typeof $$v === 'string'? $$v.trim(): $$v)"),i&&(s="_n("+s+")");var r=Wa(t,s);e.model={value:"("+t+")",expression:JSON.stringify(t),callback:"function ($$v) {"+r+"}"}}function Wa(e,t){var n=function(e){if(e=e.trim(),Ma=e.length,e.indexOf("[")<0||e.lastIndexOf("]")<Ma-1)return(Ca=e.lastIndexOf("."))>-1?{exp:e.slice(0,Ca),key:'"'+e.slice(Ca+1)+'"'}:{exp:e,key:null};for(Aa=e,Ca=xa=Ia=0;!Ga();)Qa(_a=Xa())?Ja(_a):91===_a&&Ya(_a);return{exp:e.slice(0,xa),key:e.slice(xa+1,Ia)}}(e);return null===n.key?e+"="+t:"$set("+n.exp+", "+n.key+", "+t+")"}function Xa(){return Aa.charCodeAt(++Ca)}function Ga(){return Ca>=Ma}function Qa(e){return 34===e||39===e}function Ya(e){var t=1;for(xa=Ca;!Ga();)if(Qa(e=Xa()))Ja(e);else if(91===e&&t++,93===e&&t--,0===t){Ia=Ca;break}}function Ja(e){for(var t=e;!Ga()&&(e=Xa())!==t;);}var Ka;function Za(e,t,n){var a=Ka;return function i(){var s=t.apply(null,arguments);null!==s&&ni(e,i,n,a)}}var ei=Ye&&!(te&&Number(te[1])<=53);function ti(e,t,n,a){if(ei){var i=cn,s=t;t=s._wrapper=function(e){if(e.target===e.currentTarget||e.timeStamp>=i||e.timeStamp<=0||e.target.ownerDocument!==document)return s.apply(this,arguments)}}Ka.addEventListener(e,t,ae?{capture:n,passive:a}:n)}function ni(e,t,n,a){(a||Ka).removeEventListener(e,t._wrapper||t,n)}function ai(e,t){if(!i(e.data.on)||!i(t.data.on)){var n=t.data.on||{},a=e.data.on||{};Ka=t.elm,function(e){if(s(e.__r)){var t=J?"change":"input";e[t]=[].concat(e.__r,e[t]||[]),delete e.__r}s(e.__c)&&(e.change=[].concat(e.__c,e.change||[]),delete e.__c)}(n),dt(n,a,ti,ni,Za,t.context),Ka=void 0}}var ii,si={create:ai,update:ai};function ri(e,t){if(!i(e.data.domProps)||!i(t.data.domProps)){var n,a,r=t.elm,o=e.data.domProps||{},u=t.data.domProps||{};for(n in s(u.__ob__)&&(u=t.data.domProps=P({},u)),o)n in u||(r[n]="");for(n in u){if(a=u[n],"textContent"===n||"innerHTML"===n){if(t.children&&(t.children.length=0),a===o[n])continue;1===r.childNodes.length&&r.removeChild(r.childNodes[0])}if("value"===n&&"PROGRESS"!==r.tagName){r._value=a;var p=i(a)?"":String(a);oi(r,p)&&(r.value=p)}else if("innerHTML"===n&&Kn(r.tagName)&&i(r.innerHTML)){(ii=ii||document.createElement("div")).innerHTML="<svg>"+a+"</svg>";for(var d=ii.firstChild;r.firstChild;)r.removeChild(r.firstChild);for(;d.firstChild;)r.appendChild(d.firstChild)}else if(a!==o[n])try{r[n]=a}catch(e){}}}}function oi(e,t){return!e.composing&&("OPTION"===e.tagName||function(e,t){var n=!0;try{n=document.activeElement!==e}catch(e){}return n&&e.value!==t}(e,t)||function(e,t){var n=e.value,a=e._vModifiers;if(s(a)){if(a.number)return c(n)!==c(t);if(a.trim)return n.trim()!==t.trim()}return n!==t}(e,t))}var ui={create:ri,update:ri},pi=g((function(e){var t={},n=/:(.+)/;return e.split(/;(?![^(]*\))/g).forEach((function(e){if(e){var a=e.split(n);a.length>1&&(t[a[0].trim()]=a[1].trim())}})),t}));function di(e){var t=yi(e.style);return e.staticStyle?P(e.staticStyle,t):t}function yi(e){return Array.isArray(e)?R(e):"string"==typeof e?pi(e):e}var li,mi=/^--/,ci=/\s*!important$/,fi=function(e,t,n){if(mi.test(t))e.style.setProperty(t,n);else if(ci.test(n))e.style.setProperty(C(t),n.replace(ci,""),"important");else{var a=Ti(t);if(Array.isArray(n))for(var i=0,s=n.length;i<s;i++)e.style[a]=n[i];else e.style[a]=n}},hi=["Webkit","Moz","ms"],Ti=g((function(e){if(li=li||document.createElement("div").style,"filter"!==(e=M(e))&&e in li)return e;for(var t=e.charAt(0).toUpperCase()+e.slice(1),n=0;n<hi.length;n++){var a=hi[n]+t;if(a in li)return a}}));function bi(e,t){var n=t.data,a=e.data;if(!(i(n.staticStyle)&&i(n.style)&&i(a.staticStyle)&&i(a.style))){var r,o,u=t.elm,p=a.staticStyle,d=a.normalizedStyle||a.style||{},y=p||d,l=yi(t.data.style)||{};t.data.normalizedStyle=s(l.__ob__)?P({},l):l;var m=function(e,t){for(var n,a={},i=e;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(n=di(i.data))&&P(a,n);(n=di(e.data))&&P(a,n);for(var s=e;s=s.parent;)s.data&&(n=di(s.data))&&P(a,n);return a}(t);for(o in y)i(m[o])&&fi(u,o,"");for(o in m)(r=m[o])!==y[o]&&fi(u,o,null==r?"":r)}}var vi={create:bi,update:bi},wi=/\s+/;function gi(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(wi).forEach((function(t){return e.classList.add(t)})):e.classList.add(t);else{var n=" "+(e.getAttribute("class")||"")+" ";n.indexOf(" "+t+" ")<0&&e.setAttribute("class",(n+t).trim())}}function ki(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(wi).forEach((function(t){return e.classList.remove(t)})):e.classList.remove(t),e.classList.length||e.removeAttribute("class");else{for(var n=" "+(e.getAttribute("class")||"")+" ",a=" "+t+" ";n.indexOf(a)>=0;)n=n.replace(a," ");(n=n.trim())?e.setAttribute("class",n):e.removeAttribute("class")}}function Mi(e){if(e){if("object"==typeof e){var t={};return!1!==e.css&&P(t,Ai(e.name||"v")),P(t,e),t}return"string"==typeof e?Ai(e):void 0}}var Ai=g((function(e){return{enterClass:e+"-enter",enterToClass:e+"-enter-to",enterActiveClass:e+"-enter-active",leaveClass:e+"-leave",leaveToClass:e+"-leave-to",leaveActiveClass:e+"-leave-active"}})),_i=X&&!K,Ci="transition",xi="animation",Ii="transition",Pi="transitionend",Ri="animation",Si="animationend";_i&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Ii="WebkitTransition",Pi="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Ri="WebkitAnimation",Si="webkitAnimationEnd"));var Ei=X?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(e){return e()};function Oi(e){Ei((function(){Ei(e)}))}function Ui(e,t){var n=e._transitionClasses||(e._transitionClasses=[]);n.indexOf(t)<0&&(n.push(t),gi(e,t))}function Vi(e,t){e._transitionClasses&&b(e._transitionClasses,t),ki(e,t)}function Di(e,t,n){var a=Bi(e,t),i=a.type,s=a.timeout,r=a.propCount;if(!i)return n();var o=i===Ci?Pi:Si,u=0,p=function(){e.removeEventListener(o,d),n()},d=function(t){t.target===e&&++u>=r&&p()};setTimeout((function(){u<r&&p()}),s+1),e.addEventListener(o,d)}var Li=/\b(transform|all)(,|$)/;function Bi(e,t){var n,a=window.getComputedStyle(e),i=(a[Ii+"Delay"]||"").split(", "),s=(a[Ii+"Duration"]||"").split(", "),r=qi(i,s),o=(a[Ri+"Delay"]||"").split(", "),u=(a[Ri+"Duration"]||"").split(", "),p=qi(o,u),d=0,y=0;return t===Ci?r>0&&(n=Ci,d=r,y=s.length):t===xi?p>0&&(n=xi,d=p,y=u.length):y=(n=(d=Math.max(r,p))>0?r>p?Ci:xi:null)?n===Ci?s.length:u.length:0,{type:n,timeout:d,propCount:y,hasTransform:n===Ci&&Li.test(a[Ii+"Property"])}}function qi(e,t){for(;e.length<t.length;)e=e.concat(e);return Math.max.apply(null,t.map((function(t,n){return Ni(t)+Ni(e[n])})))}function Ni(e){return 1e3*Number(e.slice(0,-1).replace(",","."))}function Fi(e,t){var n=e.elm;s(n._leaveCb)&&(n._leaveCb.cancelled=!0,n._leaveCb());var a=Mi(e.data.transition);if(!i(a)&&!s(n._enterCb)&&1===n.nodeType){for(var r=a.css,o=a.type,p=a.enterClass,d=a.enterToClass,y=a.enterActiveClass,l=a.appearClass,m=a.appearToClass,f=a.appearActiveClass,h=a.beforeEnter,T=a.enter,b=a.afterEnter,v=a.enterCancelled,w=a.beforeAppear,g=a.appear,k=a.afterAppear,M=a.appearCancelled,A=a.duration,_=tn,C=tn.$vnode;C&&C.parent;)_=C.context,C=C.parent;var x=!_._isMounted||!e.isRootInsert;if(!x||g||""===g){var I=x&&l?l:p,P=x&&f?f:y,R=x&&m?m:d,S=x&&w||h,E=x&&"function"==typeof g?g:T,O=x&&k||b,U=x&&M||v,V=c(u(A)?A.enter:A),L=!1!==r&&!K,B=$i(E),q=n._enterCb=D((function(){L&&(Vi(n,R),Vi(n,P)),q.cancelled?(L&&Vi(n,I),U&&U(n)):O&&O(n),n._enterCb=null}));e.data.show||yt(e,"insert",(function(){var t=n.parentNode,a=t&&t._pending&&t._pending[e.key];a&&a.tag===e.tag&&a.elm._leaveCb&&a.elm._leaveCb(),E&&E(n,q)})),S&&S(n),L&&(Ui(n,I),Ui(n,P),Oi((function(){Vi(n,I),q.cancelled||(Ui(n,R),B||(Hi(V)?setTimeout(q,V):Di(n,o,q)))}))),e.data.show&&(t&&t(),E&&E(n,q)),L||B||q()}}}function zi(e,t){var n=e.elm;s(n._enterCb)&&(n._enterCb.cancelled=!0,n._enterCb());var a=Mi(e.data.transition);if(i(a)||1!==n.nodeType)return t();if(!s(n._leaveCb)){var r=a.css,o=a.type,p=a.leaveClass,d=a.leaveToClass,y=a.leaveActiveClass,l=a.beforeLeave,m=a.leave,f=a.afterLeave,h=a.leaveCancelled,T=a.delayLeave,b=a.duration,v=!1!==r&&!K,w=$i(m),g=c(u(b)?b.leave:b),k=n._leaveCb=D((function(){n.parentNode&&n.parentNode._pending&&(n.parentNode._pending[e.key]=null),v&&(Vi(n,d),Vi(n,y)),k.cancelled?(v&&Vi(n,p),h&&h(n)):(t(),f&&f(n)),n._leaveCb=null}));T?T(M):M()}function M(){k.cancelled||(!e.data.show&&n.parentNode&&((n.parentNode._pending||(n.parentNode._pending={}))[e.key]=e),l&&l(n),v&&(Ui(n,p),Ui(n,y),Oi((function(){Vi(n,p),k.cancelled||(Ui(n,d),w||(Hi(g)?setTimeout(k,g):Di(n,o,k)))}))),m&&m(n,k),v||w||k())}}function Hi(e){return"number"==typeof e&&!isNaN(e)}function $i(e){if(i(e))return!1;var t=e.fns;return s(t)?$i(Array.isArray(t)?t[0]:t):(e._length||e.length)>1}function ji(e,t){!0!==t.data.show&&Fi(t)}var Wi=function(e){var t,n,a={},u=e.modules,p=e.nodeOps;for(t=0;t<ua.length;++t)for(a[ua[t]]=[],n=0;n<u.length;++n)s(u[n][ua[t]])&&a[ua[t]].push(u[n][ua[t]]);function d(e){var t=p.parentNode(e);s(t)&&p.removeChild(t,e)}function y(e,t,n,i,o,u,d){if(s(e.elm)&&s(u)&&(e=u[d]=we(e)),e.isRootInsert=!o,!function(e,t,n,i){var o=e.data;if(s(o)){var u=s(e.componentInstance)&&o.keepAlive;if(s(o=o.hook)&&s(o=o.init)&&o(e,!1),s(e.componentInstance))return l(e,t),m(n,e.elm,i),r(u)&&function(e,t,n,i){for(var r,o=e;o.componentInstance;)if(s(r=(o=o.componentInstance._vnode).data)&&s(r=r.transition)){for(r=0;r<a.activate.length;++r)a.activate[r](oa,o);t.push(o);break}m(n,e.elm,i)}(e,t,n,i),!0}}(e,t,n,i)){var y=e.data,f=e.children,h=e.tag;s(h)?(e.elm=e.ns?p.createElementNS(e.ns,h):p.createElement(h,e),b(e),c(e,f,t),s(y)&&T(e,t),m(n,e.elm,i)):r(e.isComment)?(e.elm=p.createComment(e.text),m(n,e.elm,i)):(e.elm=p.createTextNode(e.text),m(n,e.elm,i))}}function l(e,t){s(e.data.pendingInsert)&&(t.push.apply(t,e.data.pendingInsert),e.data.pendingInsert=null),e.elm=e.componentInstance.$el,h(e)?(T(e,t),b(e)):(ra(e),t.push(e))}function m(e,t,n){s(e)&&(s(n)?p.parentNode(n)===e&&p.insertBefore(e,t,n):p.appendChild(e,t))}function c(e,t,n){if(Array.isArray(t))for(var a=0;a<t.length;++a)y(t[a],n,e.elm,null,!0,t,a);else o(e.text)&&p.appendChild(e.elm,p.createTextNode(String(e.text)))}function h(e){for(;e.componentInstance;)e=e.componentInstance._vnode;return s(e.tag)}function T(e,n){for(var i=0;i<a.create.length;++i)a.create[i](oa,e);s(t=e.data.hook)&&(s(t.create)&&t.create(oa,e),s(t.insert)&&n.push(e))}function b(e){var t;if(s(t=e.fnScopeId))p.setStyleScope(e.elm,t);else for(var n=e;n;)s(t=n.context)&&s(t=t.$options._scopeId)&&p.setStyleScope(e.elm,t),n=n.parent;s(t=tn)&&t!==e.context&&t!==e.fnContext&&s(t=t.$options._scopeId)&&p.setStyleScope(e.elm,t)}function v(e,t,n,a,i,s){for(;a<=i;++a)y(n[a],s,e,t,!1,n,a)}function w(e){var t,n,i=e.data;if(s(i))for(s(t=i.hook)&&s(t=t.destroy)&&t(e),t=0;t<a.destroy.length;++t)a.destroy[t](e);if(s(t=e.children))for(n=0;n<e.children.length;++n)w(e.children[n])}function g(e,t,n){for(;t<=n;++t){var a=e[t];s(a)&&(s(a.tag)?(k(a),w(a)):d(a.elm))}}function k(e,t){if(s(t)||s(e.data)){var n,i=a.remove.length+1;for(s(t)?t.listeners+=i:t=function(e,t){function n(){0==--n.listeners&&d(e)}return n.listeners=t,n}(e.elm,i),s(n=e.componentInstance)&&s(n=n._vnode)&&s(n.data)&&k(n,t),n=0;n<a.remove.length;++n)a.remove[n](e,t);s(n=e.data.hook)&&s(n=n.remove)?n(e,t):t()}else d(e.elm)}function M(e,t,n,a){for(var i=n;i<a;i++){var r=t[i];if(s(r)&&pa(e,r))return i}}function A(e,t,n,o,u,d){if(e!==t){s(t.elm)&&s(o)&&(t=o[u]=we(t));var l=t.elm=e.elm;if(r(e.isAsyncPlaceholder))s(t.asyncFactory.resolved)?x(e.elm,t,n):t.isAsyncPlaceholder=!0;else if(r(t.isStatic)&&r(e.isStatic)&&t.key===e.key&&(r(t.isCloned)||r(t.isOnce)))t.componentInstance=e.componentInstance;else{var m,c=t.data;s(c)&&s(m=c.hook)&&s(m=m.prepatch)&&m(e,t);var f=e.children,T=t.children;if(s(c)&&h(t)){for(m=0;m<a.update.length;++m)a.update[m](e,t);s(m=c.hook)&&s(m=m.update)&&m(e,t)}i(t.text)?s(f)&&s(T)?f!==T&&function(e,t,n,a,r){for(var o,u,d,l=0,m=0,c=t.length-1,f=t[0],h=t[c],T=n.length-1,b=n[0],w=n[T],k=!r;l<=c&&m<=T;)i(f)?f=t[++l]:i(h)?h=t[--c]:pa(f,b)?(A(f,b,a,n,m),f=t[++l],b=n[++m]):pa(h,w)?(A(h,w,a,n,T),h=t[--c],w=n[--T]):pa(f,w)?(A(f,w,a,n,T),k&&p.insertBefore(e,f.elm,p.nextSibling(h.elm)),f=t[++l],w=n[--T]):pa(h,b)?(A(h,b,a,n,m),k&&p.insertBefore(e,h.elm,f.elm),h=t[--c],b=n[++m]):(i(o)&&(o=da(t,l,c)),i(u=s(b.key)?o[b.key]:M(b,t,l,c))?y(b,a,e,f.elm,!1,n,m):pa(d=t[u],b)?(A(d,b,a,n,m),t[u]=void 0,k&&p.insertBefore(e,d.elm,f.elm)):y(b,a,e,f.elm,!1,n,m),b=n[++m]);l>c?v(e,i(n[T+1])?null:n[T+1].elm,n,m,T,a):m>T&&g(t,l,c)}(l,f,T,n,d):s(T)?(s(e.text)&&p.setTextContent(l,""),v(l,null,T,0,T.length-1,n)):s(f)?g(f,0,f.length-1):s(e.text)&&p.setTextContent(l,""):e.text!==t.text&&p.setTextContent(l,t.text),s(c)&&s(m=c.hook)&&s(m=m.postpatch)&&m(e,t)}}}function _(e,t,n){if(r(n)&&s(e.parent))e.parent.data.pendingInsert=t;else for(var a=0;a<t.length;++a)t[a].data.hook.insert(t[a])}var C=f("attrs,class,staticClass,staticStyle,key");function x(e,t,n,a){var i,o=t.tag,u=t.data,p=t.children;if(a=a||u&&u.pre,t.elm=e,r(t.isComment)&&s(t.asyncFactory))return t.isAsyncPlaceholder=!0,!0;if(s(u)&&(s(i=u.hook)&&s(i=i.init)&&i(t,!0),s(i=t.componentInstance)))return l(t,n),!0;if(s(o)){if(s(p))if(e.hasChildNodes())if(s(i=u)&&s(i=i.domProps)&&s(i=i.innerHTML)){if(i!==e.innerHTML)return!1}else{for(var d=!0,y=e.firstChild,m=0;m<p.length;m++){if(!y||!x(y,p[m],n,a)){d=!1;break}y=y.nextSibling}if(!d||y)return!1}else c(t,p,n);if(s(u)){var f=!1;for(var h in u)if(!C(h)){f=!0,T(t,n);break}!f&&u.class&&rt(u.class)}}else e.data!==t.text&&(e.data=t.text);return!0}return function(e,t,n,o){if(!i(t)){var u,d=!1,l=[];if(i(e))d=!0,y(t,l);else{var m=s(e.nodeType);if(!m&&pa(e,t))A(e,t,l,null,null,o);else{if(m){if(1===e.nodeType&&e.hasAttribute(L)&&(e.removeAttribute(L),n=!0),r(n)&&x(e,t,l))return _(t,l,!0),e;u=e,e=new he(p.tagName(u).toLowerCase(),{},[],void 0,u)}var c=e.elm,f=p.parentNode(c);if(y(t,l,c._leaveCb?null:f,p.nextSibling(c)),s(t.parent))for(var T=t.parent,b=h(t);T;){for(var v=0;v<a.destroy.length;++v)a.destroy[v](T);if(T.elm=t.elm,b){for(var k=0;k<a.create.length;++k)a.create[k](oa,T);var M=T.data.hook.insert;if(M.merged)for(var C=1;C<M.fns.length;C++)M.fns[C]()}else ra(T);T=T.parent}s(f)?g([e],0,0):s(e.tag)&&w(e)}}return _(t,l,d),t.elm}s(e)&&w(e)}}({nodeOps:ia,modules:[ga,Pa,si,ui,vi,X?{create:ji,activate:ji,remove:function(e,t){!0!==e.data.show?zi(e,t):t()}}:{}].concat(Ta)});K&&document.addEventListener("selectionchange",(function(){var e=document.activeElement;e&&e.vmodel&&es(e,"input")}));var Xi={inserted:function(e,t,n,a){"select"===n.tag?(a.elm&&!a.elm._vOptions?yt(n,"postpatch",(function(){Xi.componentUpdated(e,t,n)})):Gi(e,t,n.context),e._vOptions=[].map.call(e.options,Ji)):("textarea"===n.tag||na(e.type))&&(e._vModifiers=t.modifiers,t.modifiers.lazy||(e.addEventListener("compositionstart",Ki),e.addEventListener("compositionend",Zi),e.addEventListener("change",Zi),K&&(e.vmodel=!0)))},componentUpdated:function(e,t,n){if("select"===n.tag){Gi(e,t,n.context);var a=e._vOptions,i=e._vOptions=[].map.call(e.options,Ji);i.some((function(e,t){return!U(e,a[t])}))&&(e.multiple?t.value.some((function(e){return Yi(e,i)})):t.value!==t.oldValue&&Yi(t.value,i))&&es(e,"change")}}};function Gi(e,t,n){Qi(e,t),(J||Z)&&setTimeout((function(){Qi(e,t)}),0)}function Qi(e,t,n){var a=t.value,i=e.multiple;if(!i||Array.isArray(a)){for(var s,r,o=0,u=e.options.length;o<u;o++)if(r=e.options[o],i)s=V(a,Ji(r))>-1,r.selected!==s&&(r.selected=s);else if(U(Ji(r),a))return void(e.selectedIndex!==o&&(e.selectedIndex=o));i||(e.selectedIndex=-1)}}function Yi(e,t){return t.every((function(t){return!U(t,e)}))}function Ji(e){return"_value"in e?e._value:e.value}function Ki(e){e.target.composing=!0}function Zi(e){e.target.composing&&(e.target.composing=!1,es(e.target,"input"))}function es(e,t){var n=document.createEvent("HTMLEvents");n.initEvent(t,!0,!0),e.dispatchEvent(n)}function ts(e){return!e.componentInstance||e.data&&e.data.transition?e:ts(e.componentInstance._vnode)}var ns={bind:function(e,t,n){var a=t.value,i=(n=ts(n)).data&&n.data.transition,s=e.__vOriginalDisplay="none"===e.style.display?"":e.style.display;a&&i?(n.data.show=!0,Fi(n,(function(){e.style.display=s}))):e.style.display=a?s:"none"},update:function(e,t,n){var a=t.value;!a!=!t.oldValue&&((n=ts(n)).data&&n.data.transition?(n.data.show=!0,a?Fi(n,(function(){e.style.display=e.__vOriginalDisplay})):zi(n,(function(){e.style.display="none"}))):e.style.display=a?e.__vOriginalDisplay:"none")},unbind:function(e,t,n,a,i){i||(e.style.display=e.__vOriginalDisplay)}},as={model:Xi,show:ns},is={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function ss(e){var t=e&&e.componentOptions;return t&&t.Ctor.options.abstract?ss(Yt(t.children)):e}function rs(e){var t={},n=e.$options;for(var a in n.propsData)t[a]=e[a];var i=n._parentListeners;for(var s in i)t[M(s)]=i[s];return t}function os(e,t){if(/\d-keep-alive$/.test(t.tag))return e("keep-alive",{props:t.componentOptions.propsData})}var us=function(e){return e.tag||vt(e)},ps=function(e){return"show"===e.name},ds={name:"transition",props:is,abstract:!0,render:function(e){var t=this,n=this.$slots.default;if(n&&(n=n.filter(us)).length){var a=this.mode,i=n[0];if(function(e){for(;e=e.parent;)if(e.data.transition)return!0}(this.$vnode))return i;var s=ss(i);if(!s)return i;if(this._leaving)return os(e,i);var r="__transition-"+this._uid+"-";s.key=null==s.key?s.isComment?r+"comment":r+s.tag:o(s.key)?0===String(s.key).indexOf(r)?s.key:r+s.key:s.key;var u=(s.data||(s.data={})).transition=rs(this),p=this._vnode,d=ss(p);if(s.data.directives&&s.data.directives.some(ps)&&(s.data.show=!0),d&&d.data&&!function(e,t){return t.key===e.key&&t.tag===e.tag}(s,d)&&!vt(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var y=d.data.transition=P({},u);if("out-in"===a)return this._leaving=!0,yt(y,"afterLeave",(function(){t._leaving=!1,t.$forceUpdate()})),os(e,i);if("in-out"===a){if(vt(s))return p;var l,m=function(){l()};yt(u,"afterEnter",m),yt(u,"enterCancelled",m),yt(y,"delayLeave",(function(e){l=e}))}}return i}}},ys=P({tag:String,moveClass:String},is);delete ys.mode;var ls={props:ys,beforeMount:function(){var e=this,t=this._update;this._update=function(n,a){var i=nn(e);e.__patch__(e._vnode,e.kept,!1,!0),e._vnode=e.kept,i(),t.call(e,n,a)}},render:function(e){for(var t=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),a=this.prevChildren=this.children,i=this.$slots.default||[],s=this.children=[],r=rs(this),o=0;o<i.length;o++){var u=i[o];u.tag&&null!=u.key&&0!==String(u.key).indexOf("__vlist")&&(s.push(u),n[u.key]=u,(u.data||(u.data={})).transition=r)}if(a){for(var p=[],d=[],y=0;y<a.length;y++){var l=a[y];l.data.transition=r,l.data.pos=l.elm.getBoundingClientRect(),n[l.key]?p.push(l):d.push(l)}this.kept=e(t,null,p),this.removed=d}return e(t,null,s)},updated:function(){var e=this.prevChildren,t=this.moveClass||(this.name||"v")+"-move";e.length&&this.hasMove(e[0].elm,t)&&(e.forEach(ms),e.forEach(cs),e.forEach(fs),this._reflow=document.body.offsetHeight,e.forEach((function(e){if(e.data.moved){var n=e.elm,a=n.style;Ui(n,t),a.transform=a.WebkitTransform=a.transitionDuration="",n.addEventListener(Pi,n._moveCb=function e(a){a&&a.target!==n||a&&!/transform$/.test(a.propertyName)||(n.removeEventListener(Pi,e),n._moveCb=null,Vi(n,t))})}})))},methods:{hasMove:function(e,t){if(!_i)return!1;if(this._hasMove)return this._hasMove;var n=e.cloneNode();e._transitionClasses&&e._transitionClasses.forEach((function(e){ki(n,e)})),gi(n,t),n.style.display="none",this.$el.appendChild(n);var a=Bi(n);return this.$el.removeChild(n),this._hasMove=a.hasTransform}}};function ms(e){e.elm._moveCb&&e.elm._moveCb(),e.elm._enterCb&&e.elm._enterCb()}function cs(e){e.data.newPos=e.elm.getBoundingClientRect()}function fs(e){var t=e.data.pos,n=e.data.newPos,a=t.left-n.left,i=t.top-n.top;if(a||i){e.data.moved=!0;var s=e.elm.style;s.transform=s.WebkitTransform="translate("+a+"px,"+i+"px)",s.transitionDuration="0s"}}var hs={Transition:ds,TransitionGroup:ls};Pn.config.mustUseProp=qn,Pn.config.isReservedTag=Zn,Pn.config.isReservedAttr=Ln,Pn.config.getTagNamespace=ea,Pn.config.isUnknownElement=function(e){if(!X)return!0;if(Zn(e))return!1;if(e=e.toLowerCase(),null!=ta[e])return ta[e];var t=document.createElement(e);return e.indexOf("-")>-1?ta[e]=t.constructor===window.HTMLUnknownElement||t.constructor===window.HTMLElement:ta[e]=/HTMLUnknownElement/.test(t.toString())},P(Pn.options.directives,as),P(Pn.options.components,hs),Pn.prototype.__patch__=X?Wi:S,Pn.prototype.$mount=function(e,t){return function(e,t,n){var a;return e.$el=t,e.$options.render||(e.$options.render=be),on(e,"beforeMount"),a=function(){e._update(e._render(),n)},new vn(e,a,S,{before:function(){e._isMounted&&!e._isDestroyed&&on(e,"beforeUpdate")}},!0),n=!1,null==e.$vnode&&(e._isMounted=!0,on(e,"mounted")),e}(this,e=e&&X?aa(e):void 0,t)},X&&setTimeout((function(){N.devtools&&re&&re.emit("init",Pn)}),0);var Ts,bs=/\{\{((?:.|\r?\n)+?)\}\}/g,vs=/[-.*+?^${}()|[\]\/\\]/g,ws=g((function(e){var t=e[0].replace(vs,"\\$&"),n=e[1].replace(vs,"\\$&");return new RegExp(t+"((?:.|\\n)+?)"+n,"g")})),gs={staticKeys:["staticClass"],transformNode:function(e,t){t.warn;var n=za(e,"class");n&&(e.staticClass=JSON.stringify(n));var a=Fa(e,"class",!1);a&&(e.classBinding=a)},genData:function(e){var t="";return e.staticClass&&(t+="staticClass:"+e.staticClass+","),e.classBinding&&(t+="class:"+e.classBinding+","),t}},ks={staticKeys:["staticStyle"],transformNode:function(e,t){t.warn;var n=za(e,"style");n&&(e.staticStyle=JSON.stringify(pi(n)));var a=Fa(e,"style",!1);a&&(e.styleBinding=a)},genData:function(e){var t="";return e.staticStyle&&(t+="staticStyle:"+e.staticStyle+","),e.styleBinding&&(t+="style:("+e.styleBinding+"),"),t}},Ms=f("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),As=f("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),_s=f("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"),Cs=/^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,xs=/^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,Is="[a-zA-Z_][\\-\\.0-9_a-zA-Z"+F.source+"]*",Ps="((?:"+Is+"\\:)?"+Is+")",Rs=new RegExp("^<"+Ps),Ss=/^\s*(\/?)>/,Es=new RegExp("^<\\/"+Ps+"[^>]*>"),Os=/^<!DOCTYPE [^>]+>/i,Us=/^<!\--/,Vs=/^<!\[/,Ds=f("script,style,textarea",!0),Ls={},Bs={"&lt;":"<","&gt;":">","&quot;":'"',"&amp;":"&","&#10;":"\n","&#9;":"\t","&#39;":"'"},qs=/&(?:lt|gt|quot|amp|#39);/g,Ns=/&(?:lt|gt|quot|amp|#39|#10|#9);/g,Fs=f("pre,textarea",!0),zs=function(e,t){return e&&Fs(e)&&"\n"===t[0]};function Hs(e,t){var n=t?Ns:qs;return e.replace(n,(function(e){return Bs[e]}))}var $s,js,Ws,Xs,Gs,Qs,Ys,Js,Ks=/^@|^v-on:/,Zs=/^v-|^@|^:|^#/,er=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,tr=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,nr=/^\(|\)$/g,ar=/^\[.*\]$/,ir=/:(.*)$/,sr=/^:|^\.|^v-bind:/,rr=/\.[^.\]]+(?=[^\]]*$)/g,or=/^v-slot(:|$)|^#/,ur=/[\r\n]/,pr=/[ \f\t\r\n]+/g,dr=g((function(e){return(Ts=Ts||document.createElement("div")).innerHTML=e,Ts.textContent})),yr="_empty_";function lr(e,t,n){return{type:1,tag:e,attrsList:t,attrsMap:br(t),rawAttrsMap:{},parent:n,children:[]}}function mr(e,t){var n;!function(e){var t=Fa(e,"key");t&&(e.key=t)}(e),e.plain=!e.key&&!e.scopedSlots&&!e.attrsList.length,function(e){var t=Fa(e,"ref");t&&(e.ref=t,e.refInFor=function(e){for(var t=e;t;){if(void 0!==t.for)return!0;t=t.parent}return!1}(e))}(e),function(e){var t;"template"===e.tag?(t=za(e,"scope"),e.slotScope=t||za(e,"slot-scope")):(t=za(e,"slot-scope"))&&(e.slotScope=t);var n=Fa(e,"slot");if(n&&(e.slotTarget='""'===n?'"default"':n,e.slotTargetDynamic=!(!e.attrsMap[":slot"]&&!e.attrsMap["v-bind:slot"]),"template"===e.tag||e.slotScope||Da(e,"slot",n,function(e,t){return e.rawAttrsMap[":slot"]||e.rawAttrsMap["v-bind:slot"]||e.rawAttrsMap.slot}(e))),"template"===e.tag){var a=Ha(e,or);if(a){var i=hr(a),s=i.name,r=i.dynamic;e.slotTarget=s,e.slotTargetDynamic=r,e.slotScope=a.value||yr}}else{var o=Ha(e,or);if(o){var u=e.scopedSlots||(e.scopedSlots={}),p=hr(o),d=p.name,y=p.dynamic,l=u[d]=lr("template",[],e);l.slotTarget=d,l.slotTargetDynamic=y,l.children=e.children.filter((function(e){if(!e.slotScope)return e.parent=l,!0})),l.slotScope=o.value||yr,e.children=[],e.plain=!1}}}(e),"slot"===(n=e).tag&&(n.slotName=Fa(n,"name")),function(e){var t;(t=Fa(e,"is"))&&(e.component=t),null!=za(e,"inline-template")&&(e.inlineTemplate=!0)}(e);for(var a=0;a<Ws.length;a++)e=Ws[a](e,t)||e;return function(e){var t,n,a,i,s,r,o,u,p=e.attrsList;for(t=0,n=p.length;t<n;t++)if(a=i=p[t].name,s=p[t].value,Zs.test(a))if(e.hasBindings=!0,(r=Tr(a.replace(Zs,"")))&&(a=a.replace(rr,"")),sr.test(a))a=a.replace(sr,""),s=Sa(s),(u=ar.test(a))&&(a=a.slice(1,-1)),r&&(r.prop&&!u&&"innerHtml"===(a=M(a))&&(a="innerHTML"),r.camel&&!u&&(a=M(a)),r.sync&&(o=Wa(s,"$event"),u?Na(e,'"update:"+('+a+")",o,null,!1,0,p[t],!0):(Na(e,"update:"+M(a),o,null,!1,0,p[t]),C(a)!==M(a)&&Na(e,"update:"+C(a),o,null,!1,0,p[t])))),r&&r.prop||!e.component&&Ys(e.tag,e.attrsMap.type,a)?Va(e,a,s,p[t],u):Da(e,a,s,p[t],u);else if(Ks.test(a))a=a.replace(Ks,""),(u=ar.test(a))&&(a=a.slice(1,-1)),Na(e,a,s,r,!1,0,p[t],u);else{var d=(a=a.replace(Zs,"")).match(ir),y=d&&d[1];u=!1,y&&(a=a.slice(0,-(y.length+1)),ar.test(y)&&(y=y.slice(1,-1),u=!0)),Ba(e,a,i,s,y,u,r,p[t])}else Da(e,a,JSON.stringify(s),p[t]),!e.component&&"muted"===a&&Ys(e.tag,e.attrsMap.type,a)&&Va(e,a,"true",p[t])}(e),e}function cr(e){var t;if(t=za(e,"v-for")){var n=function(e){var t=e.match(er);if(t){var n={};n.for=t[2].trim();var a=t[1].trim().replace(nr,""),i=a.match(tr);return i?(n.alias=a.replace(tr,"").trim(),n.iterator1=i[1].trim(),i[2]&&(n.iterator2=i[2].trim())):n.alias=a,n}}(t);n&&P(e,n)}}function fr(e,t){e.ifConditions||(e.ifConditions=[]),e.ifConditions.push(t)}function hr(e){var t=e.name.replace(or,"");return t||"#"!==e.name[0]&&(t="default"),ar.test(t)?{name:t.slice(1,-1),dynamic:!0}:{name:'"'+t+'"',dynamic:!1}}function Tr(e){var t=e.match(rr);if(t){var n={};return t.forEach((function(e){n[e.slice(1)]=!0})),n}}function br(e){for(var t={},n=0,a=e.length;n<a;n++)t[e[n].name]=e[n].value;return t}var vr=/^xmlns:NS\d+/,wr=/^NS\d+:/;function gr(e){return lr(e.tag,e.attrsList.slice(),e.parent)}var kr,Mr,Ar,_r=[gs,ks,{preTransformNode:function(e,t){if("input"===e.tag){var n,a=e.attrsMap;if(!a["v-model"])return;if((a[":type"]||a["v-bind:type"])&&(n=Fa(e,"type")),a.type||n||!a["v-bind"]||(n="("+a["v-bind"]+").type"),n){var i=za(e,"v-if",!0),s=i?"&&("+i+")":"",r=null!=za(e,"v-else",!0),o=za(e,"v-else-if",!0),u=gr(e);cr(u),La(u,"type","checkbox"),mr(u,t),u.processed=!0,u.if="("+n+")==='checkbox'"+s,fr(u,{exp:u.if,block:u});var p=gr(e);za(p,"v-for",!0),La(p,"type","radio"),mr(p,t),fr(u,{exp:"("+n+")==='radio'"+s,block:p});var d=gr(e);return za(d,"v-for",!0),La(d,":type",n),mr(d,t),fr(u,{exp:i,block:d}),r?u.else=!0:o&&(u.elseif=o),u}}}}],Cr={model:function(e,t,n){var a=t.value,i=t.modifiers,s=e.tag,r=e.attrsMap.type;if(e.component)return ja(e,a,i),!1;if("select"===s)!function(e,t,n){var a='var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return '+(n&&n.number?"_n(val)":"val")+"});";Na(e,"change",a=a+" "+Wa(t,"$event.target.multiple ? $$selectedVal : $$selectedVal[0]"),null,!0)}(e,a,i);else if("input"===s&&"checkbox"===r)!function(e,t,n){var a=n&&n.number,i=Fa(e,"value")||"null",s=Fa(e,"true-value")||"true",r=Fa(e,"false-value")||"false";Va(e,"checked","Array.isArray("+t+")?_i("+t+","+i+")>-1"+("true"===s?":("+t+")":":_q("+t+","+s+")")),Na(e,"change","var $$a="+t+",$$el=$event.target,$$c=$$el.checked?("+s+"):("+r+");if(Array.isArray($$a)){var $$v="+(a?"_n("+i+")":i)+",$$i=_i($$a,$$v);if($$el.checked){$$i<0&&("+Wa(t,"$$a.concat([$$v])")+")}else{$$i>-1&&("+Wa(t,"$$a.slice(0,$$i).concat($$a.slice($$i+1))")+")}}else{"+Wa(t,"$$c")+"}",null,!0)}(e,a,i);else if("input"===s&&"radio"===r)!function(e,t,n){var a=n&&n.number,i=Fa(e,"value")||"null";Va(e,"checked","_q("+t+","+(i=a?"_n("+i+")":i)+")"),Na(e,"change",Wa(t,i),null,!0)}(e,a,i);else if("input"===s||"textarea"===s)!function(e,t,n){var a=e.attrsMap.type,i=n||{},s=i.lazy,r=i.number,o=i.trim,u=!s&&"range"!==a,p=s?"change":"range"===a?"__r":"input",d="$event.target.value";o&&(d="$event.target.value.trim()"),r&&(d="_n("+d+")");var y=Wa(t,d);u&&(y="if($event.target.composing)return;"+y),Va(e,"value","("+t+")"),Na(e,p,y,null,!0),(o||r)&&Na(e,"blur","$forceUpdate()")}(e,a,i);else if(!N.isReservedTag(s))return ja(e,a,i),!1;return!0},text:function(e,t){t.value&&Va(e,"textContent","_s("+t.value+")",t)},html:function(e,t){t.value&&Va(e,"innerHTML","_s("+t.value+")",t)}},xr={expectHTML:!0,modules:_r,directives:Cr,isPreTag:function(e){return"pre"===e},isUnaryTag:Ms,mustUseProp:qn,canBeLeftOpenTag:As,isReservedTag:Zn,getTagNamespace:ea,staticKeys:(Ar=_r,Ar.reduce((function(e,t){return e.concat(t.staticKeys||[])}),[]).join(","))},Ir=g((function(e){return f("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap"+(e?","+e:""))}));function Pr(e,t){e&&(kr=Ir(t.staticKeys||""),Mr=t.isReservedTag||E,Rr(e),Sr(e,!1))}function Rr(e){if(e.static=function(e){return 2!==e.type&&(3===e.type||!(!e.pre&&(e.hasBindings||e.if||e.for||h(e.tag)||!Mr(e.tag)||function(e){for(;e.parent;){if("template"!==(e=e.parent).tag)return!1;if(e.for)return!0}return!1}(e)||!Object.keys(e).every(kr))))}(e),1===e.type){if(!Mr(e.tag)&&"slot"!==e.tag&&null==e.attrsMap["inline-template"])return;for(var t=0,n=e.children.length;t<n;t++){var a=e.children[t];Rr(a),a.static||(e.static=!1)}if(e.ifConditions)for(var i=1,s=e.ifConditions.length;i<s;i++){var r=e.ifConditions[i].block;Rr(r),r.static||(e.static=!1)}}}function Sr(e,t){if(1===e.type){if((e.static||e.once)&&(e.staticInFor=t),e.static&&e.children.length&&(1!==e.children.length||3!==e.children[0].type))return void(e.staticRoot=!0);if(e.staticRoot=!1,e.children)for(var n=0,a=e.children.length;n<a;n++)Sr(e.children[n],t||!!e.for);if(e.ifConditions)for(var i=1,s=e.ifConditions.length;i<s;i++)Sr(e.ifConditions[i].block,t)}}var Er=/^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/,Or=/\([^)]*?\);*$/,Ur=/^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/,Vr={esc:27,tab:9,enter:13,space:32,up:38,left:37,right:39,down:40,delete:[8,46]},Dr={esc:["Esc","Escape"],tab:"Tab",enter:"Enter",space:[" ","Spacebar"],up:["Up","ArrowUp"],left:["Left","ArrowLeft"],right:["Right","ArrowRight"],down:["Down","ArrowDown"],delete:["Backspace","Delete","Del"]},Lr=function(e){return"if("+e+")return null;"},Br={stop:"$event.stopPropagation();",prevent:"$event.preventDefault();",self:Lr("$event.target !== $event.currentTarget"),ctrl:Lr("!$event.ctrlKey"),shift:Lr("!$event.shiftKey"),alt:Lr("!$event.altKey"),meta:Lr("!$event.metaKey"),left:Lr("'button' in $event && $event.button !== 0"),middle:Lr("'button' in $event && $event.button !== 1"),right:Lr("'button' in $event && $event.button !== 2")};function qr(e,t){var n=t?"nativeOn:":"on:",a="",i="";for(var s in e){var r=Nr(e[s]);e[s]&&e[s].dynamic?i+=s+","+r+",":a+='"'+s+'":'+r+","}return a="{"+a.slice(0,-1)+"}",i?n+"_d("+a+",["+i.slice(0,-1)+"])":n+a}function Nr(e){if(!e)return"function(){}";if(Array.isArray(e))return"["+e.map((function(e){return Nr(e)})).join(",")+"]";var t=Ur.test(e.value),n=Er.test(e.value),a=Ur.test(e.value.replace(Or,""));if(e.modifiers){var i="",s="",r=[];for(var o in e.modifiers)if(Br[o])s+=Br[o],Vr[o]&&r.push(o);else if("exact"===o){var u=e.modifiers;s+=Lr(["ctrl","shift","alt","meta"].filter((function(e){return!u[e]})).map((function(e){return"$event."+e+"Key"})).join("||"))}else r.push(o);return r.length&&(i+=function(e){return"if(!$event.type.indexOf('key')&&"+e.map(Fr).join("&&")+")return null;"}(r)),s&&(i+=s),"function($event){"+i+(t?"return "+e.value+".apply(null, arguments)":n?"return ("+e.value+").apply(null, arguments)":a?"return "+e.value:e.value)+"}"}return t||n?e.value:"function($event){"+(a?"return "+e.value:e.value)+"}"}function Fr(e){var t=parseInt(e,10);if(t)return"$event.keyCode!=="+t;var n=Vr[e],a=Dr[e];return"_k($event.keyCode,"+JSON.stringify(e)+","+JSON.stringify(n)+",$event.key,"+JSON.stringify(a)+")"}var zr={on:function(e,t){e.wrapListeners=function(e){return"_g("+e+","+t.value+")"}},bind:function(e,t){e.wrapData=function(n){return"_b("+n+",'"+e.tag+"',"+t.value+","+(t.modifiers&&t.modifiers.prop?"true":"false")+(t.modifiers&&t.modifiers.sync?",true":"")+")"}},cloak:S},Hr=function(e){this.options=e,this.warn=e.warn||Oa,this.transforms=Ua(e.modules,"transformCode"),this.dataGenFns=Ua(e.modules,"genData"),this.directives=P(P({},zr),e.directives);var t=e.isReservedTag||E;this.maybeComponent=function(e){return!!e.component||!t(e.tag)},this.onceId=0,this.staticRenderFns=[],this.pre=!1};function $r(e,t){var n=new Hr(t);return{render:"with(this){return "+(e?"script"===e.tag?"null":jr(e,n):'_c("div")')+"}",staticRenderFns:n.staticRenderFns}}function jr(e,t){if(e.parent&&(e.pre=e.pre||e.parent.pre),e.staticRoot&&!e.staticProcessed)return Wr(e,t);if(e.once&&!e.onceProcessed)return Xr(e,t);if(e.for&&!e.forProcessed)return Yr(e,t);if(e.if&&!e.ifProcessed)return Gr(e,t);if("template"!==e.tag||e.slotTarget||t.pre){if("slot"===e.tag)return function(e,t){var n=e.slotName||'"default"',a=eo(e,t),i="_t("+n+(a?",function(){return "+a+"}":""),s=e.attrs||e.dynamicAttrs?ao((e.attrs||[]).concat(e.dynamicAttrs||[]).map((function(e){return{name:M(e.name),value:e.value,dynamic:e.dynamic}}))):null,r=e.attrsMap["v-bind"];return!s&&!r||a||(i+=",null"),s&&(i+=","+s),r&&(i+=(s?"":",null")+","+r),i+")"}(e,t);var n;if(e.component)n=function(e,t,n){var a=t.inlineTemplate?null:eo(t,n,!0);return"_c("+e+","+Jr(t,n)+(a?","+a:"")+")"}(e.component,e,t);else{var a;(!e.plain||e.pre&&t.maybeComponent(e))&&(a=Jr(e,t));var i=e.inlineTemplate?null:eo(e,t,!0);n="_c('"+e.tag+"'"+(a?","+a:"")+(i?","+i:"")+")"}for(var s=0;s<t.transforms.length;s++)n=t.transforms[s](e,n);return n}return eo(e,t)||"void 0"}function Wr(e,t){e.staticProcessed=!0;var n=t.pre;return e.pre&&(t.pre=e.pre),t.staticRenderFns.push("with(this){return "+jr(e,t)+"}"),t.pre=n,"_m("+(t.staticRenderFns.length-1)+(e.staticInFor?",true":"")+")"}function Xr(e,t){if(e.onceProcessed=!0,e.if&&!e.ifProcessed)return Gr(e,t);if(e.staticInFor){for(var n="",a=e.parent;a;){if(a.for){n=a.key;break}a=a.parent}return n?"_o("+jr(e,t)+","+t.onceId+++","+n+")":jr(e,t)}return Wr(e,t)}function Gr(e,t,n,a){return e.ifProcessed=!0,Qr(e.ifConditions.slice(),t,n,a)}function Qr(e,t,n,a){if(!e.length)return a||"_e()";var i=e.shift();return i.exp?"("+i.exp+")?"+s(i.block)+":"+Qr(e,t,n,a):""+s(i.block);function s(e){return n?n(e,t):e.once?Xr(e,t):jr(e,t)}}function Yr(e,t,n,a){var i=e.for,s=e.alias,r=e.iterator1?","+e.iterator1:"",o=e.iterator2?","+e.iterator2:"";return e.forProcessed=!0,(a||"_l")+"(("+i+"),function("+s+r+o+"){return "+(n||jr)(e,t)+"})"}function Jr(e,t){var n="{",a=function(e,t){var n=e.directives;if(n){var a,i,s,r,o="directives:[",u=!1;for(a=0,i=n.length;a<i;a++){s=n[a],r=!0;var p=t.directives[s.name];p&&(r=!!p(e,s,t.warn)),r&&(u=!0,o+='{name:"'+s.name+'",rawName:"'+s.rawName+'"'+(s.value?",value:("+s.value+"),expression:"+JSON.stringify(s.value):"")+(s.arg?",arg:"+(s.isDynamicArg?s.arg:'"'+s.arg+'"'):"")+(s.modifiers?",modifiers:"+JSON.stringify(s.modifiers):"")+"},")}return u?o.slice(0,-1)+"]":void 0}}(e,t);a&&(n+=a+","),e.key&&(n+="key:"+e.key+","),e.ref&&(n+="ref:"+e.ref+","),e.refInFor&&(n+="refInFor:true,"),e.pre&&(n+="pre:true,"),e.component&&(n+='tag:"'+e.tag+'",');for(var i=0;i<t.dataGenFns.length;i++)n+=t.dataGenFns[i](e);if(e.attrs&&(n+="attrs:"+ao(e.attrs)+","),e.props&&(n+="domProps:"+ao(e.props)+","),e.events&&(n+=qr(e.events,!1)+","),e.nativeEvents&&(n+=qr(e.nativeEvents,!0)+","),e.slotTarget&&!e.slotScope&&(n+="slot:"+e.slotTarget+","),e.scopedSlots&&(n+=function(e,t,n){var a=e.for||Object.keys(t).some((function(e){var n=t[e];return n.slotTargetDynamic||n.if||n.for||Kr(n)})),i=!!e.if;if(!a)for(var s=e.parent;s;){if(s.slotScope&&s.slotScope!==yr||s.for){a=!0;break}s.if&&(i=!0),s=s.parent}var r=Object.keys(t).map((function(e){return Zr(t[e],n)})).join(",");return"scopedSlots:_u(["+r+"]"+(a?",null,true":"")+(!a&&i?",null,false,"+function(e){for(var t=5381,n=e.length;n;)t=33*t^e.charCodeAt(--n);return t>>>0}(r):"")+")"}(e,e.scopedSlots,t)+","),e.model&&(n+="model:{value:"+e.model.value+",callback:"+e.model.callback+",expression:"+e.model.expression+"},"),e.inlineTemplate){var s=function(e,t){var n=e.children[0];if(n&&1===n.type){var a=$r(n,t.options);return"inlineTemplate:{render:function(){"+a.render+"},staticRenderFns:["+a.staticRenderFns.map((function(e){return"function(){"+e+"}"})).join(",")+"]}"}}(e,t);s&&(n+=s+",")}return n=n.replace(/,$/,"")+"}",e.dynamicAttrs&&(n="_b("+n+',"'+e.tag+'",'+ao(e.dynamicAttrs)+")"),e.wrapData&&(n=e.wrapData(n)),e.wrapListeners&&(n=e.wrapListeners(n)),n}function Kr(e){return 1===e.type&&("slot"===e.tag||e.children.some(Kr))}function Zr(e,t){var n=e.attrsMap["slot-scope"];if(e.if&&!e.ifProcessed&&!n)return Gr(e,t,Zr,"null");if(e.for&&!e.forProcessed)return Yr(e,t,Zr);var a=e.slotScope===yr?"":String(e.slotScope),i="function("+a+"){return "+("template"===e.tag?e.if&&n?"("+e.if+")?"+(eo(e,t)||"undefined")+":undefined":eo(e,t)||"undefined":jr(e,t))+"}",s=a?"":",proxy:true";return"{key:"+(e.slotTarget||'"default"')+",fn:"+i+s+"}"}function eo(e,t,n,a,i){var s=e.children;if(s.length){var r=s[0];if(1===s.length&&r.for&&"template"!==r.tag&&"slot"!==r.tag){var o=n?t.maybeComponent(r)?",1":",0":"";return""+(a||jr)(r,t)+o}var u=n?function(e,t){for(var n=0,a=0;a<e.length;a++){var i=e[a];if(1===i.type){if(to(i)||i.ifConditions&&i.ifConditions.some((function(e){return to(e.block)}))){n=2;break}(t(i)||i.ifConditions&&i.ifConditions.some((function(e){return t(e.block)})))&&(n=1)}}return n}(s,t.maybeComponent):0,p=i||no;return"["+s.map((function(e){return p(e,t)})).join(",")+"]"+(u?","+u:"")}}function to(e){return void 0!==e.for||"template"===e.tag||"slot"===e.tag}function no(e,t){return 1===e.type?jr(e,t):3===e.type&&e.isComment?function(e){return"_e("+JSON.stringify(e.text)+")"}(e):"_v("+(2===(n=e).type?n.expression:io(JSON.stringify(n.text)))+")";var n}function ao(e){for(var t="",n="",a=0;a<e.length;a++){var i=e[a],s=io(i.value);i.dynamic?n+=i.name+","+s+",":t+='"'+i.name+'":'+s+","}return t="{"+t.slice(0,-1)+"}",n?"_d("+t+",["+n.slice(0,-1)+"])":t}function io(e){return e.replace(/\u2028/g,"\\u2028").replace(/\u2029/g,"\\u2029")}function so(e,t){try{return new Function(e)}catch(n){return t.push({err:n,code:e}),S}}function ro(e){var t=Object.create(null);return function(n,a,i){(a=P({},a)).warn,delete a.warn;var s=a.delimiters?String(a.delimiters)+n:n;if(t[s])return t[s];var r=e(n,a),o={},u=[];return o.render=so(r.render,u),o.staticRenderFns=r.staticRenderFns.map((function(e){return so(e,u)})),t[s]=o}}new RegExp("\\b"+"do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments".split(",").join("\\b|\\b")+"\\b"),new RegExp("\\b"+"delete,typeof,void".split(",").join("\\s*\\([^\\)]*\\)|\\b")+"\\s*\\([^\\)]*\\)");var oo,uo,po=(oo=function(e,t){var n=function(e,t){$s=t.warn||Oa,Qs=t.isPreTag||E,Ys=t.mustUseProp||E,Js=t.getTagNamespace||E,t.isReservedTag,Ws=Ua(t.modules,"transformNode"),Xs=Ua(t.modules,"preTransformNode"),Gs=Ua(t.modules,"postTransformNode"),js=t.delimiters;var n,a,i=[],s=!1!==t.preserveWhitespace,r=t.whitespace,o=!1,u=!1;function p(e){if(d(e),o||e.processed||(e=mr(e,t)),i.length||e===n||n.if&&(e.elseif||e.else)&&fr(n,{exp:e.elseif,block:e}),a&&!e.forbidden)if(e.elseif||e.else)r=e,p=function(e){for(var t=e.length;t--;){if(1===e[t].type)return e[t];e.pop()}}(a.children),p&&p.if&&fr(p,{exp:r.elseif,block:r});else{if(e.slotScope){var s=e.slotTarget||'"default"';(a.scopedSlots||(a.scopedSlots={}))[s]=e}a.children.push(e),e.parent=a}var r,p;e.children=e.children.filter((function(e){return!e.slotScope})),d(e),e.pre&&(o=!1),Qs(e.tag)&&(u=!1);for(var y=0;y<Gs.length;y++)Gs[y](e,t)}function d(e){if(!u)for(var t;(t=e.children[e.children.length-1])&&3===t.type&&" "===t.text;)e.children.pop()}return function(e,t){for(var n,a,i=[],s=t.expectHTML,r=t.isUnaryTag||E,o=t.canBeLeftOpenTag||E,u=0;e;){if(n=e,a&&Ds(a)){var p=0,d=a.toLowerCase(),y=Ls[d]||(Ls[d]=new RegExp("([\\s\\S]*?)(</"+d+"[^>]*>)","i")),l=e.replace(y,(function(e,n,a){return p=a.length,Ds(d)||"noscript"===d||(n=n.replace(/<!\--([\s\S]*?)-->/g,"$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g,"$1")),zs(d,n)&&(n=n.slice(1)),t.chars&&t.chars(n),""}));u+=e.length-l.length,e=l,C(d,u-p,u)}else{var m=e.indexOf("<");if(0===m){if(Us.test(e)){var c=e.indexOf("--\x3e");if(c>=0){t.shouldKeepComment&&t.comment(e.substring(4,c),u,u+c+3),M(c+3);continue}}if(Vs.test(e)){var f=e.indexOf("]>");if(f>=0){M(f+2);continue}}var h=e.match(Os);if(h){M(h[0].length);continue}var T=e.match(Es);if(T){var b=u;M(T[0].length),C(T[1],b,u);continue}var v=A();if(v){_(v),zs(v.tagName,e)&&M(1);continue}}var w=void 0,g=void 0,k=void 0;if(m>=0){for(g=e.slice(m);!(Es.test(g)||Rs.test(g)||Us.test(g)||Vs.test(g)||(k=g.indexOf("<",1))<0);)m+=k,g=e.slice(m);w=e.substring(0,m)}m<0&&(w=e),w&&M(w.length),t.chars&&w&&t.chars(w,u-w.length,u)}if(e===n){t.chars&&t.chars(e);break}}function M(t){u+=t,e=e.substring(t)}function A(){var t=e.match(Rs);if(t){var n,a,i={tagName:t[1],attrs:[],start:u};for(M(t[0].length);!(n=e.match(Ss))&&(a=e.match(xs)||e.match(Cs));)a.start=u,M(a[0].length),a.end=u,i.attrs.push(a);if(n)return i.unarySlash=n[1],M(n[0].length),i.end=u,i}}function _(e){var n=e.tagName,u=e.unarySlash;s&&("p"===a&&_s(n)&&C(a),o(n)&&a===n&&C(n));for(var p=r(n)||!!u,d=e.attrs.length,y=new Array(d),l=0;l<d;l++){var m=e.attrs[l],c=m[3]||m[4]||m[5]||"",f="a"===n&&"href"===m[1]?t.shouldDecodeNewlinesForHref:t.shouldDecodeNewlines;y[l]={name:m[1],value:Hs(c,f)}}p||(i.push({tag:n,lowerCasedTag:n.toLowerCase(),attrs:y,start:e.start,end:e.end}),a=n),t.start&&t.start(n,y,p,e.start,e.end)}function C(e,n,s){var r,o;if(null==n&&(n=u),null==s&&(s=u),e)for(o=e.toLowerCase(),r=i.length-1;r>=0&&i[r].lowerCasedTag!==o;r--);else r=0;if(r>=0){for(var p=i.length-1;p>=r;p--)t.end&&t.end(i[p].tag,n,s);i.length=r,a=r&&i[r-1].tag}else"br"===o?t.start&&t.start(e,[],!0,n,s):"p"===o&&(t.start&&t.start(e,[],!1,n,s),t.end&&t.end(e,n,s))}C()}(e,{warn:$s,expectHTML:t.expectHTML,isUnaryTag:t.isUnaryTag,canBeLeftOpenTag:t.canBeLeftOpenTag,shouldDecodeNewlines:t.shouldDecodeNewlines,shouldDecodeNewlinesForHref:t.shouldDecodeNewlinesForHref,shouldKeepComment:t.comments,outputSourceRange:t.outputSourceRange,start:function(e,s,r,d,y){var l=a&&a.ns||Js(e);J&&"svg"===l&&(s=function(e){for(var t=[],n=0;n<e.length;n++){var a=e[n];vr.test(a.name)||(a.name=a.name.replace(wr,""),t.push(a))}return t}(s));var m,c=lr(e,s,a);l&&(c.ns=l),"style"!==(m=c).tag&&("script"!==m.tag||m.attrsMap.type&&"text/javascript"!==m.attrsMap.type)||se()||(c.forbidden=!0);for(var f=0;f<Xs.length;f++)c=Xs[f](c,t)||c;o||(function(e){null!=za(e,"v-pre")&&(e.pre=!0)}(c),c.pre&&(o=!0)),Qs(c.tag)&&(u=!0),o?function(e){var t=e.attrsList,n=t.length;if(n)for(var a=e.attrs=new Array(n),i=0;i<n;i++)a[i]={name:t[i].name,value:JSON.stringify(t[i].value)},null!=t[i].start&&(a[i].start=t[i].start,a[i].end=t[i].end);else e.pre||(e.plain=!0)}(c):c.processed||(cr(c),function(e){var t=za(e,"v-if");if(t)e.if=t,fr(e,{exp:t,block:e});else{null!=za(e,"v-else")&&(e.else=!0);var n=za(e,"v-else-if");n&&(e.elseif=n)}}(c),function(e){null!=za(e,"v-once")&&(e.once=!0)}(c)),n||(n=c),r?p(c):(a=c,i.push(c))},end:function(e,t,n){var s=i[i.length-1];i.length-=1,a=i[i.length-1],p(s)},chars:function(e,t,n){if(a&&(!J||"textarea"!==a.tag||a.attrsMap.placeholder!==e)){var i,p,d,y=a.children;(e=u||e.trim()?"script"===(i=a).tag||"style"===i.tag?e:dr(e):y.length?r?"condense"===r&&ur.test(e)?"":" ":s?" ":"":"")&&(u||"condense"!==r||(e=e.replace(pr," ")),!o&&" "!==e&&(p=function(e,t){var n=t?ws(t):bs;if(n.test(e)){for(var a,i,s,r=[],o=[],u=n.lastIndex=0;a=n.exec(e);){(i=a.index)>u&&(o.push(s=e.slice(u,i)),r.push(JSON.stringify(s)));var p=Sa(a[1].trim());r.push("_s("+p+")"),o.push({"@binding":p}),u=i+a[0].length}return u<e.length&&(o.push(s=e.slice(u)),r.push(JSON.stringify(s))),{expression:r.join("+"),tokens:o}}}(e,js))?d={type:2,expression:p.expression,tokens:p.tokens,text:e}:" "===e&&y.length&&" "===y[y.length-1].text||(d={type:3,text:e}),d&&y.push(d))}},comment:function(e,t,n){if(a){var i={type:3,text:e,isComment:!0};a.children.push(i)}}}),n}(e.trim(),t);!1!==t.optimize&&Pr(n,t);var a=$r(n,t);return{ast:n,render:a.render,staticRenderFns:a.staticRenderFns}},function(e){function t(t,n){var a=Object.create(e),i=[],s=[];if(n)for(var r in n.modules&&(a.modules=(e.modules||[]).concat(n.modules)),n.directives&&(a.directives=P(Object.create(e.directives||null),n.directives)),n)"modules"!==r&&"directives"!==r&&(a[r]=n[r]);a.warn=function(e,t,n){(n?s:i).push(e)};var o=oo(t.trim(),a);return o.errors=i,o.tips=s,o}return{compile:t,compileToFunctions:ro(t)}}),yo=po(xr),lo=(yo.compile,yo.compileToFunctions);function mo(e){return(uo=uo||document.createElement("div")).innerHTML=e?'<a href="\n"/>':'<div a="\n"/>',uo.innerHTML.indexOf("&#10;")>0}var co=!!X&&mo(!1),fo=!!X&&mo(!0),ho=g((function(e){var t=aa(e);return t&&t.innerHTML})),To=Pn.prototype.$mount;Pn.prototype.$mount=function(e,t){if((e=e&&aa(e))===document.body||e===document.documentElement)return this;var n=this.$options;if(!n.render){var a=n.template;if(a)if("string"==typeof a)"#"===a.charAt(0)&&(a=ho(a));else{if(!a.nodeType)return this;a=a.innerHTML}else e&&(a=function(e){if(e.outerHTML)return e.outerHTML;var t=document.createElement("div");return t.appendChild(e.cloneNode(!0)),t.innerHTML}(e));if(a){var i=lo(a,{outputSourceRange:!1,shouldDecodeNewlines:co,shouldDecodeNewlinesForHref:fo,delimiters:n.delimiters,comments:n.comments},this),s=i.render,r=i.staticRenderFns;n.render=s,n.staticRenderFns=r}}return To.call(this,e,t)},Pn.compile=lo;const bo=Pn;function vo(e,t){for(var n in t)e[n]=t[n];return e}var wo=/[!'()*]/g,go=function(e){return"%"+e.charCodeAt(0).toString(16)},ko=/%2C/g,Mo=function(e){return encodeURIComponent(e).replace(wo,go).replace(ko,",")};function Ao(e){try{return decodeURIComponent(e)}catch(e){}return e}var _o=function(e){return null==e||"object"==typeof e?e:String(e)};function Co(e){var t={};return(e=e.trim().replace(/^(\?|#|&)/,""))?(e.split("&").forEach((function(e){var n=e.replace(/\+/g," ").split("="),a=Ao(n.shift()),i=n.length>0?Ao(n.join("=")):null;void 0===t[a]?t[a]=i:Array.isArray(t[a])?t[a].push(i):t[a]=[t[a],i]})),t):t}function xo(e){var t=e?Object.keys(e).map((function(t){var n=e[t];if(void 0===n)return"";if(null===n)return Mo(t);if(Array.isArray(n)){var a=[];return n.forEach((function(e){void 0!==e&&(null===e?a.push(Mo(t)):a.push(Mo(t)+"="+Mo(e)))})),a.join("&")}return Mo(t)+"="+Mo(n)})).filter((function(e){return e.length>0})).join("&"):null;return t?"?"+t:""}var Io=/\/?$/;function Po(e,t,n,a){var i=a&&a.options.stringifyQuery,s=t.query||{};try{s=Ro(s)}catch(e){}var r={name:t.name||e&&e.name,meta:e&&e.meta||{},path:t.path||"/",hash:t.hash||"",query:s,params:t.params||{},fullPath:Oo(t,i),matched:e?Eo(e):[]};return n&&(r.redirectedFrom=Oo(n,i)),Object.freeze(r)}function Ro(e){if(Array.isArray(e))return e.map(Ro);if(e&&"object"==typeof e){var t={};for(var n in e)t[n]=Ro(e[n]);return t}return e}var So=Po(null,{path:"/"});function Eo(e){for(var t=[];e;)t.unshift(e),e=e.parent;return t}function Oo(e,t){var n=e.path,a=e.query;void 0===a&&(a={});var i=e.hash;return void 0===i&&(i=""),(n||"/")+(t||xo)(a)+i}function Uo(e,t,n){return t===So?e===t:!!t&&(e.path&&t.path?e.path.replace(Io,"")===t.path.replace(Io,"")&&(n||e.hash===t.hash&&Vo(e.query,t.query)):!(!e.name||!t.name)&&e.name===t.name&&(n||e.hash===t.hash&&Vo(e.query,t.query)&&Vo(e.params,t.params)))}function Vo(e,t){if(void 0===e&&(e={}),void 0===t&&(t={}),!e||!t)return e===t;var n=Object.keys(e).sort(),a=Object.keys(t).sort();return n.length===a.length&&n.every((function(n,i){var s=e[n];if(a[i]!==n)return!1;var r=t[n];return null==s||null==r?s===r:"object"==typeof s&&"object"==typeof r?Vo(s,r):String(s)===String(r)}))}function Do(e){for(var t=0;t<e.matched.length;t++){var n=e.matched[t];for(var a in n.instances){var i=n.instances[a],s=n.enteredCbs[a];if(i&&s){delete n.enteredCbs[a];for(var r=0;r<s.length;r++)i._isBeingDestroyed||s[r](i)}}}}var Lo={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(e,t){var n=t.props,a=t.children,i=t.parent,s=t.data;s.routerView=!0;for(var r=i.$createElement,o=n.name,u=i.$route,p=i._routerViewCache||(i._routerViewCache={}),d=0,y=!1;i&&i._routerRoot!==i;){var l=i.$vnode?i.$vnode.data:{};l.routerView&&d++,l.keepAlive&&i._directInactive&&i._inactive&&(y=!0),i=i.$parent}if(s.routerViewDepth=d,y){var m=p[o],c=m&&m.component;return c?(m.configProps&&Bo(c,s,m.route,m.configProps),r(c,s,a)):r()}var f=u.matched[d],h=f&&f.components[o];if(!f||!h)return p[o]=null,r();p[o]={component:h},s.registerRouteInstance=function(e,t){var n=f.instances[o];(t&&n!==e||!t&&n===e)&&(f.instances[o]=t)},(s.hook||(s.hook={})).prepatch=function(e,t){f.instances[o]=t.componentInstance},s.hook.init=function(e){e.data.keepAlive&&e.componentInstance&&e.componentInstance!==f.instances[o]&&(f.instances[o]=e.componentInstance),Do(u)};var T=f.props&&f.props[o];return T&&(vo(p[o],{route:u,configProps:T}),Bo(h,s,u,T)),r(h,s,a)}};function Bo(e,t,n,a){var i=t.props=function(e,t){switch(typeof t){case"undefined":return;case"object":return t;case"function":return t(e);case"boolean":return t?e.params:void 0}}(n,a);if(i){i=t.props=vo({},i);var s=t.attrs=t.attrs||{};for(var r in i)e.props&&r in e.props||(s[r]=i[r],delete i[r])}}function qo(e,t,n){var a=e.charAt(0);if("/"===a)return e;if("?"===a||"#"===a)return t+e;var i=t.split("/");n&&i[i.length-1]||i.pop();for(var s=e.replace(/^\//,"").split("/"),r=0;r<s.length;r++){var o=s[r];".."===o?i.pop():"."!==o&&i.push(o)}return""!==i[0]&&i.unshift(""),i.join("/")}function No(e){return e.replace(/\/+/g,"/")}var Fo=Array.isArray||function(e){return"[object Array]"==Object.prototype.toString.call(e)},zo=function e(t,n,a){return Fo(n)||(a=n||a,n=[]),a=a||{},t instanceof RegExp?function(e,t){var n=e.source.match(/\((?!\?)/g);if(n)for(var a=0;a<n.length;a++)t.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Zo(e,t)}(t,n):Fo(t)?function(t,n,a){for(var i=[],s=0;s<t.length;s++)i.push(e(t[s],n,a).source);return Zo(new RegExp("(?:"+i.join("|")+")",eu(a)),n)}(t,n,a):function(e,t,n){return tu(Xo(e,n),t,n)}(t,n,a)},Ho=Xo,$o=Yo,jo=tu,Wo=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Xo(e,t){for(var n,a=[],i=0,s=0,r="",o=t&&t.delimiter||"/";null!=(n=Wo.exec(e));){var u=n[0],p=n[1],d=n.index;if(r+=e.slice(s,d),s=d+u.length,p)r+=p[1];else{var y=e[s],l=n[2],m=n[3],c=n[4],f=n[5],h=n[6],T=n[7];r&&(a.push(r),r="");var b=null!=l&&null!=y&&y!==l,v="+"===h||"*"===h,w="?"===h||"*"===h,g=n[2]||o,k=c||f;a.push({name:m||i++,prefix:l||"",delimiter:g,optional:w,repeat:v,partial:b,asterisk:!!T,pattern:k?Ko(k):T?".*":"[^"+Jo(g)+"]+?"})}}return s<e.length&&(r+=e.substr(s)),r&&a.push(r),a}function Go(e){return encodeURI(e).replace(/[\/?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function Qo(e){return encodeURI(e).replace(/[?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function Yo(e,t){for(var n=new Array(e.length),a=0;a<e.length;a++)"object"==typeof e[a]&&(n[a]=new RegExp("^(?:"+e[a].pattern+")$",eu(t)));return function(t,a){for(var i="",s=t||{},r=(a||{}).pretty?Go:encodeURIComponent,o=0;o<e.length;o++){var u=e[o];if("string"!=typeof u){var p,d=s[u.name];if(null==d){if(u.optional){u.partial&&(i+=u.prefix);continue}throw new TypeError('Expected "'+u.name+'" to be defined')}if(Fo(d)){if(!u.repeat)throw new TypeError('Expected "'+u.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(u.optional)continue;throw new TypeError('Expected "'+u.name+'" to not be empty')}for(var y=0;y<d.length;y++){if(p=r(d[y]),!n[o].test(p))throw new TypeError('Expected all "'+u.name+'" to match "'+u.pattern+'", but received `'+JSON.stringify(p)+"`");i+=(0===y?u.prefix:u.delimiter)+p}}else{if(p=u.asterisk?Qo(d):r(d),!n[o].test(p))throw new TypeError('Expected "'+u.name+'" to match "'+u.pattern+'", but received "'+p+'"');i+=u.prefix+p}}else i+=u}return i}}function Jo(e){return e.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Ko(e){return e.replace(/([=!:$\/()])/g,"\\$1")}function Zo(e,t){return e.keys=t,e}function eu(e){return e&&e.sensitive?"":"i"}function tu(e,t,n){Fo(t)||(n=t||n,t=[]);for(var a=(n=n||{}).strict,i=!1!==n.end,s="",r=0;r<e.length;r++){var o=e[r];if("string"==typeof o)s+=Jo(o);else{var u=Jo(o.prefix),p="(?:"+o.pattern+")";t.push(o),o.repeat&&(p+="(?:"+u+p+")*"),s+=p=o.optional?o.partial?u+"("+p+")?":"(?:"+u+"("+p+"))?":u+"("+p+")"}}var d=Jo(n.delimiter||"/"),y=s.slice(-d.length)===d;return a||(s=(y?s.slice(0,-d.length):s)+"(?:"+d+"(?=$))?"),s+=i?"$":a&&y?"":"(?="+d+"|$)",Zo(new RegExp("^"+s,eu(n)),t)}zo.parse=Ho,zo.compile=function(e,t){return Yo(Xo(e,t),t)},zo.tokensToFunction=$o,zo.tokensToRegExp=jo;var nu=Object.create(null);function au(e,t,n){t=t||{};try{var a=nu[e]||(nu[e]=zo.compile(e));return"string"==typeof t.pathMatch&&(t[0]=t.pathMatch),a(t,{pretty:!0})}catch(e){return""}finally{delete t[0]}}function iu(e,t,n,a){var i="string"==typeof e?{path:e}:e;if(i._normalized)return i;if(i.name){var s=(i=vo({},e)).params;return s&&"object"==typeof s&&(i.params=vo({},s)),i}if(!i.path&&i.params&&t){(i=vo({},i))._normalized=!0;var r=vo(vo({},t.params),i.params);if(t.name)i.name=t.name,i.params=r;else if(t.matched.length){var o=t.matched[t.matched.length-1].path;i.path=au(o,r,t.path)}return i}var u=function(e){var t="",n="",a=e.indexOf("#");a>=0&&(t=e.slice(a),e=e.slice(0,a));var i=e.indexOf("?");return i>=0&&(n=e.slice(i+1),e=e.slice(0,i)),{path:e,query:n,hash:t}}(i.path||""),p=t&&t.path||"/",d=u.path?qo(u.path,p,n||i.append):p,y=function(e,t,n){void 0===t&&(t={});var a,i=n||Co;try{a=i(e||"")}catch(e){a={}}for(var s in t){var r=t[s];a[s]=Array.isArray(r)?r.map(_o):_o(r)}return a}(u.query,i.query,a&&a.options.parseQuery),l=i.hash||u.hash;return l&&"#"!==l.charAt(0)&&(l="#"+l),{_normalized:!0,path:d,query:y,hash:l}}var su,ru=function(){},ou={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(e){var t=this,n=this.$router,a=this.$route,i=n.resolve(this.to,a,this.append),s=i.location,r=i.route,o=i.href,u={},p=n.options.linkActiveClass,d=n.options.linkExactActiveClass,y=null==p?"router-link-active":p,l=null==d?"router-link-exact-active":d,m=null==this.activeClass?y:this.activeClass,c=null==this.exactActiveClass?l:this.exactActiveClass,f=r.redirectedFrom?Po(null,iu(r.redirectedFrom),null,n):r;u[c]=Uo(a,f,this.exactPath),u[m]=this.exact||this.exactPath?u[c]:function(e,t){return 0===e.path.replace(Io,"/").indexOf(t.path.replace(Io,"/"))&&(!t.hash||e.hash===t.hash)&&function(e,t){for(var n in t)if(!(n in e))return!1;return!0}(e.query,t.query)}(a,f);var h=u[c]?this.ariaCurrentValue:null,T=function(e){uu(e)&&(t.replace?n.replace(s,ru):n.push(s,ru))},b={click:uu};Array.isArray(this.event)?this.event.forEach((function(e){b[e]=T})):b[this.event]=T;var v={class:u},w=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:o,route:r,navigate:T,isActive:u[m],isExactActive:u[c]});if(w){if(1===w.length)return w[0];if(w.length>1||!w.length)return 0===w.length?e():e("span",{},w)}if("a"===this.tag)v.on=b,v.attrs={href:o,"aria-current":h};else{var g=pu(this.$slots.default);if(g){g.isStatic=!1;var k=g.data=vo({},g.data);for(var M in k.on=k.on||{},k.on){var A=k.on[M];M in b&&(k.on[M]=Array.isArray(A)?A:[A])}for(var _ in b)_ in k.on?k.on[_].push(b[_]):k.on[_]=T;var C=g.data.attrs=vo({},g.data.attrs);C.href=o,C["aria-current"]=h}else v.on=b}return e(this.tag,v,this.$slots.default)}};function uu(e){if(!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey||e.defaultPrevented||void 0!==e.button&&0!==e.button)){if(e.currentTarget&&e.currentTarget.getAttribute){var t=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(t))return}return e.preventDefault&&e.preventDefault(),!0}}function pu(e){if(e)for(var t,n=0;n<e.length;n++){if("a"===(t=e[n]).tag)return t;if(t.children&&(t=pu(t.children)))return t}}var du="undefined"!=typeof window;function yu(e,t,n,a,i){var s=t||[],r=n||Object.create(null),o=a||Object.create(null);e.forEach((function(e){lu(s,r,o,e,i)}));for(var u=0,p=s.length;u<p;u++)"*"===s[u]&&(s.push(s.splice(u,1)[0]),p--,u--);return{pathList:s,pathMap:r,nameMap:o}}function lu(e,t,n,a,i,s){var r=a.path,o=a.name,u=a.pathToRegexpOptions||{},p=function(e,t,n){return n||(e=e.replace(/\/$/,"")),"/"===e[0]||null==t?e:No(t.path+"/"+e)}(r,i,u.strict);"boolean"==typeof a.caseSensitive&&(u.sensitive=a.caseSensitive);var d={path:p,regex:mu(p,u),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:o,parent:i,matchAs:s,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};if(a.children&&a.children.forEach((function(a){var i=s?No(s+"/"+a.path):void 0;lu(e,t,n,a,d,i)})),t[d.path]||(e.push(d.path),t[d.path]=d),void 0!==a.alias)for(var y=Array.isArray(a.alias)?a.alias:[a.alias],l=0;l<y.length;++l){var m={path:y[l],children:a.children};lu(e,t,n,m,i,d.path||"/")}o&&(n[o]||(n[o]=d))}function mu(e,t){return zo(e,[],t)}function cu(e,t){var n=yu(e),a=n.pathList,i=n.pathMap,s=n.nameMap;function r(e,n,r){var u=iu(e,n,!1,t),p=u.name;if(p){var d=s[p];if(!d)return o(null,u);var y=d.regex.keys.filter((function(e){return!e.optional})).map((function(e){return e.name}));if("object"!=typeof u.params&&(u.params={}),n&&"object"==typeof n.params)for(var l in n.params)!(l in u.params)&&y.indexOf(l)>-1&&(u.params[l]=n.params[l]);return u.path=au(d.path,u.params),o(d,u,r)}if(u.path){u.params={};for(var m=0;m<a.length;m++){var c=a[m],f=i[c];if(fu(f.regex,u.path,u.params))return o(f,u,r)}}return o(null,u)}function o(e,n,a){return e&&e.redirect?function(e,n){var a=e.redirect,i="function"==typeof a?a(Po(e,n,null,t)):a;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return o(null,n);var u=i,p=u.name,d=u.path,y=n.query,l=n.hash,m=n.params;if(y=u.hasOwnProperty("query")?u.query:y,l=u.hasOwnProperty("hash")?u.hash:l,m=u.hasOwnProperty("params")?u.params:m,p)return s[p],r({_normalized:!0,name:p,query:y,hash:l,params:m},void 0,n);if(d){var c=function(e,t){return qo(e,t.parent?t.parent.path:"/",!0)}(d,e);return r({_normalized:!0,path:au(c,m),query:y,hash:l},void 0,n)}return o(null,n)}(e,a||n):e&&e.matchAs?function(e,t,n){var a=r({_normalized:!0,path:au(n,t.params)});if(a){var i=a.matched,s=i[i.length-1];return t.params=a.params,o(s,t)}return o(null,t)}(0,n,e.matchAs):Po(e,n,a,t)}return{match:r,addRoute:function(e,t){var n="object"!=typeof e?s[e]:void 0;yu([t||e],a,i,s,n),n&&n.alias.length&&yu(n.alias.map((function(e){return{path:e,children:[t]}})),a,i,s,n)},getRoutes:function(){return a.map((function(e){return i[e]}))},addRoutes:function(e){yu(e,a,i,s)}}}function fu(e,t,n){var a=t.match(e);if(!a)return!1;if(!n)return!0;for(var i=1,s=a.length;i<s;++i){var r=e.keys[i-1];r&&(n[r.name||"pathMatch"]="string"==typeof a[i]?Ao(a[i]):a[i])}return!0}var hu=du&&window.performance&&window.performance.now?window.performance:Date;function Tu(){return hu.now().toFixed(3)}var bu=Tu();function vu(){return bu}function wu(e){return bu=e}var gu=Object.create(null);function ku(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var e=window.location.protocol+"//"+window.location.host,t=window.location.href.replace(e,""),n=vo({},window.history.state);return n.key=vu(),window.history.replaceState(n,"",t),window.addEventListener("popstate",_u),function(){window.removeEventListener("popstate",_u)}}function Mu(e,t,n,a){if(e.app){var i=e.options.scrollBehavior;i&&e.app.$nextTick((function(){var s=function(){var e=vu();if(e)return gu[e]}(),r=i.call(e,t,n,a?s:null);r&&("function"==typeof r.then?r.then((function(e){Ru(e,s)})).catch((function(e){})):Ru(r,s))}))}}function Au(){var e=vu();e&&(gu[e]={x:window.pageXOffset,y:window.pageYOffset})}function _u(e){Au(),e.state&&e.state.key&&wu(e.state.key)}function Cu(e){return Iu(e.x)||Iu(e.y)}function xu(e){return{x:Iu(e.x)?e.x:window.pageXOffset,y:Iu(e.y)?e.y:window.pageYOffset}}function Iu(e){return"number"==typeof e}var Pu=/^#\d/;function Ru(e,t){var n,a="object"==typeof e;if(a&&"string"==typeof e.selector){var i=Pu.test(e.selector)?document.getElementById(e.selector.slice(1)):document.querySelector(e.selector);if(i){var s=e.offset&&"object"==typeof e.offset?e.offset:{};t=function(e,t){var n=document.documentElement.getBoundingClientRect(),a=e.getBoundingClientRect();return{x:a.left-n.left-t.x,y:a.top-n.top-t.y}}(i,s={x:Iu((n=s).x)?n.x:0,y:Iu(n.y)?n.y:0})}else Cu(e)&&(t=xu(e))}else a&&Cu(e)&&(t=xu(e));t&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:t.x,top:t.y,behavior:e.behavior}):window.scrollTo(t.x,t.y))}var Su,Eu=du&&(-1===(Su=window.navigator.userAgent).indexOf("Android 2.")&&-1===Su.indexOf("Android 4.0")||-1===Su.indexOf("Mobile Safari")||-1!==Su.indexOf("Chrome")||-1!==Su.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState;function Ou(e,t){Au();var n=window.history;try{if(t){var a=vo({},n.state);a.key=vu(),n.replaceState(a,"",e)}else n.pushState({key:wu(Tu())},"",e)}catch(n){window.location[t?"replace":"assign"](e)}}function Uu(e){Ou(e,!0)}function Vu(e,t,n){var a=function(i){i>=e.length?n():e[i]?t(e[i],(function(){a(i+1)})):a(i+1)};a(0)}var Du={redirected:2,aborted:4,cancelled:8,duplicated:16};function Lu(e,t){return Bu(e,t,Du.cancelled,'Navigation cancelled from "'+e.fullPath+'" to "'+t.fullPath+'" with a new navigation.')}function Bu(e,t,n,a){var i=new Error(a);return i._isRouter=!0,i.from=e,i.to=t,i.type=n,i}var qu=["params","query","hash"];function Nu(e){return Object.prototype.toString.call(e).indexOf("Error")>-1}function Fu(e,t){return Nu(e)&&e._isRouter&&(null==t||e.type===t)}function zu(e,t){return Hu(e.map((function(e){return Object.keys(e.components).map((function(n){return t(e.components[n],e.instances[n],e,n)}))})))}function Hu(e){return Array.prototype.concat.apply([],e)}var $u="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function ju(e){var t=!1;return function(){for(var n=[],a=arguments.length;a--;)n[a]=arguments[a];if(!t)return t=!0,e.apply(this,n)}}var Wu=function(e,t){this.router=e,this.base=function(e){if(!e)if(du){var t=document.querySelector("base");e=(e=t&&t.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else e="/";return"/"!==e.charAt(0)&&(e="/"+e),e.replace(/\/$/,"")}(t),this.current=So,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Xu(e,t,n,a){var i=zu(e,(function(e,a,i,s){var r=function(e,t){return"function"!=typeof e&&(e=su.extend(e)),e.options[t]}(e,t);if(r)return Array.isArray(r)?r.map((function(e){return n(e,a,i,s)})):n(r,a,i,s)}));return Hu(a?i.reverse():i)}function Gu(e,t){if(t)return function(){return e.apply(t,arguments)}}Wu.prototype.listen=function(e){this.cb=e},Wu.prototype.onReady=function(e,t){this.ready?e():(this.readyCbs.push(e),t&&this.readyErrorCbs.push(t))},Wu.prototype.onError=function(e){this.errorCbs.push(e)},Wu.prototype.transitionTo=function(e,t,n){var a,i=this;try{a=this.router.match(e,this.current)}catch(e){throw this.errorCbs.forEach((function(t){t(e)})),e}var s=this.current;this.confirmTransition(a,(function(){i.updateRoute(a),t&&t(a),i.ensureURL(),i.router.afterHooks.forEach((function(e){e&&e(a,s)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(e){e(a)})))}),(function(e){n&&n(e),e&&!i.ready&&(Fu(e,Du.redirected)&&s===So||(i.ready=!0,i.readyErrorCbs.forEach((function(t){t(e)}))))}))},Wu.prototype.confirmTransition=function(e,t,n){var a=this,i=this.current;this.pending=e;var s,r,o=function(e){!Fu(e)&&Nu(e)&&(a.errorCbs.length?a.errorCbs.forEach((function(t){t(e)})):console.error(e)),n&&n(e)},u=e.matched.length-1,p=i.matched.length-1;if(Uo(e,i)&&u===p&&e.matched[u]===i.matched[p])return this.ensureURL(),e.hash&&Mu(this.router,i,e,!1),o(((r=Bu(s=i,e,Du.duplicated,'Avoided redundant navigation to current location: "'+s.fullPath+'".')).name="NavigationDuplicated",r));var d,y=function(e,t){var n,a=Math.max(e.length,t.length);for(n=0;n<a&&e[n]===t[n];n++);return{updated:t.slice(0,n),activated:t.slice(n),deactivated:e.slice(n)}}(this.current.matched,e.matched),l=y.updated,m=y.deactivated,c=y.activated,f=[].concat(function(e){return Xu(e,"beforeRouteLeave",Gu,!0)}(m),this.router.beforeHooks,function(e){return Xu(e,"beforeRouteUpdate",Gu)}(l),c.map((function(e){return e.beforeEnter})),(d=c,function(e,t,n){var a=!1,i=0,s=null;zu(d,(function(e,t,r,o){if("function"==typeof e&&void 0===e.cid){a=!0,i++;var u,p=ju((function(t){var a;((a=t).__esModule||$u&&"Module"===a[Symbol.toStringTag])&&(t=t.default),e.resolved="function"==typeof t?t:su.extend(t),r.components[o]=t,--i<=0&&n()})),d=ju((function(e){var t="Failed to resolve async component "+o+": "+e;s||(s=Nu(e)?e:new Error(t),n(s))}));try{u=e(p,d)}catch(e){d(e)}if(u)if("function"==typeof u.then)u.then(p,d);else{var y=u.component;y&&"function"==typeof y.then&&y.then(p,d)}}})),a||n()})),h=function(t,n){if(a.pending!==e)return o(Lu(i,e));try{t(e,i,(function(t){!1===t?(a.ensureURL(!0),o(function(e,t){return Bu(e,t,Du.aborted,'Navigation aborted from "'+e.fullPath+'" to "'+t.fullPath+'" via a navigation guard.')}(i,e))):Nu(t)?(a.ensureURL(!0),o(t)):"string"==typeof t||"object"==typeof t&&("string"==typeof t.path||"string"==typeof t.name)?(o(function(e,t){return Bu(e,t,Du.redirected,'Redirected when going from "'+e.fullPath+'" to "'+function(e){if("string"==typeof e)return e;if("path"in e)return e.path;var t={};return qu.forEach((function(n){n in e&&(t[n]=e[n])})),JSON.stringify(t,null,2)}(t)+'" via a navigation guard.')}(i,e)),"object"==typeof t&&t.replace?a.replace(t):a.push(t)):n(t)}))}catch(e){o(e)}};Vu(f,h,(function(){var n=function(e){return Xu(e,"beforeRouteEnter",(function(e,t,n,a){return function(e,t,n){return function(a,i,s){return e(a,i,(function(e){"function"==typeof e&&(t.enteredCbs[n]||(t.enteredCbs[n]=[]),t.enteredCbs[n].push(e)),s(e)}))}}(e,n,a)}))}(c);Vu(n.concat(a.router.resolveHooks),h,(function(){if(a.pending!==e)return o(Lu(i,e));a.pending=null,t(e),a.router.app&&a.router.app.$nextTick((function(){Do(e)}))}))}))},Wu.prototype.updateRoute=function(e){this.current=e,this.cb&&this.cb(e)},Wu.prototype.setupListeners=function(){},Wu.prototype.teardown=function(){this.listeners.forEach((function(e){e()})),this.listeners=[],this.current=So,this.pending=null};var Qu=function(e){function t(t,n){e.call(this,t,n),this._startLocation=Yu(this.base)}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router,n=t.options.scrollBehavior,a=Eu&&n;a&&this.listeners.push(ku());var i=function(){var n=e.current,i=Yu(e.base);e.current===So&&i===e._startLocation||e.transitionTo(i,(function(e){a&&Mu(t,e,n,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},t.prototype.go=function(e){window.history.go(e)},t.prototype.push=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){Ou(No(a.base+e.fullPath)),Mu(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){Uu(No(a.base+e.fullPath)),Mu(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.ensureURL=function(e){if(Yu(this.base)!==this.current.fullPath){var t=No(this.base+this.current.fullPath);e?Ou(t):Uu(t)}},t.prototype.getCurrentLocation=function(){return Yu(this.base)},t}(Wu);function Yu(e){var t=window.location.pathname,n=t.toLowerCase(),a=e.toLowerCase();return!e||n!==a&&0!==n.indexOf(No(a+"/"))||(t=t.slice(e.length)),(t||"/")+window.location.search+window.location.hash}var Ju=function(e){function t(t,n,a){e.call(this,t,n),a&&function(e){var t=Yu(e);if(!/^\/#/.test(t))return window.location.replace(No(e+"/#"+t)),!0}(this.base)||Ku()}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router.options.scrollBehavior,n=Eu&&t;n&&this.listeners.push(ku());var a=function(){var t=e.current;Ku()&&e.transitionTo(Zu(),(function(a){n&&Mu(e.router,a,t,!0),Eu||np(a.fullPath)}))},i=Eu?"popstate":"hashchange";window.addEventListener(i,a),this.listeners.push((function(){window.removeEventListener(i,a)}))}},t.prototype.push=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){tp(e.fullPath),Mu(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){np(e.fullPath),Mu(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.go=function(e){window.history.go(e)},t.prototype.ensureURL=function(e){var t=this.current.fullPath;Zu()!==t&&(e?tp(t):np(t))},t.prototype.getCurrentLocation=function(){return Zu()},t}(Wu);function Ku(){var e=Zu();return"/"===e.charAt(0)||(np("/"+e),!1)}function Zu(){var e=window.location.href,t=e.indexOf("#");return t<0?"":e=e.slice(t+1)}function ep(e){var t=window.location.href,n=t.indexOf("#");return(n>=0?t.slice(0,n):t)+"#"+e}function tp(e){Eu?Ou(ep(e)):window.location.hash=e}function np(e){Eu?Uu(ep(e)):window.location.replace(ep(e))}var ap=function(e){function t(t,n){e.call(this,t,n),this.stack=[],this.index=-1}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.push=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index+1).concat(e),a.index++,t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index).concat(e),t&&t(e)}),n)},t.prototype.go=function(e){var t=this,n=this.index+e;if(!(n<0||n>=this.stack.length)){var a=this.stack[n];this.confirmTransition(a,(function(){var e=t.current;t.index=n,t.updateRoute(a),t.router.afterHooks.forEach((function(t){t&&t(a,e)}))}),(function(e){Fu(e,Du.duplicated)&&(t.index=n)}))}},t.prototype.getCurrentLocation=function(){var e=this.stack[this.stack.length-1];return e?e.fullPath:"/"},t.prototype.ensureURL=function(){},t}(Wu),ip=function(e){void 0===e&&(e={}),this.app=null,this.apps=[],this.options=e,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=cu(e.routes||[],this);var t=e.mode||"hash";switch(this.fallback="history"===t&&!Eu&&!1!==e.fallback,this.fallback&&(t="hash"),du||(t="abstract"),this.mode=t,t){case"history":this.history=new Qu(this,e.base);break;case"hash":this.history=new Ju(this,e.base,this.fallback);break;case"abstract":this.history=new ap(this,e.base)}},sp={currentRoute:{configurable:!0}};function rp(e,t){return e.push(t),function(){var n=e.indexOf(t);n>-1&&e.splice(n,1)}}ip.prototype.match=function(e,t,n){return this.matcher.match(e,t,n)},sp.currentRoute.get=function(){return this.history&&this.history.current},ip.prototype.init=function(e){var t=this;if(this.apps.push(e),e.$once("hook:destroyed",(function(){var n=t.apps.indexOf(e);n>-1&&t.apps.splice(n,1),t.app===e&&(t.app=t.apps[0]||null),t.app||t.history.teardown()})),!this.app){this.app=e;var n=this.history;if(n instanceof Qu||n instanceof Ju){var a=function(e){n.setupListeners(),function(e){var a=n.current,i=t.options.scrollBehavior;Eu&&i&&"fullPath"in e&&Mu(t,e,a,!1)}(e)};n.transitionTo(n.getCurrentLocation(),a,a)}n.listen((function(e){t.apps.forEach((function(t){t._route=e}))}))}},ip.prototype.beforeEach=function(e){return rp(this.beforeHooks,e)},ip.prototype.beforeResolve=function(e){return rp(this.resolveHooks,e)},ip.prototype.afterEach=function(e){return rp(this.afterHooks,e)},ip.prototype.onReady=function(e,t){this.history.onReady(e,t)},ip.prototype.onError=function(e){this.history.onError(e)},ip.prototype.push=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.push(e,t,n)}));this.history.push(e,t,n)},ip.prototype.replace=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.replace(e,t,n)}));this.history.replace(e,t,n)},ip.prototype.go=function(e){this.history.go(e)},ip.prototype.back=function(){this.go(-1)},ip.prototype.forward=function(){this.go(1)},ip.prototype.getMatchedComponents=function(e){var t=e?e.matched?e:this.resolve(e).route:this.currentRoute;return t?[].concat.apply([],t.matched.map((function(e){return Object.keys(e.components).map((function(t){return e.components[t]}))}))):[]},ip.prototype.resolve=function(e,t,n){var a=iu(e,t=t||this.history.current,n,this),i=this.match(a,t),s=i.redirectedFrom||i.fullPath,r=function(e,t,n){var a="hash"===n?"#"+t:t;return e?No(e+"/"+a):a}(this.history.base,s,this.mode);return{location:a,route:i,href:r,normalizedTo:a,resolved:i}},ip.prototype.getRoutes=function(){return this.matcher.getRoutes()},ip.prototype.addRoute=function(e,t){this.matcher.addRoute(e,t),this.history.current!==So&&this.history.transitionTo(this.history.getCurrentLocation())},ip.prototype.addRoutes=function(e){this.matcher.addRoutes(e),this.history.current!==So&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(ip.prototype,sp),ip.install=function e(t){if(!e.installed||su!==t){e.installed=!0,su=t;var n=function(e){return void 0!==e},a=function(e,t){var a=e.$options._parentVnode;n(a)&&n(a=a.data)&&n(a=a.registerRouteInstance)&&a(e,t)};t.mixin({beforeCreate:function(){n(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),t.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(t.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(t.prototype,"$route",{get:function(){return this._routerRoot._route}}),t.component("RouterView",Lo),t.component("RouterLink",ou);var i=t.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},ip.version="3.5.3",ip.isNavigationFailure=Fu,ip.NavigationFailureType=Du,ip.START_LOCATION=So,du&&window.Vue&&window.Vue.use(ip);const op=ip;var up=function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"min-h-screen bg-gray-100 px-4 pt-6"},[t("router-view")],1)};function pp(e,t,n,a,i,s,r,o){var u,p="function"==typeof e?e.options:e;if(t&&(p.render=t,p.staticRenderFns=n,p._compiled=!0),a&&(p.functional=!0),s&&(p._scopeId="data-v-"+s),r?(u=function(e){(e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),i&&i.call(this,e),e&&e._registeredComponents&&e._registeredComponents.add(r)},p._ssrRegister=u):i&&(u=o?function(){i.call(this,(p.functional?this.parent:this).$root.$options.shadowRoot)}:i),u)if(p.functional){p._injectStyles=u;var d=p.render;p.render=function(e,t){return u.call(t),d(e,t)}}else{var y=p.beforeCreate;p.beforeCreate=y?[].concat(y,u):[u]}return{exports:e,options:p}}up._withStripped=!0,n(387);var dp=pp({},up,[],!1,null,null,null);dp.options.__file="node_modules/hardhat-docgen/src/App.vue";const yp=dp.exports;var lp=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto"},[n("HeaderBar"),e._v(" "),n("div",{staticClass:"pb-32"},[n("div",{staticClass:"space-y-4"},[n("span",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.source)+"\n      ")]),e._v(" "),n("h1",{staticClass:"text-xl"},[e._v("\n        "+e._s(e.json.name)+"\n      ")]),e._v(" "),n("h2",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.title)+"\n      ")]),e._v(" "),n("h2",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.author)+"\n      ")]),e._v(" "),n("p",[e._v(e._s(e.json.notice))]),e._v(" "),n("p",[e._v(e._s(e.json.details))])]),e._v(" "),n("div",{staticClass:"mt-8"},[e.json.hasOwnProperty("constructor")?n("Member",{attrs:{json:e.json.constructor}}):e._e()],1),e._v(" "),n("div",{staticClass:"mt-8"},[e.json.receive?n("Member",{attrs:{json:e.json.receive}}):e._e()],1),e._v(" "),n("div",{staticClass:"mt-8"},[e.json.fallback?n("Member",{attrs:{json:e.json.fallback}}):e._e()],1),e._v(" "),e.json.events?n("MemberSet",{attrs:{title:"Events",json:e.json.events}}):e._e(),e._v(" "),e.json.stateVariables?n("MemberSet",{attrs:{title:"State Variables",json:e.json.stateVariables}}):e._e(),e._v(" "),e.json.methods?n("MemberSet",{attrs:{title:"Methods",json:e.json.methods}}):e._e()],1),e._v(" "),n("FooterBar")],1)};lp._withStripped=!0;var mp=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"bg-gray-100 fixed bottom-0 right-0 w-full border-t border-dashed border-gray-300"},[n("div",{staticClass:"w-full text-center py-2 md:max-w-screen-sm lg:max-w-screen-md mx-auto"},[n("button",{staticClass:"py-1 px-2 text-gray-500",on:{click:function(t){return e.openLink(e.repository)}}},[e._v("\n      built with "+e._s(e.name)+"\n    ")])])])};mp._withStripped=!0;const cp=JSON.parse('{"u2":"hardhat-docgen","cj":"https://github.com/ItsNickBarry/hardhat-docgen"}');var fp=pp({data:function(){return{repository:cp.cj,name:cp.u2}},methods:{openLink(e){window.open(e,"_blank")}}},mp,[],!1,null,null,null);fp.options.__file="node_modules/hardhat-docgen/src/components/FooterBar.vue";const hp=fp.exports;var Tp=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"w-full border-b border-dashed py-2 border-gray-300"},[n("router-link",{staticClass:"py-2 text-gray-500",attrs:{to:"/"}},[e._v("\n    <- Go back\n  ")])],1)};Tp._withStripped=!0;var bp=pp({},Tp,[],!1,null,null,null);bp.options.__file="node_modules/hardhat-docgen/src/components/HeaderBar.vue";const vp=bp.exports;var wp=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"border-2 border-gray-400 border-dashed w-full p-2"},[n("h3",{staticClass:"text-lg pb-2 mb-2 border-b-2 border-gray-400 border-dashed"},[e._v("\n    "+e._s(e.name)+" "+e._s(e.keywords)+" "+e._s(e.inputSignature)+"\n  ")]),e._v(" "),n("div",{staticClass:"space-y-3"},[n("p",[e._v(e._s(e.json.notice))]),e._v(" "),n("p",[e._v(e._s(e.json.details))]),e._v(" "),n("MemberSection",{attrs:{name:"Parameters",items:e.inputs}}),e._v(" "),n("MemberSection",{attrs:{name:"Return Values",items:e.outputs}})],1)])};wp._withStripped=!0;var gp=function(){var e=this,t=e.$createElement,n=e._self._c||t;return e.items.length>0?n("ul",[n("h4",{staticClass:"text-lg"},[e._v("\n    "+e._s(e.name)+"\n  ")]),e._v(" "),e._l(e.items,(function(t,a){return n("li",{key:a},[n("span",{staticClass:"bg-gray-300"},[e._v(e._s(t.type))]),e._v(" "),n("b",[e._v(e._s(t.name||"_"+a))]),t.desc?n("span",[e._v(": "),n("i",[e._v(e._s(t.desc))])]):e._e()])}))],2):e._e()};gp._withStripped=!0;var kp=pp({props:{name:{type:String,default:""},items:{type:Array,default:()=>new Array}}},gp,[],!1,null,null,null);kp.options.__file="node_modules/hardhat-docgen/src/components/MemberSection.vue";const Mp={components:{MemberSection:kp.exports},props:{json:{type:Object,default:()=>new Object}},computed:{name:function(){return this.json.name||this.json.type},keywords:function(){let e=[];return this.json.stateMutability&&e.push(this.json.stateMutability),"true"===this.json.anonymous&&e.push("anonymous"),e.join(" ")},params:function(){return this.json.params||{}},returns:function(){return this.json.returns||{}},inputs:function(){return(this.json.inputs||[]).map((e=>({...e,desc:this.params[e.name]})))},inputSignature:function(){return`(${this.inputs.map((e=>e.type)).join(",")})`},outputs:function(){return(this.json.outputs||[]).map(((e,t)=>({...e,desc:this.returns[e.name||`_${t}`]})))},outputSignature:function(){return`(${this.outputs.map((e=>e.type)).join(",")})`}}};var Ap=pp(Mp,wp,[],!1,null,null,null);Ap.options.__file="node_modules/hardhat-docgen/src/components/Member.vue";const _p=Ap.exports;var Cp=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"w-full mt-8"},[n("h2",{staticClass:"text-lg"},[e._v(e._s(e.title))]),e._v(" "),e._l(Object.keys(e.json),(function(t){return n("Member",{key:t,staticClass:"mt-3",attrs:{json:e.json[t]}})}))],2)};Cp._withStripped=!0;var xp=pp({components:{Member:_p},props:{title:{type:String,default:""},json:{type:Object,default:()=>new Object}}},Cp,[],!1,null,null,null);xp.options.__file="node_modules/hardhat-docgen/src/components/MemberSet.vue";var Ip=pp({components:{Member:_p,MemberSet:xp.exports,HeaderBar:vp,FooterBar:hp},props:{json:{type:Object,default:()=>new Object}}},lp,[],!1,null,null,null);Ip.options.__file="node_modules/hardhat-docgen/src/components/Contract.vue";const Pp=Ip.exports;var Rp=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto pb-32"},[n("Branch",{attrs:{json:e.trees,name:"Sources:"}}),e._v(" "),n("FooterBar",{staticClass:"mt-20"})],1)};Rp._withStripped=!0;var Sp=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",[e._v("\n  "+e._s(e.name)+"\n  "),Array.isArray(e.json)?n("div",{staticClass:"pl-5"},e._l(e.json,(function(t,a){return n("div",{key:a},[n("router-link",{attrs:{to:t.source+":"+t.name}},[e._v("\n        "+e._s(t.name)+"\n      ")])],1)})),0):n("div",{staticClass:"pl-5"},e._l(Object.keys(e.json),(function(t){return n("div",{key:t},[n("Branch",{attrs:{json:e.json[t],name:t}})],1)})),0)])};Sp._withStripped=!0;var Ep=pp({name:"Branch",props:{name:{type:String,default:null},json:{type:[Object,Array],default:()=>new Object}}},Sp,[],!1,null,null,null);Ep.options.__file="node_modules/hardhat-docgen/src/components/Branch.vue";var Op=pp({components:{Branch:Ep.exports,FooterBar:hp},props:{json:{type:Object,default:()=>new Object}},computed:{trees:function(){let e={};for(let t in this.json)t.replace("/","//").split(/\/(?=[^\/])/).reduce(function(e,n){if(!n.includes(":"))return e[n]=e[n]||{},e[n];{let[a]=n.split(":");e[a]=e[a]||[],e[a].push(this.json[t])}}.bind(this),e);return e}}},Rp,[],!1,null,null,null);Op.options.__file="node_modules/hardhat-docgen/src/components/Index.vue";const Up=Op.exports;bo.use(op);const Vp={"contracts/airdrop/MerkleDistributor.sol:MerkleDistributor":{source:"contracts/airdrop/MerkleDistributor.sol",name:"MerkleDistributor",constructor:{inputs:[{internalType:"address",name:"_token",type:"address"},{internalType:"bytes32",name:"_merkleRoot",type:"bytes32"}],stateMutability:"nonpayable",type:"constructor"},events:{"Claimed(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"_index",type:"uint256"},{indexed:!1,internalType:"address",name:"_account",type:"address"},{indexed:!1,internalType:"uint256",name:"_amount",type:"uint256"}],name:"Claimed",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"Withdrawn(address,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"_treasury",type:"address"},{indexed:!1,internalType:"uint256",name:"_amount",type:"uint256"}],name:"Withdrawn",type:"event"}},methods:{"claim(uint256,address,uint256,bytes32[])":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"},{internalType:"address",name:"_account",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"},{internalType:"bytes32[]",name:"_merkleProof",type:"bytes32[]"}],name:"claim",outputs:[],stateMutability:"nonpayable",type:"function"},"claimPeriodEndBlock()":{inputs:[],name:"claimPeriodEndBlock",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"isClaimed(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"isClaimed",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"merkleRoot()":{inputs:[],name:"merkleRoot",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"token()":{inputs:[],name:"token",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"amount of the transaction",_to:"address of the receiver",_token:"address of the ERC20 token"},notice:"Transfers an amount of an ERC20 from this contract to an address"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"withdrawUnclaimed()":{inputs:[],name:"withdrawUnclaimed",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/airdrop/interfaces/IMerkleDistributor.sol:IMerkleDistributor":{source:"contracts/airdrop/interfaces/IMerkleDistributor.sol",name:"IMerkleDistributor",events:{"Claimed(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"_index",type:"uint256"},{indexed:!1,internalType:"address",name:"_account",type:"address"},{indexed:!1,internalType:"uint256",name:"_amount",type:"uint256"}],name:"Claimed",type:"event"},"Withdrawn(address,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"_treasury",type:"address"},{indexed:!1,internalType:"uint256",name:"_amount",type:"uint256"}],name:"Withdrawn",type:"event"}},methods:{"claim(uint256,address,uint256,bytes32[])":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"},{internalType:"address",name:"_account",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"},{internalType:"bytes32[]",name:"_merkleProof",type:"bytes32[]"}],name:"claim",outputs:[],stateMutability:"nonpayable",type:"function"},"isClaimed(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"isClaimed",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"merkleRoot()":{inputs:[],name:"merkleRoot",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"token()":{inputs:[],name:"token",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"withdrawUnclaimed()":{inputs:[],name:"withdrawUnclaimed",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/airdropV2/AirdropV2Implementation.sol:AirdropV2Implementation":{source:"contracts/airdropV2/AirdropV2Implementation.sol",name:"AirdropV2Implementation",events:{"Claimed(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beneficiary",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Claimed",type:"event",params:{amount:"The amount of the claim",beneficiary:"The address of the beneficiary that has claimed"},notice:"Triggered after a claim"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"}},methods:{"PACT()":{inputs:[],name:"PACT",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"beneficiaries(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"beneficiaries",outputs:[{internalType:"uint256",name:"claimedAmount",type:"uint256"},{internalType:"uint256",name:"lastClaimTime",type:"uint256"}],stateMutability:"view",type:"function"},"claim(address,bytes32[])":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"},{internalType:"bytes32[]",name:"_merkleProof",type:"bytes32[]"}],name:"claim",outputs:[],stateMutability:"nonpayable",type:"function",params:{_beneficiaryAddress:"the address of the beneficiary",_merkleProof:"the proof vor validating the beneficiary"},notice:"Transfers PACTs to a beneficiary"},"cooldown()":{inputs:[],name:"cooldown",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function",notice:"Returns the current implementation version"},"initialize(address,uint256,uint256,uint256,uint256,bytes32)":{inputs:[{internalType:"address",name:"_PACTAddress",type:"address"},{internalType:"uint256",name:"_startTime",type:"uint256"},{internalType:"uint256",name:"_trancheAmount",type:"uint256"},{internalType:"uint256",name:"_totalAmount",type:"uint256"},{internalType:"uint256",name:"_cooldown",type:"uint256"},{internalType:"bytes32",name:"_merkleRoot",type:"bytes32"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_PACTAddress:"The address of the PACT token",_cooldown:"The minimum number of seconds between two claims",_merkleRoot:"The root of the merkle tree",_startTime:"The timestamp when the airdrop will be available",_totalAmount:"The total number of PACTs to be claimed by a beneficiary",_trancheAmount:"The number of PACTs to be claimed in one transaction"},notice:"Used to initialize a new Airdrop contract"},"merkleRoot()":{inputs:[],name:"merkleRoot",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if the contract is paused, and false otherwise."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"startTime()":{inputs:[],name:"startTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalAmount()":{inputs:[],name:"totalAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"trancheAmount()":{inputs:[],name:"trancheAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"updateCooldown(uint256)":{inputs:[{internalType:"uint256",name:"_newCooldown",type:"uint256"}],name:"updateCooldown",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newCooldown:"the new cooldown timestamp"},notice:"Updates the cooldown value"},"updateMerkleRoot(bytes32)":{inputs:[{internalType:"bytes32",name:"_newMerkleRoot",type:"bytes32"}],name:"updateMerkleRoot",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newMerkleRoot:"the new merkleRoot"},notice:"Updates the merkleRoot"},"updateStartTime(uint256)":{inputs:[{internalType:"uint256",name:"_newStartTime",type:"uint256"}],name:"updateStartTime",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newStartTime:"the new start timestamp"},notice:"Updates the startTime value"},"updateTotalAmount(uint256)":{inputs:[{internalType:"uint256",name:"_newTotalAmount",type:"uint256"}],name:"updateTotalAmount",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newTotalAmount:"the new totalAmount"},notice:"Updates the totalAmount value"},"updateTrancheAmount(uint256)":{inputs:[{internalType:"uint256",name:"_newTrancheAmount",type:"uint256"}],name:"updateTrancheAmount",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newTrancheAmount:"the new trancheAmount"},notice:"Updates the trancheAmount value"}}},"contracts/airdropV2/AirdropV2Proxy.sol:AirdropV2Proxy":{source:"contracts/airdropV2/AirdropV2Proxy.sol",name:"AirdropV2Proxy",constructor:{inputs:[{internalType:"address",name:"_logic",type:"address"},{internalType:"address",name:"_proxyAdmin",type:"address"}],stateMutability:"nonpayable",type:"constructor"},fallback:{stateMutability:"payable",type:"fallback"},receive:{stateMutability:"payable",type:"receive"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"admin()":{inputs:[],name:"admin",outputs:[{internalType:"address",name:"admin_",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Returns the current admin. NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}. TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`"},"changeAdmin(address)":{inputs:[{internalType:"address",name:"newAdmin",type:"address"}],name:"changeAdmin",outputs:[],stateMutability:"nonpayable",type:"function",details:"Changes the admin of the proxy. Emits an {AdminChanged} event. NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}."},"implementation()":{inputs:[],name:"implementation",outputs:[{internalType:"address",name:"implementation_",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Returns the current implementation. NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}. TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy. NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy, and then call a function from the new implementation as specified by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the proxied contract. NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}."}}},"contracts/airdropV2/interfaces/AirdropV2StorageV1.sol:AirdropV2StorageV1":{source:"contracts/airdropV2/interfaces/AirdropV2StorageV1.sol",name:"AirdropV2StorageV1",title:"Storage for Deposit",notice:"For future upgrades, do not change DepositStorageV1. Create a new contract which implements DepositStorageV1 and following the naming convention DepositStorageVx.",methods:{"PACT()":{inputs:[],name:"PACT",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"beneficiaries(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"beneficiaries",outputs:[{internalType:"uint256",name:"claimedAmount",type:"uint256"},{internalType:"uint256",name:"lastClaimTime",type:"uint256"}],stateMutability:"view",type:"function"},"claim(address,bytes32[])":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"},{internalType:"bytes32[]",name:"_merkleProof",type:"bytes32[]"}],name:"claim",outputs:[],stateMutability:"nonpayable",type:"function"},"cooldown()":{inputs:[],name:"cooldown",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"merkleRoot()":{inputs:[],name:"merkleRoot",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"startTime()":{inputs:[],name:"startTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalAmount()":{inputs:[],name:"totalAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"trancheAmount()":{inputs:[],name:"trancheAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"updateCooldown(uint256)":{inputs:[{internalType:"uint256",name:"_newCooldown",type:"uint256"}],name:"updateCooldown",outputs:[],stateMutability:"nonpayable",type:"function"},"updateMerkleRoot(bytes32)":{inputs:[{internalType:"bytes32",name:"_newMerkleRoot",type:"bytes32"}],name:"updateMerkleRoot",outputs:[],stateMutability:"nonpayable",type:"function"},"updateStartTime(uint256)":{inputs:[{internalType:"uint256",name:"_newStartTime",type:"uint256"}],name:"updateStartTime",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTotalAmount(uint256)":{inputs:[{internalType:"uint256",name:"_newTotalAmount",type:"uint256"}],name:"updateTotalAmount",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTrancheAmount(uint256)":{inputs:[{internalType:"uint256",name:"_newTrancheAmount",type:"uint256"}],name:"updateTrancheAmount",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/airdropV2/interfaces/IAirdropV2.sol:IAirdropV2":{source:"contracts/airdropV2/interfaces/IAirdropV2.sol",name:"IAirdropV2",methods:{"PACT()":{inputs:[],name:"PACT",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"claim(address,bytes32[])":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"},{internalType:"bytes32[]",name:"_merkleProof",type:"bytes32[]"}],name:"claim",outputs:[],stateMutability:"nonpayable",type:"function"},"cooldown()":{inputs:[],name:"cooldown",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"merkleRoot()":{inputs:[],name:"merkleRoot",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"startTime()":{inputs:[],name:"startTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalAmount()":{inputs:[],name:"totalAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"trancheAmount()":{inputs:[],name:"trancheAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"updateCooldown(uint256)":{inputs:[{internalType:"uint256",name:"_newCooldown",type:"uint256"}],name:"updateCooldown",outputs:[],stateMutability:"nonpayable",type:"function"},"updateMerkleRoot(bytes32)":{inputs:[{internalType:"bytes32",name:"_newMerkleRoot",type:"bytes32"}],name:"updateMerkleRoot",outputs:[],stateMutability:"nonpayable",type:"function"},"updateStartTime(uint256)":{inputs:[{internalType:"uint256",name:"_newStartTime",type:"uint256"}],name:"updateStartTime",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTotalAmount(uint256)":{inputs:[{internalType:"uint256",name:"_newTotalAmount",type:"uint256"}],name:"updateTotalAmount",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTrancheAmount(uint256)":{inputs:[{internalType:"uint256",name:"_newTrancheAmount",type:"uint256"}],name:"updateTrancheAmount",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/ambassadors/AmbassadorsImplementation.sol:AmbassadorsImplementation":{source:"contracts/ambassadors/AmbassadorsImplementation.sol",name:"AmbassadorsImplementation",notice:"Welcome to Ambassadors contract.",events:{"AmbassadorAccountReplaced(uint256,address,address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"ambassadorIndex",type:"uint256"},{indexed:!0,internalType:"address",name:"entityAccount",type:"address"},{indexed:!0,internalType:"address",name:"oldAccount",type:"address"},{indexed:!0,internalType:"address",name:"newAccount",type:"address"}],name:"AmbassadorAccountReplaced",type:"event",params:{ambassadorIndex:"Index of the ambassador being replaced",entityAccount:"Address of the entity where ambassador is being replaced",newAccount:"Ambassador's new account address",oldAccount:"Ambassador's old account address"},notice:"Triggered when an ambassador replaces it's own account."},"AmbassadorAdded(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"ambassador",type:"address"},{indexed:!0,internalType:"address",name:"entity",type:"address"}],name:"AmbassadorAdded",type:"event",params:{ambassador:"Address of the ambassador added",entity:"Address of the entity where the ambassador is added"},notice:"Triggered when an ambassador is added to an entity."},"AmbassadorRemoved(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"ambassador",type:"address"},{indexed:!0,internalType:"address",name:"entity",type:"address"}],name:"AmbassadorRemoved",type:"event",params:{ambassador:"Address of the ambassador removed",entity:"Address of the entity where the ambassador is removed"},notice:"Triggered when an ambassador is removed."},"AmbassadorReplaced(uint256,address,address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"ambassadorIndex",type:"uint256"},{indexed:!0,internalType:"address",name:"entityAccount",type:"address"},{indexed:!0,internalType:"address",name:"oldAmbassador",type:"address"},{indexed:!0,internalType:"address",name:"newAmbassador",type:"address"}],name:"AmbassadorReplaced",type:"event",params:{ambassadorIndex:"Index of the ambassador being replaced",entityAccount:"Address of the entity where ambassador is being replaced",newAmbassador:"Ambassador's new account address",oldAmbassador:"Ambassador's old account address"},notice:"Triggered when an ambassador is replaced by the entity."},"AmbassadorToCommunityUpdated(address,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"fromAmbassador",type:"address"},{indexed:!0,internalType:"address",name:"toAmbassador",type:"address"},{indexed:!0,internalType:"address",name:"community",type:"address"}],name:"AmbassadorToCommunityUpdated",type:"event",params:{community:"Community address being transfered",fromAmbassador:"Ambassador address from which the community is being transfered from",toAmbassador:"Ambassador address to which the community is being transfered to"},notice:"Triggered when a community is transfered from one ambassador to another."},"AmbassadorTransfered(address,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"ambassador",type:"address"},{indexed:!0,internalType:"address",name:"oldEntity",type:"address"},{indexed:!0,internalType:"address",name:"newEntity",type:"address"}],name:"AmbassadorTransfered",type:"event",params:{ambassador:"Ambassador address being replaced",newEntity:"Entity's new account address",oldEntity:"Entity's old account address"},notice:"Triggered when an ambassador is transfered to a new entity."},"CommunityRemoved(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"ambassador",type:"address"},{indexed:!0,internalType:"address",name:"community",type:"address"}],name:"CommunityRemoved",type:"event",params:{ambassador:"Ambassador of the community being removed",community:"Community address being removed"},notice:"Triggered when a community is removed."},"EntityAccountReplaced(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"entityIndex",type:"uint256"},{indexed:!0,internalType:"address",name:"oldAccount",type:"address"},{indexed:!0,internalType:"address",name:"newAccount",type:"address"}],name:"EntityAccountReplaced",type:"event",params:{entityIndex:"Entity index replacing account address",newAccount:"New account address",oldAccount:"Old account address"},notice:"Triggered when an entity replaced account address."},"EntityAdded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"entity",type:"address"}],name:"EntityAdded",type:"event",params:{entity:"Address of the entity added"},notice:"Triggered when an entity is added."},"EntityRemoved(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"entity",type:"address"}],name:"EntityRemoved",type:"event",params:{entity:"Address of the entity removed"},notice:"Triggered when an entity is removed."},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"}},methods:{"addAmbassador(address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"}],name:"addAmbassador",outputs:[],stateMutability:"nonpayable",type:"function",params:{_ambassador:"Address of the ambassador"},notice:"Registers an ambassador."},"addEntity(address)":{inputs:[{internalType:"address",name:"_entity",type:"address"}],name:"addEntity",outputs:[],stateMutability:"nonpayable",type:"function",params:{_entity:"Address of the entity"},notice:"Registers an entity."},"ambassadorByAddress(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"ambassadorByAddress",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"ambassadorByIndex(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"ambassadorByIndex",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"ambassadorIndex()":{inputs:[],name:"ambassadorIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"ambassadorToEntity(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"ambassadorToEntity",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"communityAdmin()":{inputs:[],name:"communityAdmin",outputs:[{internalType:"contract ICommunityAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"communityToAmbassador(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"communityToAmbassador",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"entityAmbassadors(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"entityAmbassadors",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"entityByAddress(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"entityByAddress",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"entityByIndex(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"entityByIndex",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"entityIndex()":{inputs:[],name:"entityIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function",notice:"Returns the current implementation version"},"initialize(address)":{inputs:[{internalType:"contract ICommunityAdmin",name:"_communityAdmin",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_communityAdmin:"Address of the community admin contract"},notice:"Used to initialize a new Ambassadors contract"},"isAmbassador(address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"}],name:"isAmbassador",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_ambassador:"Address of the ambassador"},returns:{_0:"Boolean whether an address is ambassador or not"},notice:"Returns boolean whether an address is ambassador or not."},"isAmbassadorAt(address,address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"},{internalType:"address",name:"_entityAddress",type:"address"}],name:"isAmbassadorAt",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_ambassador:"Address of the ambassador",_entityAddress:"Address of the entity"},returns:{_0:"Boolean whether an address is ambassador at a given entity or not"},notice:"Returns boolean whether an address is ambassador at a given entity."},"isAmbassadorOf(address,address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"},{internalType:"address",name:"_community",type:"address"}],name:"isAmbassadorOf",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_ambassador:"Address of the ambassador",_community:"Address of the community"},returns:{_0:"Boolean whether an address is ambassador of a given community or not"},notice:"Returns boolean whether an address is ambassador of a given community."},"isEntityOf(address,address)":{inputs:[{internalType:"address",name:"_entity",type:"address"},{internalType:"address",name:"_community",type:"address"}],name:"isEntityOf",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_community:"Address of the community",_entity:"Address of the entity"},returns:{_0:"Boolean whether an address is entity responsible for ambassador of a given community or not"},notice:"Returns boolean whether an address is entity responsible for ambassador of a given community."},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"removeAmbassador(address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"}],name:"removeAmbassador",outputs:[],stateMutability:"nonpayable",type:"function",params:{_ambassador:"Address of the ambassador"},notice:"Removes an ambassador."},"removeCommunity(address)":{inputs:[{internalType:"address",name:"_community",type:"address"}],name:"removeCommunity",outputs:[],stateMutability:"nonpayable",type:"function",params:{_community:"Community address"},notice:"Removes community."},"removeEntity(address)":{inputs:[{internalType:"address",name:"_entity",type:"address"}],name:"removeEntity",outputs:[],stateMutability:"nonpayable",type:"function",params:{_entity:"Address of the entity"},notice:"Removes an entity."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"replaceAmbassador(address,address)":{inputs:[{internalType:"address",name:"_oldAmbassador",type:"address"},{internalType:"address",name:"_newAmbassador",type:"address"}],name:"replaceAmbassador",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newAmbassador:"New ambassador address",_oldAmbassador:"Address of the ambassador"},notice:"Replaces an ambassador. Called by entity."},"replaceAmbassadorAccount(address,address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"},{internalType:"address",name:"_newAmbassador",type:"address"}],name:"replaceAmbassadorAccount",outputs:[],stateMutability:"nonpayable",type:"function",params:{_ambassador:"Address of the ambassador",_newAmbassador:"New ambassador address"},notice:"Replace ambassador account. Called by ambassador."},"replaceEntityAccount(address,address)":{inputs:[{internalType:"address",name:"_entity",type:"address"},{internalType:"address",name:"_newEntity",type:"address"}],name:"replaceEntityAccount",outputs:[],stateMutability:"nonpayable",type:"function",params:{_entity:"Address of the entity",_newEntity:"New entity address"},notice:"Replace entity account."},"setCommunityToAmbassador(address,address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"},{internalType:"address",name:"_community",type:"address"}],name:"setCommunityToAmbassador",outputs:[],stateMutability:"nonpayable",type:"function",params:{_ambassador:"Address of the ambassador",_community:"Community address"},notice:"Sets community to ambassador."},"transferAmbassador(address,address,bool)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"},{internalType:"address",name:"_toEntity",type:"address"},{internalType:"bool",name:"_keepCommunities",type:"bool"}],name:"transferAmbassador",outputs:[],stateMutability:"nonpayable",type:"function",params:{_ambassador:"Address of the ambassador",_keepCommunities:"Boolean whether to keep the ambassador's communities or not",_toEntity:"Address of the entity"},notice:"Transfers an ambassador to another entity."},"transferCommunityToAmbassador(address,address)":{inputs:[{internalType:"address",name:"_to",type:"address"},{internalType:"address",name:"_community",type:"address"}],name:"transferCommunityToAmbassador",outputs:[],stateMutability:"nonpayable",type:"function",params:{_community:"Community address",_to:"Address of the ambassador to transfer the community to"},notice:"Transfers community from ambassador to another ambassador."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"updateCommunityAdmin(address)":{inputs:[{internalType:"contract ICommunityAdmin",name:"_newCommunityAdmin",type:"address"}],name:"updateCommunityAdmin",outputs:[],stateMutability:"nonpayable",type:"function",details:"used only for testing the new community upgrade flow",params:{_newCommunityAdmin:"address of the new communityAdmin"},notice:"Updates the address of the communityAdmin"}}},"contracts/ambassadors/AmbassadorsProxy.sol:AmbassadorsProxy":{source:"contracts/ambassadors/AmbassadorsProxy.sol",name:"AmbassadorsProxy",constructor:{inputs:[{internalType:"address",name:"_logic",type:"address"},{internalType:"address",name:"_proxyAdmin",type:"address"}],stateMutability:"nonpayable",type:"constructor"},fallback:{stateMutability:"payable",type:"fallback"},receive:{stateMutability:"payable",type:"receive"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"admin()":{inputs:[],name:"admin",outputs:[{internalType:"address",name:"admin_",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Returns the current admin. NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}. TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`"},"changeAdmin(address)":{inputs:[{internalType:"address",name:"newAdmin",type:"address"}],name:"changeAdmin",outputs:[],stateMutability:"nonpayable",type:"function",details:"Changes the admin of the proxy. Emits an {AdminChanged} event. NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}."},"implementation()":{inputs:[],name:"implementation",outputs:[{internalType:"address",name:"implementation_",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Returns the current implementation. NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}. TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy. NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy, and then call a function from the new implementation as specified by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the proxied contract. NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}."}}},"contracts/ambassadors/interfaces/AmbassadorsStorageV1.sol:AmbassadorsStorageV1":{source:"contracts/ambassadors/interfaces/AmbassadorsStorageV1.sol",name:"AmbassadorsStorageV1",title:"Storage for Ambassadors",notice:"For future upgrades, do not change AmbassadorsStorageV1. Create a new contract which implements AmbassadorsStorageV1 and following the naming convention AmbassadorsStorageVX.",methods:{"addAmbassador(address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"}],name:"addAmbassador",outputs:[],stateMutability:"nonpayable",type:"function"},"addEntity(address)":{inputs:[{internalType:"address",name:"_entity",type:"address"}],name:"addEntity",outputs:[],stateMutability:"nonpayable",type:"function"},"ambassadorByAddress(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"ambassadorByAddress",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"ambassadorByIndex(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"ambassadorByIndex",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"ambassadorIndex()":{inputs:[],name:"ambassadorIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"ambassadorToEntity(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"ambassadorToEntity",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"communityAdmin()":{inputs:[],name:"communityAdmin",outputs:[{internalType:"contract ICommunityAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"communityToAmbassador(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"communityToAmbassador",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"entityAmbassadors(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"entityAmbassadors",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"entityByAddress(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"entityByAddress",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"entityByIndex(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"entityByIndex",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"entityIndex()":{inputs:[],name:"entityIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"isAmbassador(address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"}],name:"isAmbassador",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isAmbassadorAt(address,address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"},{internalType:"address",name:"_entityAddress",type:"address"}],name:"isAmbassadorAt",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isAmbassadorOf(address,address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"},{internalType:"address",name:"_community",type:"address"}],name:"isAmbassadorOf",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isEntityOf(address,address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"},{internalType:"address",name:"_entityAddress",type:"address"}],name:"isEntityOf",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"removeAmbassador(address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"}],name:"removeAmbassador",outputs:[],stateMutability:"nonpayable",type:"function"},"removeCommunity(address)":{inputs:[{internalType:"address",name:"_community",type:"address"}],name:"removeCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"removeEntity(address)":{inputs:[{internalType:"address",name:"_entity",type:"address"}],name:"removeEntity",outputs:[],stateMutability:"nonpayable",type:"function"},"replaceAmbassador(address,address)":{inputs:[{internalType:"address",name:"_oldAmbassador",type:"address"},{internalType:"address",name:"_newAmbassador",type:"address"}],name:"replaceAmbassador",outputs:[],stateMutability:"nonpayable",type:"function"},"replaceAmbassadorAccount(address,address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"},{internalType:"address",name:"_newAmbassador",type:"address"}],name:"replaceAmbassadorAccount",outputs:[],stateMutability:"nonpayable",type:"function"},"replaceEntityAccount(address,address)":{inputs:[{internalType:"address",name:"_entity",type:"address"},{internalType:"address",name:"_newEntity",type:"address"}],name:"replaceEntityAccount",outputs:[],stateMutability:"nonpayable",type:"function"},"setCommunityToAmbassador(address,address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"},{internalType:"address",name:"_community",type:"address"}],name:"setCommunityToAmbassador",outputs:[],stateMutability:"nonpayable",type:"function"},"transferAmbassador(address,address,bool)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"},{internalType:"address",name:"_toEntity",type:"address"},{internalType:"bool",name:"_keepCommunities",type:"bool"}],name:"transferAmbassador",outputs:[],stateMutability:"nonpayable",type:"function"},"transferCommunityToAmbassador(address,address)":{inputs:[{internalType:"address",name:"_to",type:"address"},{internalType:"address",name:"_community",type:"address"}],name:"transferCommunityToAmbassador",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/ambassadors/interfaces/IAmbassadors.sol:IAmbassadors":{source:"contracts/ambassadors/interfaces/IAmbassadors.sol",name:"IAmbassadors",methods:{"addAmbassador(address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"}],name:"addAmbassador",outputs:[],stateMutability:"nonpayable",type:"function"},"addEntity(address)":{inputs:[{internalType:"address",name:"_entity",type:"address"}],name:"addEntity",outputs:[],stateMutability:"nonpayable",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"isAmbassador(address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"}],name:"isAmbassador",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isAmbassadorAt(address,address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"},{internalType:"address",name:"_entityAddress",type:"address"}],name:"isAmbassadorAt",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isAmbassadorOf(address,address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"},{internalType:"address",name:"_community",type:"address"}],name:"isAmbassadorOf",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isEntityOf(address,address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"},{internalType:"address",name:"_entityAddress",type:"address"}],name:"isEntityOf",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"removeAmbassador(address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"}],name:"removeAmbassador",outputs:[],stateMutability:"nonpayable",type:"function"},"removeCommunity(address)":{inputs:[{internalType:"address",name:"_community",type:"address"}],name:"removeCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"removeEntity(address)":{inputs:[{internalType:"address",name:"_entity",type:"address"}],name:"removeEntity",outputs:[],stateMutability:"nonpayable",type:"function"},"replaceAmbassador(address,address)":{inputs:[{internalType:"address",name:"_oldAmbassador",type:"address"},{internalType:"address",name:"_newAmbassador",type:"address"}],name:"replaceAmbassador",outputs:[],stateMutability:"nonpayable",type:"function"},"replaceAmbassadorAccount(address,address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"},{internalType:"address",name:"_newAmbassador",type:"address"}],name:"replaceAmbassadorAccount",outputs:[],stateMutability:"nonpayable",type:"function"},"replaceEntityAccount(address,address)":{inputs:[{internalType:"address",name:"_entity",type:"address"},{internalType:"address",name:"_newEntity",type:"address"}],name:"replaceEntityAccount",outputs:[],stateMutability:"nonpayable",type:"function"},"setCommunityToAmbassador(address,address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"},{internalType:"address",name:"_community",type:"address"}],name:"setCommunityToAmbassador",outputs:[],stateMutability:"nonpayable",type:"function"},"transferAmbassador(address,address,bool)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"},{internalType:"address",name:"_toEntity",type:"address"},{internalType:"bool",name:"_keepCommunities",type:"bool"}],name:"transferAmbassador",outputs:[],stateMutability:"nonpayable",type:"function"},"transferCommunityToAmbassador(address,address)":{inputs:[{internalType:"address",name:"_to",type:"address"},{internalType:"address",name:"_community",type:"address"}],name:"transferCommunityToAmbassador",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/community/CommunityAdminImplementation.sol:CommunityAdminImplementation":{source:"contracts/community/CommunityAdminImplementation.sol",name:"CommunityAdminImplementation",notice:"Welcome to CommunityAdmin, the main contract. This is an administrative (for now) contract where the admins have control over the list of communities. Being only able to add and remove communities",events:{"AmbassadorsUpdated(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldAmbassadors",type:"address"},{indexed:!0,internalType:"address",name:"newAmbassadors",type:"address"}],name:"AmbassadorsUpdated",type:"event",params:{newAmbassadors:"New Ambassador address",oldAmbassadors:"Old Ambassador address"},notice:"Triggered when the ambassadors has been updated"},"CommunityAdded(address,address[],uint256,uint256,uint256,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"communityAddress",type:"address"},{indexed:!1,internalType:"address[]",name:"managers",type:"address[]"},{indexed:!1,internalType:"uint256",name:"originalClaimAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"maxTotalClaim",type:"uint256"},{indexed:!1,internalType:"uint256",name:"decreaseStep",type:"uint256"},{indexed:!1,internalType:"uint256",name:"baseInterval",type:"uint256"},{indexed:!1,internalType:"uint256",name:"incrementInterval",type:"uint256"},{indexed:!1,internalType:"uint256",name:"minTranche",type:"uint256"},{indexed:!1,internalType:"uint256",name:"maxTranche",type:"uint256"}],name:"CommunityAdded",type:"event",params:{baseInterval:"Value of the baseInterval",communityAddress:"Address of the community that has been added",decreaseStep:"Value of the decreaseStep",incrementInterval:"Value of the incrementInterval",managers:"Addresses of the initial managers",maxTotalClaim:"Value of the maxTotalClaim",maxTranche:"Value of the maxTranche For further information regarding each parameter, see *Community* smart contract initialize method.",minTranche:"Value of the minTranche",originalClaimAmount:"Value of the originalClaimAmount"},notice:"Triggered when a community has been added"},"CommunityCopied(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"originalCommunity",type:"address"},{indexed:!0,internalType:"address",name:"copyCommunity",type:"address"}],name:"CommunityCopied",type:"event",params:{copyCommunity:"Address of the copy",originalCommunity:"Address of the community that has been copied"},notice:"Triggered when a community has been copied"},"CommunityFunded(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"community",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"CommunityFunded",type:"event",params:{amount:"Amount of the funding",community:"Address of the community"},notice:"Triggered when a community has been funded"},"CommunityImplementationUpdated(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldCommunityImplementation",type:"address"},{indexed:!0,internalType:"address",name:"newCommunityImplementation",type:"address"}],name:"CommunityImplementationUpdated",type:"event",params:{newCommunityImplementation:"New communityImplementation address",oldCommunityImplementation:"Old communityImplementation address"},notice:"Triggered when the communityImplementation address has been updated"},"CommunityMiddleProxyUpdated(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldCommunityMiddleProxy",type:"address"},{indexed:!1,internalType:"address",name:"newCommunityMiddleProxy",type:"address"}],name:"CommunityMiddleProxyUpdated",type:"event",params:{newCommunityMiddleProxy:"New communityMiddleProxy address",oldCommunityMiddleProxy:"Old communityMiddleProxy address"},notice:"Triggered when the communityMiddleProxy address has been updated"},"CommunityMigrated(address[],address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address[]",name:"managers",type:"address[]"},{indexed:!0,internalType:"address",name:"communityAddress",type:"address"},{indexed:!0,internalType:"address",name:"previousCommunityAddress",type:"address"}],name:"CommunityMigrated",type:"event",params:{communityAddress:"New community address",managers:"Addresses of the new community's initial managers",previousCommunityAddress:"Old community address"},notice:"Triggered when a community has been migrated"},"CommunityRemoved(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"communityAddress",type:"address"}],name:"CommunityRemoved",type:"event",params:{communityAddress:"Address of the community that has been removed"},notice:"Triggered when a community has been removed"},"ImpactMarketCouncilUpdated(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldImpactMarketCouncil",type:"address"},{indexed:!0,internalType:"address",name:"newImpactMarketCouncil",type:"address"}],name:"ImpactMarketCouncilUpdated",type:"event",params:{newImpactMarketCouncil:"New impactMarket Council address",oldImpactMarketCouncil:"Old impactMarket Council address"},notice:"Triggered when the impactMarket Council has been updated"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"TransferERC20(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"TransferERC20",type:"event",params:{amount:"Amount of the transaction",to:"Address of the receiver",token:"ERC20 token address"},notice:"Triggered when an amount of an ERC20 has been transferred from this contract to an address"},"TreasuryUpdated(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldTreasury",type:"address"},{indexed:!0,internalType:"address",name:"newTreasury",type:"address"}],name:"TreasuryUpdated",type:"event",params:{newTreasury:"New treasury address",oldTreasury:"Old treasury address"},notice:"Triggered when the treasury address has been updated"}},methods:{"addCommunity(address,address[],address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"address[]",name:"_managers",type:"address[]"},{internalType:"address",name:"_ambassador",type:"address"},{internalType:"uint256",name:"_originalClaimAmount",type:"uint256"},{internalType:"uint256",name:"_maxTotalClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"},{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"},{internalType:"uint256",name:"_maxBeneficiaries",type:"uint256"}],name:"addCommunity",outputs:[],stateMutability:"nonpayable",type:"function",params:{_ambassador:"address of the ambassador",_baseInterval:"base interval to start claiming",_decreaseStep:"value decreased from maxTotalClaim for every beneficiary added",_incrementInterval:"increment interval used in each claim",_managers:"addresses of the community managers",_maxBeneficiaries:"maximum number of valid beneficiaries",_maxTotalClaim:"limit that a beneficiary can claim at in total",_maxTranche:"maximum amount that the community will receive when requesting funds",_minTranche:"minimum amount that the community will receive when requesting funds",_originalClaimAmount:"maximum base amount to be claim by the beneficiary",_tokenAddress:"address of the token used by the community"},notice:"Adds a new community"},"ambassadors()":{inputs:[],name:"ambassadors",outputs:[{internalType:"contract IAmbassadors",name:"",type:"address"}],stateMutability:"view",type:"function"},"authorizedWalletAddress()":{inputs:[],name:"authorizedWalletAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"calculateCommunityTrancheAmount(address)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"}],name:"calculateCommunityTrancheAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Calculates the tranche amount of a community.",params:{_community:"address of the community"},returns:{_0:"uint256        the value of the tranche amount"}},"communities(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"communities",outputs:[{internalType:"enum ICommunityAdmin.CommunityState",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"communityImplementation()":{inputs:[],name:"communityImplementation",outputs:[{internalType:"contract ICommunity",name:"",type:"address"}],stateMutability:"view",type:"function"},"communityListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"communityListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{_index:"index of the community"},returns:{_0:"address of the community"},notice:"Returns the address of a community from communityList"},"communityListLength()":{inputs:[],name:"communityListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"uint256 number of communities"},notice:"Returns the number of communities"},"communityMiddleProxy()":{inputs:[],name:"communityMiddleProxy",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"communityProxyAdmin()":{inputs:[],name:"communityProxyAdmin",outputs:[{internalType:"contract ProxyAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"fundCommunity()":{inputs:[],name:"fundCommunity",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"Funds an existing community if it hasn't enough funds"},"getCommunityProxyImplementation(address)":{inputs:[{internalType:"address",name:"_communityProxyAddress",type:"address"}],name:"getCommunityProxyImplementation",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{_communityProxyAddress:"address of the community"},notice:"Gets a community implementation address"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function",notice:"Returns the current implementation version"},"impactMarketCouncil()":{inputs:[],name:"impactMarketCouncil",outputs:[{internalType:"contract IImpactMarketCouncil",name:"",type:"address"}],stateMutability:"view",type:"function"},"initialize(address,address)":{inputs:[{internalType:"contract ICommunity",name:"_communityImplementation",type:"address"},{internalType:"contract IERC20Upgradeable",name:"_cUSD",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_cUSD:"Address of the cUSD token",_communityImplementation:"Address of the Community implementation                              used for deploying new communities"},notice:"Used to initialize a new CommunityAdmin contract"},"isAmbassadorOrEntityOfCommunity(address,address)":{inputs:[{internalType:"address",name:"_community",type:"address"},{internalType:"address",name:"_ambassadorOrEntity",type:"address"}],name:"isAmbassadorOrEntityOfCommunity",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"bool true if the address is an ambassador or entity of the community"},notice:"Returns if an address is the ambassador or entity of the community"},"migrateCommunity(address[],address)":{inputs:[{internalType:"address[]",name:"_managers",type:"address[]"},{internalType:"contract ICommunity",name:"_previousCommunity",type:"address"}],name:"migrateCommunity",outputs:[],stateMutability:"nonpayable",type:"function",params:{_managers:"address of the community managers",_previousCommunity:"address of the community to be migrated"},notice:"Migrates a community by deploying a new contract."},"minClaimAmountRatio()":{inputs:[],name:"minClaimAmountRatio",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minClaimAmountRatioPrecision()":{inputs:[],name:"minClaimAmountRatioPrecision",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function",returns:{_0:"uint256 number of communities"},notice:"Returns the MIN_CLAIM_AMOUNT_RATIO_PRECISION"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"removeCommunity(address)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"}],name:"removeCommunity",outputs:[],stateMutability:"nonpayable",type:"function",params:{_community:"address of the community"},notice:"Removes an existing community. All community funds are transferred to the treasury"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"setCommunityToAmbassador(address,address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"},{internalType:"contract ICommunity",name:"_community",type:"address"}],name:"setCommunityToAmbassador",outputs:[],stateMutability:"nonpayable",type:"function",params:{_ambassador:"address of the ambassador",_community:"address of the community contract"},notice:"Set an existing ambassador to an existing community"},"splitCommunity(address,uint256,address,address[])":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_numberOfCopies",type:"uint256"},{internalType:"address",name:"_ambassador",type:"address"},{internalType:"address[]",name:"_managers",type:"address[]"}],name:"splitCommunity",outputs:[],stateMutability:"nonpayable",type:"function",params:{_ambassador:"address of the ambassador",_community:"address of the community to be split",_managers:"address of the community managers",_numberOfCopies:"the number of communities that will copy the data"},notice:"Migrates a community by deploying a new contract."},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"amount of the transaction",_to:"address of the receiver",_token:"address of the ERC20 token"},notice:"Transfers an amount of an ERC20 from this contract to an address"},"transferFromCommunity(address,address,address,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transferFromCommunity",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"amount of the transaction",_community:"address of the community",_to:"address of the receiver",_token:"address of the ERC20 token"},notice:"Transfers an amount of an ERC20 from  community to an address"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"contract ITreasury",name:"",type:"address"}],stateMutability:"view",type:"function"},"treasuryMinBalance()":{inputs:[],name:"treasuryMinBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"treasurySafetyPercentage()":{inputs:[],name:"treasurySafetyPercentage",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"updateAmbassadors(address)":{inputs:[{internalType:"contract IAmbassadors",name:"_newAmbassadors",type:"address"}],name:"updateAmbassadors",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newAmbassadors:"address of new implementation contract"},notice:"Updates proxy implementation address of ambassadors"},"updateAuthorizedWalletAddress(address)":{inputs:[{internalType:"address",name:"_newAuthorizedWalletAddress",type:"address"}],name:"updateAuthorizedWalletAddress",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newAuthorizedWalletAddress:"address of the new backend wallet"},notice:"Updates the address of the backend wallet"},"updateBeneficiaryParams(address,uint256,uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_originalClaimAmount",type:"uint256"},{internalType:"uint256",name:"_maxTotalClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"},{internalType:"uint256",name:"_maxBeneficiaries",type:"uint256"}],name:"updateBeneficiaryParams",outputs:[],stateMutability:"nonpayable",type:"function",params:{_baseInterval:"base interval to start claiming",_community:"address of the community",_decreaseStep:"value decreased from maxTotalClaim each time a is beneficiary added",_incrementInterval:"increment interval used in each claim",_maxBeneficiaries:"maximum number of beneficiaries",_maxTotalClaim:"limit that a beneficiary can claim  in total",_originalClaimAmount:"maximum base amount to be claim by the beneficiary"},notice:"Updates the beneficiary params of a community"},"updateCommunityImplementation(address)":{inputs:[{internalType:"contract ICommunity",name:"_newCommunityImplementation",type:"address"}],name:"updateCommunityImplementation",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newCommunityImplementation:"address of the new communityImplementation contract"},notice:"Updates the address of the the communityImplementation"},"updateCommunityMiddleProxy(address)":{inputs:[{internalType:"address",name:"_newCommunityMiddleProxy",type:"address"}],name:"updateCommunityMiddleProxy",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newCommunityMiddleProxy:"address of new implementation contract"},notice:"Updates communityMiddleProxy address"},"updateCommunityParams(address,uint256,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"}],name:"updateCommunityParams",outputs:[],stateMutability:"nonpayable",type:"function",params:{_community:"address of the community",_maxTranche:"maximum amount that the community will receive when requesting funds",_minTranche:"minimum amount that the community will receive when requesting funds"},notice:"Updates params of a community"},"updateCommunityToken(address,address,address[],uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"contract IERC20Upgradeable",name:"_newToken",type:"address"},{internalType:"address[]",name:"_exchangePath",type:"address[]"},{internalType:"uint256",name:"_originalClaimAmount",type:"uint256"},{internalType:"uint256",name:"_maxTotalClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"}],name:"updateCommunityToken",outputs:[],stateMutability:"nonpayable",type:"function",params:{_community:"address of the community",_exchangePath:"path used by uniswap to exchange the current tokens to the new tokens",_newToken:"new token address"},notice:"Updates token address of a community"},"updateImpactMarketCouncil(address)":{inputs:[{internalType:"contract IImpactMarketCouncil",name:"_newImpactMarketCouncil",type:"address"}],name:"updateImpactMarketCouncil",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newImpactMarketCouncil:"address of new implementation contract"},notice:"Updates proxy implementation address of impactMarket council"},"updateMinClaimAmountRatio(uint256)":{inputs:[{internalType:"uint256",name:"_newMinClaimAmountRatio",type:"uint256"}],name:"updateMinClaimAmountRatio",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newMinClaimAmountRatio:"value of the minClaimAmountRatio !!! be aware that this value will be divided by MIN_CLAIM_AMOUNT_RATIO_PRECISION"},notice:"Updates the value of the minClaimAmountRatio"},"updateProxyImplementation(address,address)":{inputs:[{internalType:"address",name:"_communityMiddleProxy",type:"address"},{internalType:"address",name:"_newCommunityImplementation",type:"address"}],name:"updateProxyImplementation",outputs:[],stateMutability:"nonpayable",type:"function",params:{_communityMiddleProxy:"address of the community",_newCommunityImplementation:"address of new implementation contract"},notice:"Updates proxy implementation address of a community use this only for changing the implementation for one community for updating the implementation for (almost) all communities, just update the communityImplementation param"},"updateTreasury(address)":{inputs:[{internalType:"contract ITreasury",name:"_newTreasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newTreasury:"address of the new treasury contract"},notice:"Updates the address of the treasury"},"updateTreasuryMinBalance(uint256)":{inputs:[{internalType:"uint256",name:"_newTreasuryMinBalance",type:"uint256"}],name:"updateTreasuryMinBalance",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newTreasuryMinBalance:"value of the treasuryMinBalance"},notice:"Updates the value of the treasuryMinBalance"},"updateTreasurySafetyPercentage(uint256)":{inputs:[{internalType:"uint256",name:"_newTreasurySafetyPercentage",type:"uint256"}],name:"updateTreasurySafetyPercentage",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newTreasurySafetyPercentage:"value of the treasurySafetyPercentage"},notice:"Updates the value of the treasurySafetyPercentage"}}},"contracts/community/CommunityAdminProxy.sol:CommunityAdminProxy":{source:"contracts/community/CommunityAdminProxy.sol",name:"CommunityAdminProxy",constructor:{inputs:[{internalType:"address",name:"_logic",type:"address"},{internalType:"address",name:"_proxyAdmin",type:"address"}],stateMutability:"nonpayable",type:"constructor"},fallback:{stateMutability:"payable",type:"fallback"},receive:{stateMutability:"payable",type:"receive"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"admin()":{inputs:[],name:"admin",outputs:[{internalType:"address",name:"admin_",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Returns the current admin. NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}. TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`"},"changeAdmin(address)":{inputs:[{internalType:"address",name:"newAdmin",type:"address"}],name:"changeAdmin",outputs:[],stateMutability:"nonpayable",type:"function",details:"Changes the admin of the proxy. Emits an {AdminChanged} event. NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}."},"implementation()":{inputs:[],name:"implementation",outputs:[{internalType:"address",name:"implementation_",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Returns the current implementation. NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}. TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy. NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy, and then call a function from the new implementation as specified by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the proxied contract. NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}."}}},"contracts/community/CommunityImplementation.sol:CommunityImplementation":{source:"contracts/community/CommunityImplementation.sol",name:"CommunityImplementation",notice:"Welcome to the Community contract. For each community there will be one proxy contract deployed by CommunityAdmin. The implementation of the proxy is this contract. This enable us to save tokens on the contract itself, and avoid the problems of having everything in one single contract. Each community has it's own members and and managers.",events:{"BeneficiaryAdded(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"manager",type:"address"},{indexed:!0,internalType:"address",name:"beneficiary",type:"address"}],name:"BeneficiaryAdded",type:"event",params:{beneficiary:"Address of the beneficiary that has been added",manager:"Address of the manager that triggered the event"},notice:"Triggered when a beneficiary has been added"},"BeneficiaryAddressChanged(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beneficiary1",type:"address"},{indexed:!0,internalType:"address",name:"beneficiary2",type:"address"}],name:"BeneficiaryAddressChanged",type:"event",params:{beneficiary1:"Address of the first beneficiary",beneficiary2:"Address of the second beneficiary"},notice:"Triggered when two beneficiaries has been merged"},"BeneficiaryClaim(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beneficiary",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"BeneficiaryClaim",type:"event",params:{amount:"Amount of the claim",beneficiary:"Address of the beneficiary that has claimed"},notice:"Triggered when a beneficiary has claimed"},"BeneficiaryCopied(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"manager",type:"address"},{indexed:!0,internalType:"address",name:"beneficiary",type:"address"}],name:"BeneficiaryCopied",type:"event",params:{beneficiary:"Address of the beneficiary that has been added",manager:"Address of the manager that triggered the event"},notice:"Triggered when a beneficiary has been copied"},"BeneficiaryJoined(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beneficiary",type:"address"}],name:"BeneficiaryJoined",type:"event",params:{beneficiary:"Address of the beneficiary"},notice:"Triggered when a beneficiary from previous community has joined in the current community"},"BeneficiaryLocked(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"manager",type:"address"},{indexed:!0,internalType:"address",name:"beneficiary",type:"address"}],name:"BeneficiaryLocked",type:"event",params:{beneficiary:"Address of the beneficiary that has been locked",manager:"Address of the manager that triggered the event"},notice:"Triggered when a beneficiary has been locked"},"BeneficiaryParamsUpdated(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldOriginalClaimAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldMaxTotalClaim",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldDecreaseStep",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldBaseInterval",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldIncrementInterval",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newOriginalClaimAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newMaxTotalClaim",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newDecreaseStep",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newBaseInterval",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newIncrementInterval",type:"uint256"}],name:"BeneficiaryParamsUpdated",type:"event",params:{newBaseInterval:"New baseInterval value",newDecreaseStep:"New decreaseStep value",newIncrementInterval:"New incrementInterval value For further information regarding each parameter, see *Community* smart contract initialize method.",newMaxTotalClaim:"New maxTotalClaim value",newOriginalClaimAmount:"New originalClaimAmount value",oldBaseInterval:"Old baseInterval value",oldDecreaseStep:"Old decreaseStep value",oldIncrementInterval:"Old incrementInterval value",oldMaxTotalClaim:"Old maxTotalClaim value",oldOriginalClaimAmount:"Old originalClaimAmount value"},notice:"Triggered when beneficiary params has been updated"},"BeneficiaryRemoved(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"manager",type:"address"},{indexed:!0,internalType:"address",name:"beneficiary",type:"address"}],name:"BeneficiaryRemoved",type:"event",params:{beneficiary:"Address of the beneficiary that has been removed",manager:"Address of the manager that triggered the event"},notice:"Triggered when a beneficiary has been removed"},"BeneficiaryUnlocked(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"manager",type:"address"},{indexed:!0,internalType:"address",name:"beneficiary",type:"address"}],name:"BeneficiaryUnlocked",type:"event",params:{beneficiary:"Address of the beneficiary that has been unlocked",manager:"Address of the manager that triggered the event"},notice:"Triggered when a beneficiary has been unlocked"},"ClaimAmountUpdated(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldClaimAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newClaimAmount",type:"uint256"}],name:"ClaimAmountUpdated",type:"event",params:{newClaimAmount:"New claimAmount value",oldClaimAmount:"Old claimAmount value"},notice:"Triggered when claimAmount has been changed"},"CommunityAdminUpdated(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldCommunityAdmin",type:"address"},{indexed:!0,internalType:"address",name:"newCommunityAdmin",type:"address"}],name:"CommunityAdminUpdated",type:"event",params:{newCommunityAdmin:"New communityAdmin address",oldCommunityAdmin:"Old communityAdmin address"},notice:"Triggered when communityAdmin has been updated"},"CommunityLocked(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"manager",type:"address"}],name:"CommunityLocked",type:"event",params:{manager:"Address of the manager that triggered the event"},notice:"Triggered when a community has been locked"},"CommunityParamsUpdated(uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldMinTranche",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldMaxTranche",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newMinTranche",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newMaxTranche",type:"uint256"}],name:"CommunityParamsUpdated",type:"event",params:{newMaxTranche:"New maxTranche value For further information regarding each parameter, see *Community* smart contract initialize method.",newMinTranche:"New minTranche value",oldMaxTranche:"Old maxTranche value",oldMinTranche:"Old minTranche value"},notice:"Triggered when community params has been updated"},"CommunityUnlocked(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"manager",type:"address"}],name:"CommunityUnlocked",type:"event",params:{manager:"Address of the manager that triggered the event"},notice:"Triggered when a community has been unlocked"},"Donate(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"donor",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Donate",type:"event",params:{amount:"Amount of the donation",donor:"Address of the donor"},notice:"Triggered when someone has donated token"},"FundsRequested(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"manager",type:"address"}],name:"FundsRequested",type:"event",params:{manager:"Address of the manager that triggered the event"},notice:"Triggered when a manager has requested funds for community"},"ManagerAdded(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"manager",type:"address"},{indexed:!0,internalType:"address",name:"account",type:"address"}],name:"ManagerAdded",type:"event",params:{account:"Address of the manager that has been added",manager:"Address of the manager that triggered the event                          or address of the CommunityAdmin if it's first manager"},notice:"Triggered when a manager has been added"},"ManagerRemoved(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"manager",type:"address"},{indexed:!0,internalType:"address",name:"account",type:"address"}],name:"ManagerRemoved",type:"event",params:{account:"Address of the manager that has been removed",manager:"Address of the manager that triggered the event"},notice:"Triggered when a manager has been removed"},"MaxBeneficiariesUpdated(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldMaxBeneficiaries",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newMaxBeneficiaries",type:"uint256"}],name:"MaxBeneficiariesUpdated",type:"event",params:{newMaxBeneficiaries:"New maxBeneficiaries value",oldMaxBeneficiaries:"Old maxBeneficiaries value"},notice:"Triggered when maxBeneficiaries has been updated"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"PreviousCommunityUpdated(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldPreviousCommunity",type:"address"},{indexed:!0,internalType:"address",name:"newPreviousCommunity",type:"address"}],name:"PreviousCommunityUpdated",type:"event",params:{newPreviousCommunity:"New previousCommunity address",oldPreviousCommunity:"Old previousCommunity address"},notice:"Triggered when previousCommunity has been updated"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"TokenUpdated(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldTokenAddress",type:"address"},{indexed:!0,internalType:"address",name:"newTokenAddress",type:"address"}],name:"TokenUpdated",type:"event",params:{newTokenAddress:"New token address",oldTokenAddress:"Old token address"},notice:"Triggered when token address has been updated"},"TransferERC20(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"TransferERC20",type:"event",params:{amount:"Amount of the transaction",to:"Address of the receiver",token:"ERC20 token address"},notice:"Triggered when an amount of an ERC20 has been transferred from this contract to an address"}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"_token()":{inputs:[],name:"_token",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"addBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"addBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function",params:{_beneficiaryAddresses:"addresses of the beneficiaries to be added"},notice:"Adds new beneficiaries"},"addBeneficiariesUsingSignature(address[],uint256,bytes)":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"},{internalType:"uint256",name:"_expirationTimestamp",type:"uint256"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"addBeneficiariesUsingSignature",outputs:[],stateMutability:"nonpayable",type:"function",params:{_beneficiaryAddresses:"addresses of the beneficiaries to be added",_expirationTimestamp:"timestamp when the signature will expire/expired",_signature:"the signature of a manager"},notice:"Adds new beneficiaries using a manager signature"},"addBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"addBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function",params:{_beneficiaryAddress:"address of the beneficiary to be added"},notice:"Adds a new beneficiary"},"addCopy(address)":{inputs:[{internalType:"contract ICommunity",name:"_copy",type:"address"}],name:"addCopy",outputs:[],stateMutability:"nonpayable",type:"function",params:{_copy:"address of the 'child' community"},notice:"Adds a new copy of this community"},"addManager(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"addManager",outputs:[],stateMutability:"nonpayable",type:"function",params:{_account:"address of the manager to be added"},notice:"Adds a new manager"},"addTreasuryFunds(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"addTreasuryFunds",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"amount to be added to treasuryFunds"},notice:"Increases the treasuryFunds value Used by communityAdmin after an amount of tokens are sent from the treasury"},"baseInterval()":{inputs:[],name:"baseInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"beneficiaries(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"beneficiaries",outputs:[{internalType:"enum ICommunity.BeneficiaryState",name:"state",type:"uint8"},{internalType:"uint256",name:"claims",type:"uint256"},{internalType:"uint256",name:"claimedAmount",type:"uint256"},{internalType:"uint256",name:"lastClaim",type:"uint256"}],stateMutability:"view",type:"function",params:{_beneficiaryAddress:"address of the beneficiary"},returns:{claimedAmount:"        the amount he has claimed",claims:"               how many times the beneficiary has claimed",lastClaim:"            block number of the last claim",state:"                the status of the beneficiary"},notice:"Returns the data of a beneficiary"},"beneficiaryClaimedAmounts(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"beneficiaryClaimedAmounts",outputs:[{internalType:"uint256[]",name:"claimedAmounts",type:"uint256[]"}],stateMutability:"view",type:"function",params:{_beneficiaryAddress:"address of the beneficiary"},returns:{claimedAmounts:"       a uint256 array with all claimed amounts in the same order as tokenList array"},notice:"Returns the beneficiary's claimed amounts for each token"},"beneficiaryJoinFromMigrated(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"beneficiaryJoinFromMigrated",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Allows a beneficiary from the previousCommunity to join in this community"},"beneficiaryListAt(uint256)":{inputs:[{internalType:"uint256",name:"index_",type:"uint256"}],name:"beneficiaryListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{index_:"index value"},returns:{_0:"address of the beneficiary"},notice:"Returns an address from the beneficiaryList"},"beneficiaryListLength()":{inputs:[],name:"beneficiaryListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"Returns the length of the beneficiaryList"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Returns the cUSD contract address todo: to be removed, use token() instead"},"changeBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"_newBeneficiaryAddress",type:"address"}],name:"changeBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"used by beneficiaries",notice:"Allows a beneficiary to use another address this action adds claim details from both addresses"},"changeBeneficiaryAddressByManager(address,address)":{inputs:[{internalType:"address",name:"_oldBeneficiaryAddress",type:"address"},{internalType:"address",name:"_newBeneficiaryAddress",type:"address"}],name:"changeBeneficiaryAddressByManager",outputs:[],stateMutability:"nonpayable",type:"function",details:"used by managers",notice:"Changes the address of a beneficiary this action adds claim details from both addresses"},"claim()":{inputs:[],name:"claim",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers tokens to a valid beneficiary"},"claimAmount()":{inputs:[],name:"claimAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimCooldown(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"claimCooldown",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_beneficiaryAddress:"address of the beneficiary"},returns:{_0:"uint256 number of block when the beneficiary can claim"},notice:"Returns the block number when a beneficiary can claim again"},"communityAdmin()":{inputs:[],name:"communityAdmin",outputs:[{internalType:"contract ICommunityAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"copies()":{inputs:[],name:"copies",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",notice:"Returns the list with all communities copies"},"copyBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"copyBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function",params:{_beneficiaryAddresses:"addresses of the beneficiaries to be copied"},notice:"Copies beneficiaries from the original community"},"copyCommunityDetails(address)":{inputs:[{internalType:"contract ICommunity",name:"_originalCommunity",type:"address"}],name:"copyCommunityDetails",outputs:[],stateMutability:"nonpayable",type:"function",params:{_originalCommunity:"address of the 'parent' community"},notice:"Copies the original community details that haven't been copied in the initialize method  !!used only by communityAdmin.copyCommunity method"},"copyOf()":{inputs:[],name:"copyOf",outputs:[{internalType:"contract ICommunity",name:"",type:"address"}],stateMutability:"view",type:"function"},"decreaseStep()":{inputs:[],name:"decreaseStep",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donate(address,uint256)":{inputs:[{internalType:"address",name:"_sender",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"donate",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"amount to be donated",_sender:"address of the sender"},notice:"Transfers tokens from donor to this community Used by donationToCommunity method from DonationMiner contract"},"getInitialMaxClaim()":{inputs:[],name:"getInitialMaxClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"Returns the initial maxTotalClaim todo: do be deleted after updating all communities to v3"},"getInitialMaxTotalClaim()":{inputs:[],name:"getInitialMaxTotalClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"Returns the initial maxTotalClaim"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function",notice:"Returns the current implementation version"},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"",type:"bytes32"},{internalType:"address",name:"",type:"address"}],name:"grantRole",outputs:[],stateMutability:"pure",type:"function",notice:"Enforces managers to use addManager method"},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"impactMarketAddress()":{inputs:[],name:"impactMarketAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function",notice:"Returns the 0 address only used for backwards compatibility"},"incrementInterval()":{inputs:[],name:"incrementInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"initialize(address,address[],uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"address[]",name:"_managers",type:"address[]"},{internalType:"uint256",name:"_originalClaimAmount",type:"uint256"},{internalType:"uint256",name:"_maxTotalClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"},{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"},{internalType:"uint256",name:"_maxBeneficiaries",type:"uint256"},{internalType:"contract ICommunity",name:"_previousCommunity",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_baseInterval:"Base interval to start claiming",_decreaseStep:"Value decreased from maxTotalClaim each time a beneficiary is added",_incrementInterval:"Increment interval used in each claim",_managers:"Community's initial managers                             Will be able to add others",_maxBeneficiaries:"Maximum valid beneficiaries number",_maxTotalClaim:"Limit that a beneficiary can claim in total",_maxTranche:"Maximum amount that the community will receive when requesting funds",_minTranche:"Minimum amount that the community will receive when requesting funds",_originalClaimAmount:"Maximum base amount to be claim by the beneficiary",_previousCommunity:"Previous smart contract address of community",_tokenAddress:"Address of the token used by the community"},notice:"Used to initialize a new Community contract"},"isSelfFunding()":{inputs:[],name:"isSelfFunding",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"lastFundRequest()":{inputs:[],name:"lastFundRequest",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lastInterval(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"lastInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_beneficiaryAddress:"address of the beneficiary"},returns:{_0:"uint256 number of blocks for the lastInterval"},notice:"Returns the number of blocks that a beneficiary have to wait between claims"},"lock()":{inputs:[],name:"lock",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Locks the community"},"lockBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"lockBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function",params:{_beneficiaryAddresses:"addresses of the beneficiaries to be locked"},notice:"Locks a list of beneficiaries"},"lockBeneficiariesUsingSignature(address[],uint256,bytes)":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"},{internalType:"uint256",name:"_expirationTimestamp",type:"uint256"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"lockBeneficiariesUsingSignature",outputs:[],stateMutability:"nonpayable",type:"function",params:{_beneficiaryAddresses:"addresses of the beneficiaries to be locked",_expirationTimestamp:"timestamp when the signature will expire/expired",_signature:"the signature of a manager"},notice:"Locks a list of beneficiaries using a manager signature"},"lockBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"lockBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function",params:{_beneficiaryAddress:"address of the beneficiary to be locked"},notice:"Locks a valid beneficiary"},"locked()":{inputs:[],name:"locked",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"maxBeneficiaries()":{inputs:[],name:"maxBeneficiaries",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"maxClaim()":{inputs:[],name:"maxClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"Returns the amount that can be claimed by a beneficiary in total todo: remove it after the frontend is updated to the new function: maxTotalClaim()"},"maxTotalClaim()":{inputs:[],name:"maxTotalClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"maxTranche()":{inputs:[],name:"maxTranche",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minTranche()":{inputs:[],name:"minTranche",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"originalClaimAmount()":{inputs:[],name:"originalClaimAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"previousCommunity()":{inputs:[],name:"previousCommunity",outputs:[{internalType:"contract ICommunity",name:"",type:"address"}],stateMutability:"view",type:"function"},"privateFunds()":{inputs:[],name:"privateFunds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"removeBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"removeBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function",params:{_beneficiaryAddresses:"addresses of the beneficiaries to be removed"},notice:"Removes a list of beneficiaries"},"removeBeneficiariesUsingSignature(address[],uint256,bytes)":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"},{internalType:"uint256",name:"_expirationTimestamp",type:"uint256"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"removeBeneficiariesUsingSignature",outputs:[],stateMutability:"nonpayable",type:"function",params:{_beneficiaryAddresses:"addresses of the beneficiaries to be removed",_expirationTimestamp:"timestamp when the signature will expire/expired",_signature:"the signature of a manager"},notice:"Removes a list of beneficiaries using a manager signature"},"removeBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"removeBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function",params:{_beneficiaryAddress:"address of the beneficiary to be removed"},notice:"Remove an existing beneficiary"},"removeManager(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"removeManager",outputs:[],stateMutability:"nonpayable",type:"function",params:{_account:"address of the manager to be removed"},notice:"Remove an existing manager"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"requestFunds()":{inputs:[],name:"requestFunds",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Requests treasury funds from the communityAdmin"},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"",type:"bytes32"},{internalType:"address",name:"",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"pure",type:"function",notice:"Enforces managers to use removeManager method"},"setBeneficiaryState(address,uint8)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"},{internalType:"enum ICommunity.BeneficiaryState",name:"_state",type:"uint8"}],name:"setBeneficiaryState",outputs:[],stateMutability:"nonpayable",type:"function",params:{_beneficiaryAddress:"address of the beneficiary",_state:"beneficiary's state"},notice:"Sets a beneficiary's state"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"token()":{inputs:[],name:"token",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Returns the address of the token used by this community"},"tokenList()":{inputs:[],name:"tokenList",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function"},"tokenUpdates(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tokenUpdates",outputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"ratio",type:"uint256"},{internalType:"uint256",name:"startBlock",type:"uint256"}],stateMutability:"view",type:"function"},"tokenUpdatesLength()":{inputs:[],name:"tokenUpdatesLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"Returns the length of the tokenList"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"amount of the transaction",_to:"address of the receiver",_token:"address of the ERC20 token"},notice:"Transfers an amount of an ERC20 from this contract to an address"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"treasuryFunds()":{inputs:[],name:"treasuryFunds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"unlock()":{inputs:[],name:"unlock",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Unlocks the community"},"unlockBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"unlockBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function",params:{_beneficiaryAddresses:"addresses of the beneficiaries to be unlocked"},notice:"Unlocks a list of beneficiaries"},"unlockBeneficiariesUsingSignature(address[],uint256,bytes)":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"},{internalType:"uint256",name:"_expirationTimestamp",type:"uint256"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"unlockBeneficiariesUsingSignature",outputs:[],stateMutability:"nonpayable",type:"function",params:{_beneficiaryAddresses:"addresses of the beneficiaries to be unlocked",_expirationTimestamp:"timestamp when the signature will expire/expired",_signature:"the signature of a manager"},notice:"Unlocks a list of beneficiaries using a manager signature"},"unlockBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"unlockBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function",params:{_beneficiaryAddress:"address of the beneficiary to be unlocked"},notice:"Unlocks a locked beneficiary"},"updateBeneficiaryParams(uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_originalClaimAmount",type:"uint256"},{internalType:"uint256",name:"_maxTotalClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"}],name:"updateBeneficiaryParams",outputs:[],stateMutability:"nonpayable",type:"function",params:{_baseInterval:"base interval to start claiming",_decreaseStep:"value decreased from maxTotalClaim each time a is beneficiary added",_incrementInterval:"increment interval used in each claim",_maxTotalClaim:"limit that a beneficiary can claim  in total",_originalClaimAmount:"maximum base amount to be claim by the beneficiary"},notice:"Updates beneficiary paramsbe aware that max claim will not be the same with the value you've provided             maxTotalClaim = _maxTotalClaim - validBeneficiaryCount * _decreaseStep"},"updateCommunityAdmin(address)":{inputs:[{internalType:"contract ICommunityAdmin",name:"_newCommunityAdmin",type:"address"}],name:"updateCommunityAdmin",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newCommunityAdmin:"address of the new communityAdmin"},notice:"Updates the address of the communityAdmin"},"updateCommunityParams(uint256,uint256)":{inputs:[{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"}],name:"updateCommunityParams",outputs:[],stateMutability:"nonpayable",type:"function",params:{_maxTranche:"maximum amount that the community will receive when requesting funds",_minTranche:"minimum amount that the community will receive when requesting funds"},notice:"Updates params of a community"},"updateMaxBeneficiaries(uint256)":{inputs:[{internalType:"uint256",name:"_newMaxBeneficiaries",type:"uint256"}],name:"updateMaxBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newMaxBeneficiaries:"new _maxBeneficiaries value"},notice:"Updates maxBeneficiaries"},"updatePreviousCommunity(address)":{inputs:[{internalType:"contract ICommunity",name:"_newPreviousCommunity",type:"address"}],name:"updatePreviousCommunity",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newPreviousCommunity:"address of the new previousCommunity"},notice:"Updates the address of the previousCommunity"},"updateToken(address,address[],uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_newToken",type:"address"},{internalType:"address[]",name:"_exchangePath",type:"address[]"},{internalType:"uint256",name:"_originalClaimAmount",type:"uint256"},{internalType:"uint256",name:"_maxTotalClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"}],name:"updateToken",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Updates token address   !!!!!! you must be careful about _maxTotalClaim value. This value determines all beneficiaries claimedAmounts"},"validBeneficiaryCount()":{inputs:[],name:"validBeneficiaryCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/community/CommunityMiddleProxy.sol:CommunityMiddleProxy":{source:"contracts/community/CommunityMiddleProxy.sol",name:"CommunityMiddleProxy",constructor:{inputs:[{internalType:"address",name:"_fakeLogic",type:"address"},{internalType:"address",name:"_fakeProxyAdmin",type:"address"}],stateMutability:"nonpayable",type:"constructor"},fallback:{stateMutability:"payable",type:"fallback"},receive:{stateMutability:"payable",type:"receive"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"admin()":{inputs:[],name:"admin",outputs:[{internalType:"address",name:"admin_",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Returns the current admin. NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}. TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`"},"changeAdmin(address)":{inputs:[{internalType:"address",name:"newAdmin",type:"address"}],name:"changeAdmin",outputs:[],stateMutability:"nonpayable",type:"function",details:"Changes the admin of the proxy. Emits an {AdminChanged} event. NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}."},"implementation()":{inputs:[],name:"implementation",outputs:[{internalType:"address",name:"implementation_",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Returns the current implementation. NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}. TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy. NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy, and then call a function from the new implementation as specified by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the proxied contract. NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}."}}},"contracts/community/interfaces/CommunityAdminStorageV1.sol:CommunityAdminStorageV1":{source:"contracts/community/interfaces/CommunityAdminStorageV1.sol",name:"CommunityAdminStorageV1",title:"Storage for CommunityAdmin",notice:"For future upgrades, do not change CommunityAdminStorageV1. Create a new contract which implements CommunityAdminStorageV1 and following the naming convention CommunityAdminStorageVX.",methods:{"addCommunity(address,address[],address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"address[]",name:"_managers",type:"address[]"},{internalType:"address",name:"_ambassador",type:"address"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"},{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"},{internalType:"uint256",name:"_maxBeneficiaries",type:"uint256"}],name:"addCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"ambassadors()":{inputs:[],name:"ambassadors",outputs:[{internalType:"contract IAmbassadors",name:"",type:"address"}],stateMutability:"view",type:"function"},"authorizedWalletAddress()":{inputs:[],name:"authorizedWalletAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"calculateCommunityTrancheAmount(address)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"}],name:"calculateCommunityTrancheAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"communities(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"communities",outputs:[{internalType:"enum ICommunityAdmin.CommunityState",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"communityImplementation()":{inputs:[],name:"communityImplementation",outputs:[{internalType:"contract ICommunity",name:"",type:"address"}],stateMutability:"view",type:"function"},"communityListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"communityListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"communityListLength()":{inputs:[],name:"communityListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"communityMiddleProxy()":{inputs:[],name:"communityMiddleProxy",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"communityProxyAdmin()":{inputs:[],name:"communityProxyAdmin",outputs:[{internalType:"contract ProxyAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"fundCommunity()":{inputs:[],name:"fundCommunity",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"getCommunityProxyImplementation(address)":{inputs:[{internalType:"address",name:"_communityProxyAddress",type:"address"}],name:"getCommunityProxyImplementation",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"impactMarketCouncil()":{inputs:[],name:"impactMarketCouncil",outputs:[{internalType:"contract IImpactMarketCouncil",name:"",type:"address"}],stateMutability:"view",type:"function"},"isAmbassadorOrEntityOfCommunity(address,address)":{inputs:[{internalType:"address",name:"_community",type:"address"},{internalType:"address",name:"_ambassadorOrEntity",type:"address"}],name:"isAmbassadorOrEntityOfCommunity",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"migrateCommunity(address[],address)":{inputs:[{internalType:"address[]",name:"_managers",type:"address[]"},{internalType:"contract ICommunity",name:"_previousCommunity",type:"address"}],name:"migrateCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"minClaimAmountRatio()":{inputs:[],name:"minClaimAmountRatio",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minClaimAmountRatioPrecision()":{inputs:[],name:"minClaimAmountRatioPrecision",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"removeCommunity(address)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"}],name:"removeCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"setCommunityToAmbassador(address,address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"},{internalType:"contract ICommunity",name:"_communityAddress",type:"address"}],name:"setCommunityToAmbassador",outputs:[],stateMutability:"nonpayable",type:"function"},"splitCommunity(address,uint256,address,address[])":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_numberOfCopies",type:"uint256"},{internalType:"address",name:"_ambassador",type:"address"},{internalType:"address[]",name:"_managers",type:"address[]"}],name:"splitCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"transferFromCommunity(address,address,address,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transferFromCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"contract ITreasury",name:"",type:"address"}],stateMutability:"view",type:"function"},"treasuryMinBalance()":{inputs:[],name:"treasuryMinBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"treasurySafetyPercentage()":{inputs:[],name:"treasurySafetyPercentage",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"updateAmbassadors(address)":{inputs:[{internalType:"contract IAmbassadors",name:"_newAmbassadors",type:"address"}],name:"updateAmbassadors",outputs:[],stateMutability:"nonpayable",type:"function"},"updateAuthorizedWalletAddress(address)":{inputs:[{internalType:"address",name:"_newSignerAddress",type:"address"}],name:"updateAuthorizedWalletAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"updateBeneficiaryParams(address,uint256,uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"},{internalType:"uint256",name:"_maxBeneficiaries",type:"uint256"}],name:"updateBeneficiaryParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityImplementation(address)":{inputs:[{internalType:"contract ICommunity",name:"_communityImplementation_",type:"address"}],name:"updateCommunityImplementation",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityMiddleProxy(address)":{inputs:[{internalType:"address",name:"_communityMiddleProxy",type:"address"}],name:"updateCommunityMiddleProxy",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityParams(address,uint256,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"}],name:"updateCommunityParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityToken(address,address,address[],uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"contract IERC20Upgradeable",name:"_newToken",type:"address"},{internalType:"address[]",name:"_exchangePath",type:"address[]"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"}],name:"updateCommunityToken",outputs:[],stateMutability:"nonpayable",type:"function"},"updateImpactMarketCouncil(address)":{inputs:[{internalType:"contract IImpactMarketCouncil",name:"_newImpactMarketCouncil",type:"address"}],name:"updateImpactMarketCouncil",outputs:[],stateMutability:"nonpayable",type:"function"},"updateMinClaimAmountRatio(uint256)":{inputs:[{internalType:"uint256",name:"_newMinClaimAmountRatio",type:"uint256"}],name:"updateMinClaimAmountRatio",outputs:[],stateMutability:"nonpayable",type:"function"},"updateProxyImplementation(address,address)":{inputs:[{internalType:"address",name:"_communityMiddleProxy",type:"address"},{internalType:"address",name:"_newLogic",type:"address"}],name:"updateProxyImplementation",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasury(address)":{inputs:[{internalType:"contract ITreasury",name:"_newTreasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasuryMinBalance(uint256)":{inputs:[{internalType:"uint256",name:"_newTreasuryMinBalance",type:"uint256"}],name:"updateTreasuryMinBalance",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasurySafetyPercentage(uint256)":{inputs:[{internalType:"uint256",name:"_newTreasurySafetyPercentage",type:"uint256"}],name:"updateTreasurySafetyPercentage",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/community/interfaces/CommunityAdminStorageV2.sol:CommunityAdminStorageV2":{source:"contracts/community/interfaces/CommunityAdminStorageV2.sol",name:"CommunityAdminStorageV2",title:"Storage for CommunityAdmin",notice:"For future upgrades, do not change CommunityAdminStorageV1. Create a new contract which implements CommunityAdminStorageV1 and following the naming convention CommunityAdminStorageVX.",methods:{"addCommunity(address,address[],address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"address[]",name:"_managers",type:"address[]"},{internalType:"address",name:"_ambassador",type:"address"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"},{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"},{internalType:"uint256",name:"_maxBeneficiaries",type:"uint256"}],name:"addCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"ambassadors()":{inputs:[],name:"ambassadors",outputs:[{internalType:"contract IAmbassadors",name:"",type:"address"}],stateMutability:"view",type:"function"},"authorizedWalletAddress()":{inputs:[],name:"authorizedWalletAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"calculateCommunityTrancheAmount(address)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"}],name:"calculateCommunityTrancheAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"communities(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"communities",outputs:[{internalType:"enum ICommunityAdmin.CommunityState",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"communityImplementation()":{inputs:[],name:"communityImplementation",outputs:[{internalType:"contract ICommunity",name:"",type:"address"}],stateMutability:"view",type:"function"},"communityListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"communityListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"communityListLength()":{inputs:[],name:"communityListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"communityMiddleProxy()":{inputs:[],name:"communityMiddleProxy",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"communityProxyAdmin()":{inputs:[],name:"communityProxyAdmin",outputs:[{internalType:"contract ProxyAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"fundCommunity()":{inputs:[],name:"fundCommunity",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"getCommunityProxyImplementation(address)":{inputs:[{internalType:"address",name:"_communityProxyAddress",type:"address"}],name:"getCommunityProxyImplementation",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"impactMarketCouncil()":{inputs:[],name:"impactMarketCouncil",outputs:[{internalType:"contract IImpactMarketCouncil",name:"",type:"address"}],stateMutability:"view",type:"function"},"isAmbassadorOrEntityOfCommunity(address,address)":{inputs:[{internalType:"address",name:"_community",type:"address"},{internalType:"address",name:"_ambassadorOrEntity",type:"address"}],name:"isAmbassadorOrEntityOfCommunity",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"migrateCommunity(address[],address)":{inputs:[{internalType:"address[]",name:"_managers",type:"address[]"},{internalType:"contract ICommunity",name:"_previousCommunity",type:"address"}],name:"migrateCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"minClaimAmountRatio()":{inputs:[],name:"minClaimAmountRatio",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minClaimAmountRatioPrecision()":{inputs:[],name:"minClaimAmountRatioPrecision",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"removeCommunity(address)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"}],name:"removeCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"setCommunityToAmbassador(address,address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"},{internalType:"contract ICommunity",name:"_communityAddress",type:"address"}],name:"setCommunityToAmbassador",outputs:[],stateMutability:"nonpayable",type:"function"},"splitCommunity(address,uint256,address,address[])":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_numberOfCopies",type:"uint256"},{internalType:"address",name:"_ambassador",type:"address"},{internalType:"address[]",name:"_managers",type:"address[]"}],name:"splitCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"transferFromCommunity(address,address,address,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transferFromCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"contract ITreasury",name:"",type:"address"}],stateMutability:"view",type:"function"},"treasuryMinBalance()":{inputs:[],name:"treasuryMinBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"treasurySafetyPercentage()":{inputs:[],name:"treasurySafetyPercentage",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"updateAmbassadors(address)":{inputs:[{internalType:"contract IAmbassadors",name:"_newAmbassadors",type:"address"}],name:"updateAmbassadors",outputs:[],stateMutability:"nonpayable",type:"function"},"updateAuthorizedWalletAddress(address)":{inputs:[{internalType:"address",name:"_newSignerAddress",type:"address"}],name:"updateAuthorizedWalletAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"updateBeneficiaryParams(address,uint256,uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"},{internalType:"uint256",name:"_maxBeneficiaries",type:"uint256"}],name:"updateBeneficiaryParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityImplementation(address)":{inputs:[{internalType:"contract ICommunity",name:"_communityImplementation_",type:"address"}],name:"updateCommunityImplementation",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityMiddleProxy(address)":{inputs:[{internalType:"address",name:"_communityMiddleProxy",type:"address"}],name:"updateCommunityMiddleProxy",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityParams(address,uint256,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"}],name:"updateCommunityParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityToken(address,address,address[],uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"contract IERC20Upgradeable",name:"_newToken",type:"address"},{internalType:"address[]",name:"_exchangePath",type:"address[]"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"}],name:"updateCommunityToken",outputs:[],stateMutability:"nonpayable",type:"function"},"updateImpactMarketCouncil(address)":{inputs:[{internalType:"contract IImpactMarketCouncil",name:"_newImpactMarketCouncil",type:"address"}],name:"updateImpactMarketCouncil",outputs:[],stateMutability:"nonpayable",type:"function"},"updateMinClaimAmountRatio(uint256)":{inputs:[{internalType:"uint256",name:"_newMinClaimAmountRatio",type:"uint256"}],name:"updateMinClaimAmountRatio",outputs:[],stateMutability:"nonpayable",type:"function"},"updateProxyImplementation(address,address)":{inputs:[{internalType:"address",name:"_communityMiddleProxy",type:"address"},{internalType:"address",name:"_newLogic",type:"address"}],name:"updateProxyImplementation",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasury(address)":{inputs:[{internalType:"contract ITreasury",name:"_newTreasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasuryMinBalance(uint256)":{inputs:[{internalType:"uint256",name:"_newTreasuryMinBalance",type:"uint256"}],name:"updateTreasuryMinBalance",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasurySafetyPercentage(uint256)":{inputs:[{internalType:"uint256",name:"_newTreasurySafetyPercentage",type:"uint256"}],name:"updateTreasurySafetyPercentage",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/community/interfaces/CommunityAdminStorageV3.sol:CommunityAdminStorageV3":{source:"contracts/community/interfaces/CommunityAdminStorageV3.sol",name:"CommunityAdminStorageV3",title:"Storage for CommunityAdmin",notice:"For future upgrades, do not change CommunityAdminStorageV2. Create a new contract which implements CommunityAdminStorageV2 and following the naming convention CommunityAdminStorageVX.",methods:{"addCommunity(address,address[],address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"address[]",name:"_managers",type:"address[]"},{internalType:"address",name:"_ambassador",type:"address"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"},{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"},{internalType:"uint256",name:"_maxBeneficiaries",type:"uint256"}],name:"addCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"ambassadors()":{inputs:[],name:"ambassadors",outputs:[{internalType:"contract IAmbassadors",name:"",type:"address"}],stateMutability:"view",type:"function"},"authorizedWalletAddress()":{inputs:[],name:"authorizedWalletAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"calculateCommunityTrancheAmount(address)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"}],name:"calculateCommunityTrancheAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"communities(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"communities",outputs:[{internalType:"enum ICommunityAdmin.CommunityState",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"communityImplementation()":{inputs:[],name:"communityImplementation",outputs:[{internalType:"contract ICommunity",name:"",type:"address"}],stateMutability:"view",type:"function"},"communityListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"communityListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"communityListLength()":{inputs:[],name:"communityListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"communityMiddleProxy()":{inputs:[],name:"communityMiddleProxy",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"communityProxyAdmin()":{inputs:[],name:"communityProxyAdmin",outputs:[{internalType:"contract ProxyAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"fundCommunity()":{inputs:[],name:"fundCommunity",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"getCommunityProxyImplementation(address)":{inputs:[{internalType:"address",name:"_communityProxyAddress",type:"address"}],name:"getCommunityProxyImplementation",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"impactMarketCouncil()":{inputs:[],name:"impactMarketCouncil",outputs:[{internalType:"contract IImpactMarketCouncil",name:"",type:"address"}],stateMutability:"view",type:"function"},"isAmbassadorOrEntityOfCommunity(address,address)":{inputs:[{internalType:"address",name:"_community",type:"address"},{internalType:"address",name:"_ambassadorOrEntity",type:"address"}],name:"isAmbassadorOrEntityOfCommunity",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"migrateCommunity(address[],address)":{inputs:[{internalType:"address[]",name:"_managers",type:"address[]"},{internalType:"contract ICommunity",name:"_previousCommunity",type:"address"}],name:"migrateCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"minClaimAmountRatio()":{inputs:[],name:"minClaimAmountRatio",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minClaimAmountRatioPrecision()":{inputs:[],name:"minClaimAmountRatioPrecision",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"removeCommunity(address)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"}],name:"removeCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"setCommunityToAmbassador(address,address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"},{internalType:"contract ICommunity",name:"_communityAddress",type:"address"}],name:"setCommunityToAmbassador",outputs:[],stateMutability:"nonpayable",type:"function"},"splitCommunity(address,uint256,address,address[])":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_numberOfCopies",type:"uint256"},{internalType:"address",name:"_ambassador",type:"address"},{internalType:"address[]",name:"_managers",type:"address[]"}],name:"splitCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"transferFromCommunity(address,address,address,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transferFromCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"contract ITreasury",name:"",type:"address"}],stateMutability:"view",type:"function"},"treasuryMinBalance()":{inputs:[],name:"treasuryMinBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"treasurySafetyPercentage()":{inputs:[],name:"treasurySafetyPercentage",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"updateAmbassadors(address)":{inputs:[{internalType:"contract IAmbassadors",name:"_newAmbassadors",type:"address"}],name:"updateAmbassadors",outputs:[],stateMutability:"nonpayable",type:"function"},"updateAuthorizedWalletAddress(address)":{inputs:[{internalType:"address",name:"_newSignerAddress",type:"address"}],name:"updateAuthorizedWalletAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"updateBeneficiaryParams(address,uint256,uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"},{internalType:"uint256",name:"_maxBeneficiaries",type:"uint256"}],name:"updateBeneficiaryParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityImplementation(address)":{inputs:[{internalType:"contract ICommunity",name:"_communityImplementation_",type:"address"}],name:"updateCommunityImplementation",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityMiddleProxy(address)":{inputs:[{internalType:"address",name:"_communityMiddleProxy",type:"address"}],name:"updateCommunityMiddleProxy",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityParams(address,uint256,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"}],name:"updateCommunityParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityToken(address,address,address[],uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"contract IERC20Upgradeable",name:"_newToken",type:"address"},{internalType:"address[]",name:"_exchangePath",type:"address[]"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"}],name:"updateCommunityToken",outputs:[],stateMutability:"nonpayable",type:"function"},"updateImpactMarketCouncil(address)":{inputs:[{internalType:"contract IImpactMarketCouncil",name:"_newImpactMarketCouncil",type:"address"}],name:"updateImpactMarketCouncil",outputs:[],stateMutability:"nonpayable",type:"function"},"updateMinClaimAmountRatio(uint256)":{inputs:[{internalType:"uint256",name:"_newMinClaimAmountRatio",type:"uint256"}],name:"updateMinClaimAmountRatio",outputs:[],stateMutability:"nonpayable",type:"function"},"updateProxyImplementation(address,address)":{inputs:[{internalType:"address",name:"_communityMiddleProxy",type:"address"},{internalType:"address",name:"_newLogic",type:"address"}],name:"updateProxyImplementation",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasury(address)":{inputs:[{internalType:"contract ITreasury",name:"_newTreasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasuryMinBalance(uint256)":{inputs:[{internalType:"uint256",name:"_newTreasuryMinBalance",type:"uint256"}],name:"updateTreasuryMinBalance",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasurySafetyPercentage(uint256)":{inputs:[{internalType:"uint256",name:"_newTreasurySafetyPercentage",type:"uint256"}],name:"updateTreasurySafetyPercentage",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/community/interfaces/CommunityStorageV1.sol:CommunityStorageV1":{source:"contracts/community/interfaces/CommunityStorageV1.sol",name:"CommunityStorageV1",title:"Storage for Community",notice:"For future upgrades, do not change CommunityStorageV1. Create a new contract which implements CommunityStorageV1 and following the naming convention CommunityStorageVX.",methods:{"addBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"addBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"addBeneficiariesUsingSignature(address[],uint256,bytes)":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"},{internalType:"uint256",name:"_expirationTimestamp",type:"uint256"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"addBeneficiariesUsingSignature",outputs:[],stateMutability:"nonpayable",type:"function"},"addBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"addBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"addCopy(address)":{inputs:[{internalType:"contract ICommunity",name:"_copy",type:"address"}],name:"addCopy",outputs:[],stateMutability:"nonpayable",type:"function"},"addManager(address)":{inputs:[{internalType:"address",name:"_managerAddress",type:"address"}],name:"addManager",outputs:[],stateMutability:"nonpayable",type:"function"},"addTreasuryFunds(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"addTreasuryFunds",outputs:[],stateMutability:"nonpayable",type:"function"},"baseInterval()":{inputs:[],name:"baseInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"beneficiaries(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"beneficiaries",outputs:[{internalType:"enum ICommunity.BeneficiaryState",name:"state",type:"uint8"},{internalType:"uint256",name:"claims",type:"uint256"},{internalType:"uint256",name:"claimedAmount",type:"uint256"},{internalType:"uint256",name:"lastClaim",type:"uint256"}],stateMutability:"view",type:"function"},"beneficiaryClaimedAmounts(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"beneficiaryClaimedAmounts",outputs:[{internalType:"uint256[]",name:"claimedAmounts",type:"uint256[]"}],stateMutability:"view",type:"function"},"beneficiaryJoinFromMigrated(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"beneficiaryJoinFromMigrated",outputs:[],stateMutability:"nonpayable",type:"function"},"beneficiaryListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"beneficiaryListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"beneficiaryListLength()":{inputs:[],name:"beneficiaryListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"changeBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"_newBeneficiaryAddress",type:"address"}],name:"changeBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"changeBeneficiaryAddressByManager(address,address)":{inputs:[{internalType:"address",name:"_oldBeneficiaryAddress",type:"address"},{internalType:"address",name:"_newBeneficiaryAddress",type:"address"}],name:"changeBeneficiaryAddressByManager",outputs:[],stateMutability:"nonpayable",type:"function"},"claim()":{inputs:[],name:"claim",outputs:[],stateMutability:"nonpayable",type:"function"},"claimAmount()":{inputs:[],name:"claimAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimCooldown(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"claimCooldown",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"communityAdmin()":{inputs:[],name:"communityAdmin",outputs:[{internalType:"contract ICommunityAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"copies()":{inputs:[],name:"copies",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function"},"copyBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"copyBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"copyCommunityDetails(address)":{inputs:[{internalType:"contract ICommunity",name:"_originalCommunity",type:"address"}],name:"copyCommunityDetails",outputs:[],stateMutability:"nonpayable",type:"function"},"copyOf()":{inputs:[],name:"copyOf",outputs:[{internalType:"contract ICommunity",name:"",type:"address"}],stateMutability:"view",type:"function"},"decreaseStep()":{inputs:[],name:"decreaseStep",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donate(address,uint256)":{inputs:[{internalType:"address",name:"_sender",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"donate",outputs:[],stateMutability:"nonpayable",type:"function"},"getInitialMaxClaim()":{inputs:[],name:"getInitialMaxClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"impactMarketAddress()":{inputs:[],name:"impactMarketAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"},"incrementInterval()":{inputs:[],name:"incrementInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"initialize(address,address[],uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"address[]",name:"_managers",type:"address[]"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"},{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"},{internalType:"uint256",name:"_maxBeneficiaries",type:"uint256"},{internalType:"contract ICommunity",name:"_previousCommunity",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function"},"isSelfFunding()":{inputs:[],name:"isSelfFunding",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"lastFundRequest()":{inputs:[],name:"lastFundRequest",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lastInterval(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"lastInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lock()":{inputs:[],name:"lock",outputs:[],stateMutability:"nonpayable",type:"function"},"lockBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"lockBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"lockBeneficiariesUsingSignature(address[],uint256,bytes)":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"},{internalType:"uint256",name:"_expirationTimestamp",type:"uint256"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"lockBeneficiariesUsingSignature",outputs:[],stateMutability:"nonpayable",type:"function"},"lockBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"lockBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"locked()":{inputs:[],name:"locked",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"maxBeneficiaries()":{inputs:[],name:"maxBeneficiaries",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"maxClaim()":{inputs:[],name:"maxClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"maxTotalClaim()":{inputs:[],name:"maxTotalClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"maxTranche()":{inputs:[],name:"maxTranche",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minTranche()":{inputs:[],name:"minTranche",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"originalClaimAmount()":{inputs:[],name:"originalClaimAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"previousCommunity()":{inputs:[],name:"previousCommunity",outputs:[{internalType:"contract ICommunity",name:"",type:"address"}],stateMutability:"view",type:"function"},"privateFunds()":{inputs:[],name:"privateFunds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"removeBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"removeBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"removeBeneficiariesUsingSignature(address[],uint256,bytes)":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"},{internalType:"uint256",name:"_expirationTimestamp",type:"uint256"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"removeBeneficiariesUsingSignature",outputs:[],stateMutability:"nonpayable",type:"function"},"removeBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"removeBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"removeManager(address)":{inputs:[{internalType:"address",name:"_managerAddress",type:"address"}],name:"removeManager",outputs:[],stateMutability:"nonpayable",type:"function"},"requestFunds()":{inputs:[],name:"requestFunds",outputs:[],stateMutability:"nonpayable",type:"function"},"setBeneficiaryState(address,uint8)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"},{internalType:"enum ICommunity.BeneficiaryState",name:"_state",type:"uint8"}],name:"setBeneficiaryState",outputs:[],stateMutability:"nonpayable",type:"function"},"token()":{inputs:[],name:"token",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"tokenList()":{inputs:[],name:"tokenList",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function"},"tokenUpdates(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"tokenUpdates",outputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"ratio",type:"uint256"},{internalType:"uint256",name:"startBlock",type:"uint256"}],stateMutability:"view",type:"function"},"tokenUpdatesLength()":{inputs:[],name:"tokenUpdatesLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"treasuryFunds()":{inputs:[],name:"treasuryFunds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"unlock()":{inputs:[],name:"unlock",outputs:[],stateMutability:"nonpayable",type:"function"},"unlockBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"unlockBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"unlockBeneficiariesUsingSignature(address[],uint256,bytes)":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"},{internalType:"uint256",name:"_expirationTimestamp",type:"uint256"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"unlockBeneficiariesUsingSignature",outputs:[],stateMutability:"nonpayable",type:"function"},"unlockBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"unlockBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"updateBeneficiaryParams(uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"}],name:"updateBeneficiaryParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityAdmin(address)":{inputs:[{internalType:"contract ICommunityAdmin",name:"_communityAdmin",type:"address"}],name:"updateCommunityAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityParams(uint256,uint256)":{inputs:[{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"}],name:"updateCommunityParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateMaxBeneficiaries(uint256)":{inputs:[{internalType:"uint256",name:"_newMaxBeneficiaries",type:"uint256"}],name:"updateMaxBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"updatePreviousCommunity(address)":{inputs:[{internalType:"contract ICommunity",name:"_newPreviousCommunity",type:"address"}],name:"updatePreviousCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"updateToken(address,address[],uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_newToken",type:"address"},{internalType:"address[]",name:"_exchangePath",type:"address[]"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"}],name:"updateToken",outputs:[],stateMutability:"nonpayable",type:"function"},"validBeneficiaryCount()":{inputs:[],name:"validBeneficiaryCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/community/interfaces/CommunityStorageV2.sol:CommunityStorageV2":{source:"contracts/community/interfaces/CommunityStorageV2.sol",name:"CommunityStorageV2",title:"Storage for Community",notice:"For future upgrades, do not change CommunityStorageV2. Create a new contract which implements CommunityStorageV2 and following the naming convention CommunityStorageVX.",methods:{"_token()":{inputs:[],name:"_token",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"addBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"addBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"addBeneficiariesUsingSignature(address[],uint256,bytes)":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"},{internalType:"uint256",name:"_expirationTimestamp",type:"uint256"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"addBeneficiariesUsingSignature",outputs:[],stateMutability:"nonpayable",type:"function"},"addBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"addBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"addCopy(address)":{inputs:[{internalType:"contract ICommunity",name:"_copy",type:"address"}],name:"addCopy",outputs:[],stateMutability:"nonpayable",type:"function"},"addManager(address)":{inputs:[{internalType:"address",name:"_managerAddress",type:"address"}],name:"addManager",outputs:[],stateMutability:"nonpayable",type:"function"},"addTreasuryFunds(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"addTreasuryFunds",outputs:[],stateMutability:"nonpayable",type:"function"},"baseInterval()":{inputs:[],name:"baseInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"beneficiaries(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"beneficiaries",outputs:[{internalType:"enum ICommunity.BeneficiaryState",name:"state",type:"uint8"},{internalType:"uint256",name:"claims",type:"uint256"},{internalType:"uint256",name:"claimedAmount",type:"uint256"},{internalType:"uint256",name:"lastClaim",type:"uint256"}],stateMutability:"view",type:"function"},"beneficiaryClaimedAmounts(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"beneficiaryClaimedAmounts",outputs:[{internalType:"uint256[]",name:"claimedAmounts",type:"uint256[]"}],stateMutability:"view",type:"function"},"beneficiaryJoinFromMigrated(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"beneficiaryJoinFromMigrated",outputs:[],stateMutability:"nonpayable",type:"function"},"beneficiaryListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"beneficiaryListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"beneficiaryListLength()":{inputs:[],name:"beneficiaryListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"changeBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"_newBeneficiaryAddress",type:"address"}],name:"changeBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"changeBeneficiaryAddressByManager(address,address)":{inputs:[{internalType:"address",name:"_oldBeneficiaryAddress",type:"address"},{internalType:"address",name:"_newBeneficiaryAddress",type:"address"}],name:"changeBeneficiaryAddressByManager",outputs:[],stateMutability:"nonpayable",type:"function"},"claim()":{inputs:[],name:"claim",outputs:[],stateMutability:"nonpayable",type:"function"},"claimAmount()":{inputs:[],name:"claimAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimCooldown(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"claimCooldown",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"communityAdmin()":{inputs:[],name:"communityAdmin",outputs:[{internalType:"contract ICommunityAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"copies()":{inputs:[],name:"copies",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function"},"copyBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"copyBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"copyCommunityDetails(address)":{inputs:[{internalType:"contract ICommunity",name:"_originalCommunity",type:"address"}],name:"copyCommunityDetails",outputs:[],stateMutability:"nonpayable",type:"function"},"copyOf()":{inputs:[],name:"copyOf",outputs:[{internalType:"contract ICommunity",name:"",type:"address"}],stateMutability:"view",type:"function"},"decreaseStep()":{inputs:[],name:"decreaseStep",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donate(address,uint256)":{inputs:[{internalType:"address",name:"_sender",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"donate",outputs:[],stateMutability:"nonpayable",type:"function"},"getInitialMaxClaim()":{inputs:[],name:"getInitialMaxClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"impactMarketAddress()":{inputs:[],name:"impactMarketAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"},"incrementInterval()":{inputs:[],name:"incrementInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"initialize(address,address[],uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"address[]",name:"_managers",type:"address[]"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"},{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"},{internalType:"uint256",name:"_maxBeneficiaries",type:"uint256"},{internalType:"contract ICommunity",name:"_previousCommunity",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function"},"isSelfFunding()":{inputs:[],name:"isSelfFunding",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"lastFundRequest()":{inputs:[],name:"lastFundRequest",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lastInterval(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"lastInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lock()":{inputs:[],name:"lock",outputs:[],stateMutability:"nonpayable",type:"function"},"lockBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"lockBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"lockBeneficiariesUsingSignature(address[],uint256,bytes)":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"},{internalType:"uint256",name:"_expirationTimestamp",type:"uint256"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"lockBeneficiariesUsingSignature",outputs:[],stateMutability:"nonpayable",type:"function"},"lockBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"lockBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"locked()":{inputs:[],name:"locked",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"maxBeneficiaries()":{inputs:[],name:"maxBeneficiaries",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"maxClaim()":{inputs:[],name:"maxClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"maxTotalClaim()":{inputs:[],name:"maxTotalClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"maxTranche()":{inputs:[],name:"maxTranche",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minTranche()":{inputs:[],name:"minTranche",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"originalClaimAmount()":{inputs:[],name:"originalClaimAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"previousCommunity()":{inputs:[],name:"previousCommunity",outputs:[{internalType:"contract ICommunity",name:"",type:"address"}],stateMutability:"view",type:"function"},"privateFunds()":{inputs:[],name:"privateFunds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"removeBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"removeBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"removeBeneficiariesUsingSignature(address[],uint256,bytes)":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"},{internalType:"uint256",name:"_expirationTimestamp",type:"uint256"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"removeBeneficiariesUsingSignature",outputs:[],stateMutability:"nonpayable",type:"function"},"removeBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"removeBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"removeManager(address)":{inputs:[{internalType:"address",name:"_managerAddress",type:"address"}],name:"removeManager",outputs:[],stateMutability:"nonpayable",type:"function"},"requestFunds()":{inputs:[],name:"requestFunds",outputs:[],stateMutability:"nonpayable",type:"function"},"setBeneficiaryState(address,uint8)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"},{internalType:"enum ICommunity.BeneficiaryState",name:"_state",type:"uint8"}],name:"setBeneficiaryState",outputs:[],stateMutability:"nonpayable",type:"function"},"token()":{inputs:[],name:"token",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"tokenList()":{inputs:[],name:"tokenList",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function"},"tokenUpdates(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"tokenUpdates",outputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"ratio",type:"uint256"},{internalType:"uint256",name:"startBlock",type:"uint256"}],stateMutability:"view",type:"function"},"tokenUpdatesLength()":{inputs:[],name:"tokenUpdatesLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"treasuryFunds()":{inputs:[],name:"treasuryFunds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"unlock()":{inputs:[],name:"unlock",outputs:[],stateMutability:"nonpayable",type:"function"},"unlockBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"unlockBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"unlockBeneficiariesUsingSignature(address[],uint256,bytes)":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"},{internalType:"uint256",name:"_expirationTimestamp",type:"uint256"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"unlockBeneficiariesUsingSignature",outputs:[],stateMutability:"nonpayable",type:"function"},"unlockBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"unlockBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"updateBeneficiaryParams(uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"}],name:"updateBeneficiaryParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityAdmin(address)":{inputs:[{internalType:"contract ICommunityAdmin",name:"_communityAdmin",type:"address"}],name:"updateCommunityAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityParams(uint256,uint256)":{inputs:[{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"}],name:"updateCommunityParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateMaxBeneficiaries(uint256)":{inputs:[{internalType:"uint256",name:"_newMaxBeneficiaries",type:"uint256"}],name:"updateMaxBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"updatePreviousCommunity(address)":{inputs:[{internalType:"contract ICommunity",name:"_newPreviousCommunity",type:"address"}],name:"updatePreviousCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"updateToken(address,address[],uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_newToken",type:"address"},{internalType:"address[]",name:"_exchangePath",type:"address[]"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"}],name:"updateToken",outputs:[],stateMutability:"nonpayable",type:"function"},"validBeneficiaryCount()":{inputs:[],name:"validBeneficiaryCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/community/interfaces/CommunityStorageV3.sol:CommunityStorageV3":{source:"contracts/community/interfaces/CommunityStorageV3.sol",name:"CommunityStorageV3",title:"Storage for Community",notice:"For future upgrades, do not change CommunityStorageV3. Create a new contract which implements CommunityStorageV3 and following the naming convention CommunityStorageVX.",methods:{"_token()":{inputs:[],name:"_token",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"addBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"addBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"addBeneficiariesUsingSignature(address[],uint256,bytes)":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"},{internalType:"uint256",name:"_expirationTimestamp",type:"uint256"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"addBeneficiariesUsingSignature",outputs:[],stateMutability:"nonpayable",type:"function"},"addBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"addBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"addCopy(address)":{inputs:[{internalType:"contract ICommunity",name:"_copy",type:"address"}],name:"addCopy",outputs:[],stateMutability:"nonpayable",type:"function"},"addManager(address)":{inputs:[{internalType:"address",name:"_managerAddress",type:"address"}],name:"addManager",outputs:[],stateMutability:"nonpayable",type:"function"},"addTreasuryFunds(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"addTreasuryFunds",outputs:[],stateMutability:"nonpayable",type:"function"},"baseInterval()":{inputs:[],name:"baseInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"beneficiaries(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"beneficiaries",outputs:[{internalType:"enum ICommunity.BeneficiaryState",name:"state",type:"uint8"},{internalType:"uint256",name:"claims",type:"uint256"},{internalType:"uint256",name:"claimedAmount",type:"uint256"},{internalType:"uint256",name:"lastClaim",type:"uint256"}],stateMutability:"view",type:"function"},"beneficiaryClaimedAmounts(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"beneficiaryClaimedAmounts",outputs:[{internalType:"uint256[]",name:"claimedAmounts",type:"uint256[]"}],stateMutability:"view",type:"function"},"beneficiaryJoinFromMigrated(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"beneficiaryJoinFromMigrated",outputs:[],stateMutability:"nonpayable",type:"function"},"beneficiaryListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"beneficiaryListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"beneficiaryListLength()":{inputs:[],name:"beneficiaryListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"changeBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"_newBeneficiaryAddress",type:"address"}],name:"changeBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"changeBeneficiaryAddressByManager(address,address)":{inputs:[{internalType:"address",name:"_oldBeneficiaryAddress",type:"address"},{internalType:"address",name:"_newBeneficiaryAddress",type:"address"}],name:"changeBeneficiaryAddressByManager",outputs:[],stateMutability:"nonpayable",type:"function"},"claim()":{inputs:[],name:"claim",outputs:[],stateMutability:"nonpayable",type:"function"},"claimAmount()":{inputs:[],name:"claimAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimCooldown(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"claimCooldown",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"communityAdmin()":{inputs:[],name:"communityAdmin",outputs:[{internalType:"contract ICommunityAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"copies()":{inputs:[],name:"copies",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function"},"copyBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"copyBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"copyCommunityDetails(address)":{inputs:[{internalType:"contract ICommunity",name:"_originalCommunity",type:"address"}],name:"copyCommunityDetails",outputs:[],stateMutability:"nonpayable",type:"function"},"copyOf()":{inputs:[],name:"copyOf",outputs:[{internalType:"contract ICommunity",name:"",type:"address"}],stateMutability:"view",type:"function"},"decreaseStep()":{inputs:[],name:"decreaseStep",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donate(address,uint256)":{inputs:[{internalType:"address",name:"_sender",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"donate",outputs:[],stateMutability:"nonpayable",type:"function"},"getInitialMaxClaim()":{inputs:[],name:"getInitialMaxClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"impactMarketAddress()":{inputs:[],name:"impactMarketAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"},"incrementInterval()":{inputs:[],name:"incrementInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"initialize(address,address[],uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"address[]",name:"_managers",type:"address[]"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"},{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"},{internalType:"uint256",name:"_maxBeneficiaries",type:"uint256"},{internalType:"contract ICommunity",name:"_previousCommunity",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function"},"isSelfFunding()":{inputs:[],name:"isSelfFunding",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"lastFundRequest()":{inputs:[],name:"lastFundRequest",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lastInterval(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"lastInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lock()":{inputs:[],name:"lock",outputs:[],stateMutability:"nonpayable",type:"function"},"lockBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"lockBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"lockBeneficiariesUsingSignature(address[],uint256,bytes)":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"},{internalType:"uint256",name:"_expirationTimestamp",type:"uint256"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"lockBeneficiariesUsingSignature",outputs:[],stateMutability:"nonpayable",type:"function"},"lockBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"lockBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"locked()":{inputs:[],name:"locked",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"maxBeneficiaries()":{inputs:[],name:"maxBeneficiaries",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"maxClaim()":{inputs:[],name:"maxClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"maxTotalClaim()":{inputs:[],name:"maxTotalClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"maxTranche()":{inputs:[],name:"maxTranche",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minTranche()":{inputs:[],name:"minTranche",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"originalClaimAmount()":{inputs:[],name:"originalClaimAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"previousCommunity()":{inputs:[],name:"previousCommunity",outputs:[{internalType:"contract ICommunity",name:"",type:"address"}],stateMutability:"view",type:"function"},"privateFunds()":{inputs:[],name:"privateFunds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"removeBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"removeBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"removeBeneficiariesUsingSignature(address[],uint256,bytes)":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"},{internalType:"uint256",name:"_expirationTimestamp",type:"uint256"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"removeBeneficiariesUsingSignature",outputs:[],stateMutability:"nonpayable",type:"function"},"removeBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"removeBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"removeManager(address)":{inputs:[{internalType:"address",name:"_managerAddress",type:"address"}],name:"removeManager",outputs:[],stateMutability:"nonpayable",type:"function"},"requestFunds()":{inputs:[],name:"requestFunds",outputs:[],stateMutability:"nonpayable",type:"function"},"setBeneficiaryState(address,uint8)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"},{internalType:"enum ICommunity.BeneficiaryState",name:"_state",type:"uint8"}],name:"setBeneficiaryState",outputs:[],stateMutability:"nonpayable",type:"function"},"token()":{inputs:[],name:"token",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"tokenList()":{inputs:[],name:"tokenList",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function"},"tokenUpdates(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tokenUpdates",outputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"ratio",type:"uint256"},{internalType:"uint256",name:"startBlock",type:"uint256"}],stateMutability:"view",type:"function"},"tokenUpdatesLength()":{inputs:[],name:"tokenUpdatesLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"treasuryFunds()":{inputs:[],name:"treasuryFunds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"unlock()":{inputs:[],name:"unlock",outputs:[],stateMutability:"nonpayable",type:"function"},"unlockBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"unlockBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"unlockBeneficiariesUsingSignature(address[],uint256,bytes)":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"},{internalType:"uint256",name:"_expirationTimestamp",type:"uint256"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"unlockBeneficiariesUsingSignature",outputs:[],stateMutability:"nonpayable",type:"function"},"unlockBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"unlockBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"updateBeneficiaryParams(uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"}],name:"updateBeneficiaryParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityAdmin(address)":{inputs:[{internalType:"contract ICommunityAdmin",name:"_communityAdmin",type:"address"}],name:"updateCommunityAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityParams(uint256,uint256)":{inputs:[{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"}],name:"updateCommunityParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateMaxBeneficiaries(uint256)":{inputs:[{internalType:"uint256",name:"_newMaxBeneficiaries",type:"uint256"}],name:"updateMaxBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"updatePreviousCommunity(address)":{inputs:[{internalType:"contract ICommunity",name:"_newPreviousCommunity",type:"address"}],name:"updatePreviousCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"updateToken(address,address[],uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_newToken",type:"address"},{internalType:"address[]",name:"_exchangePath",type:"address[]"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"}],name:"updateToken",outputs:[],stateMutability:"nonpayable",type:"function"},"validBeneficiaryCount()":{inputs:[],name:"validBeneficiaryCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/community/interfaces/CommunityStorageV4.sol:CommunityStorageV4":{source:"contracts/community/interfaces/CommunityStorageV4.sol",name:"CommunityStorageV4",title:"Storage for Community",notice:"For future upgrades, do not change CommunityStorageV4. Create a new contract which implements CommunityStorageV4 and following the naming convention CommunityStorageVX.",methods:{"_token()":{inputs:[],name:"_token",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"addBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"addBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"addBeneficiariesUsingSignature(address[],uint256,bytes)":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"},{internalType:"uint256",name:"_expirationTimestamp",type:"uint256"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"addBeneficiariesUsingSignature",outputs:[],stateMutability:"nonpayable",type:"function"},"addBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"addBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"addCopy(address)":{inputs:[{internalType:"contract ICommunity",name:"_copy",type:"address"}],name:"addCopy",outputs:[],stateMutability:"nonpayable",type:"function"},"addManager(address)":{inputs:[{internalType:"address",name:"_managerAddress",type:"address"}],name:"addManager",outputs:[],stateMutability:"nonpayable",type:"function"},"addTreasuryFunds(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"addTreasuryFunds",outputs:[],stateMutability:"nonpayable",type:"function"},"baseInterval()":{inputs:[],name:"baseInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"beneficiaries(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"beneficiaries",outputs:[{internalType:"enum ICommunity.BeneficiaryState",name:"state",type:"uint8"},{internalType:"uint256",name:"claims",type:"uint256"},{internalType:"uint256",name:"claimedAmount",type:"uint256"},{internalType:"uint256",name:"lastClaim",type:"uint256"}],stateMutability:"view",type:"function"},"beneficiaryClaimedAmounts(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"beneficiaryClaimedAmounts",outputs:[{internalType:"uint256[]",name:"claimedAmounts",type:"uint256[]"}],stateMutability:"view",type:"function"},"beneficiaryJoinFromMigrated(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"beneficiaryJoinFromMigrated",outputs:[],stateMutability:"nonpayable",type:"function"},"beneficiaryListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"beneficiaryListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"beneficiaryListLength()":{inputs:[],name:"beneficiaryListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"changeBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"_newBeneficiaryAddress",type:"address"}],name:"changeBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"changeBeneficiaryAddressByManager(address,address)":{inputs:[{internalType:"address",name:"_oldBeneficiaryAddress",type:"address"},{internalType:"address",name:"_newBeneficiaryAddress",type:"address"}],name:"changeBeneficiaryAddressByManager",outputs:[],stateMutability:"nonpayable",type:"function"},"claim()":{inputs:[],name:"claim",outputs:[],stateMutability:"nonpayable",type:"function"},"claimAmount()":{inputs:[],name:"claimAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimCooldown(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"claimCooldown",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"communityAdmin()":{inputs:[],name:"communityAdmin",outputs:[{internalType:"contract ICommunityAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"copies()":{inputs:[],name:"copies",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function"},"copyBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"copyBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"copyCommunityDetails(address)":{inputs:[{internalType:"contract ICommunity",name:"_originalCommunity",type:"address"}],name:"copyCommunityDetails",outputs:[],stateMutability:"nonpayable",type:"function"},"copyOf()":{inputs:[],name:"copyOf",outputs:[{internalType:"contract ICommunity",name:"",type:"address"}],stateMutability:"view",type:"function"},"decreaseStep()":{inputs:[],name:"decreaseStep",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donate(address,uint256)":{inputs:[{internalType:"address",name:"_sender",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"donate",outputs:[],stateMutability:"nonpayable",type:"function"},"getInitialMaxClaim()":{inputs:[],name:"getInitialMaxClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"impactMarketAddress()":{inputs:[],name:"impactMarketAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"},"incrementInterval()":{inputs:[],name:"incrementInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"initialize(address,address[],uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"address[]",name:"_managers",type:"address[]"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"},{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"},{internalType:"uint256",name:"_maxBeneficiaries",type:"uint256"},{internalType:"contract ICommunity",name:"_previousCommunity",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function"},"isSelfFunding()":{inputs:[],name:"isSelfFunding",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"lastFundRequest()":{inputs:[],name:"lastFundRequest",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lastInterval(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"lastInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lock()":{inputs:[],name:"lock",outputs:[],stateMutability:"nonpayable",type:"function"},"lockBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"lockBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"lockBeneficiariesUsingSignature(address[],uint256,bytes)":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"},{internalType:"uint256",name:"_expirationTimestamp",type:"uint256"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"lockBeneficiariesUsingSignature",outputs:[],stateMutability:"nonpayable",type:"function"},"lockBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"lockBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"locked()":{inputs:[],name:"locked",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"maxBeneficiaries()":{inputs:[],name:"maxBeneficiaries",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"maxClaim()":{inputs:[],name:"maxClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"maxTotalClaim()":{inputs:[],name:"maxTotalClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"maxTranche()":{inputs:[],name:"maxTranche",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minTranche()":{inputs:[],name:"minTranche",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"originalClaimAmount()":{inputs:[],name:"originalClaimAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"previousCommunity()":{inputs:[],name:"previousCommunity",outputs:[{internalType:"contract ICommunity",name:"",type:"address"}],stateMutability:"view",type:"function"},"privateFunds()":{inputs:[],name:"privateFunds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"removeBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"removeBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"removeBeneficiariesUsingSignature(address[],uint256,bytes)":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"},{internalType:"uint256",name:"_expirationTimestamp",type:"uint256"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"removeBeneficiariesUsingSignature",outputs:[],stateMutability:"nonpayable",type:"function"},"removeBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"removeBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"removeManager(address)":{inputs:[{internalType:"address",name:"_managerAddress",type:"address"}],name:"removeManager",outputs:[],stateMutability:"nonpayable",type:"function"},"requestFunds()":{inputs:[],name:"requestFunds",outputs:[],stateMutability:"nonpayable",type:"function"},"setBeneficiaryState(address,uint8)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"},{internalType:"enum ICommunity.BeneficiaryState",name:"_state",type:"uint8"}],name:"setBeneficiaryState",outputs:[],stateMutability:"nonpayable",type:"function"},"token()":{inputs:[],name:"token",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"tokenList()":{inputs:[],name:"tokenList",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function"},"tokenUpdates(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tokenUpdates",outputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"ratio",type:"uint256"},{internalType:"uint256",name:"startBlock",type:"uint256"}],stateMutability:"view",type:"function"},"tokenUpdatesLength()":{inputs:[],name:"tokenUpdatesLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"treasuryFunds()":{inputs:[],name:"treasuryFunds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"unlock()":{inputs:[],name:"unlock",outputs:[],stateMutability:"nonpayable",type:"function"},"unlockBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"unlockBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"unlockBeneficiariesUsingSignature(address[],uint256,bytes)":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"},{internalType:"uint256",name:"_expirationTimestamp",type:"uint256"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"unlockBeneficiariesUsingSignature",outputs:[],stateMutability:"nonpayable",type:"function"},"unlockBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"unlockBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"updateBeneficiaryParams(uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"}],name:"updateBeneficiaryParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityAdmin(address)":{inputs:[{internalType:"contract ICommunityAdmin",name:"_communityAdmin",type:"address"}],name:"updateCommunityAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityParams(uint256,uint256)":{inputs:[{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"}],name:"updateCommunityParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateMaxBeneficiaries(uint256)":{inputs:[{internalType:"uint256",name:"_newMaxBeneficiaries",type:"uint256"}],name:"updateMaxBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"updatePreviousCommunity(address)":{inputs:[{internalType:"contract ICommunity",name:"_newPreviousCommunity",type:"address"}],name:"updatePreviousCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"updateToken(address,address[],uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_newToken",type:"address"},{internalType:"address[]",name:"_exchangePath",type:"address[]"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"}],name:"updateToken",outputs:[],stateMutability:"nonpayable",type:"function"},"validBeneficiaryCount()":{inputs:[],name:"validBeneficiaryCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/community/interfaces/ICommunity.sol:ICommunity":{source:"contracts/community/interfaces/ICommunity.sol",name:"ICommunity",methods:{"addBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"addBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"addBeneficiariesUsingSignature(address[],uint256,bytes)":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"},{internalType:"uint256",name:"_expirationTimestamp",type:"uint256"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"addBeneficiariesUsingSignature",outputs:[],stateMutability:"nonpayable",type:"function"},"addBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"addBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"addCopy(address)":{inputs:[{internalType:"contract ICommunity",name:"_copy",type:"address"}],name:"addCopy",outputs:[],stateMutability:"nonpayable",type:"function"},"addManager(address)":{inputs:[{internalType:"address",name:"_managerAddress",type:"address"}],name:"addManager",outputs:[],stateMutability:"nonpayable",type:"function"},"addTreasuryFunds(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"addTreasuryFunds",outputs:[],stateMutability:"nonpayable",type:"function"},"baseInterval()":{inputs:[],name:"baseInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"beneficiaries(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"beneficiaries",outputs:[{internalType:"enum ICommunity.BeneficiaryState",name:"state",type:"uint8"},{internalType:"uint256",name:"claims",type:"uint256"},{internalType:"uint256",name:"claimedAmount",type:"uint256"},{internalType:"uint256",name:"lastClaim",type:"uint256"}],stateMutability:"view",type:"function"},"beneficiaryClaimedAmounts(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"beneficiaryClaimedAmounts",outputs:[{internalType:"uint256[]",name:"claimedAmounts",type:"uint256[]"}],stateMutability:"view",type:"function"},"beneficiaryJoinFromMigrated(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"beneficiaryJoinFromMigrated",outputs:[],stateMutability:"nonpayable",type:"function"},"beneficiaryListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"beneficiaryListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"beneficiaryListLength()":{inputs:[],name:"beneficiaryListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"changeBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"_newBeneficiaryAddress",type:"address"}],name:"changeBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"changeBeneficiaryAddressByManager(address,address)":{inputs:[{internalType:"address",name:"_oldBeneficiaryAddress",type:"address"},{internalType:"address",name:"_newBeneficiaryAddress",type:"address"}],name:"changeBeneficiaryAddressByManager",outputs:[],stateMutability:"nonpayable",type:"function"},"claim()":{inputs:[],name:"claim",outputs:[],stateMutability:"nonpayable",type:"function"},"claimAmount()":{inputs:[],name:"claimAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimCooldown(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"claimCooldown",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"communityAdmin()":{inputs:[],name:"communityAdmin",outputs:[{internalType:"contract ICommunityAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"copies()":{inputs:[],name:"copies",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function"},"copyBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"copyBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"copyCommunityDetails(address)":{inputs:[{internalType:"contract ICommunity",name:"_originalCommunity",type:"address"}],name:"copyCommunityDetails",outputs:[],stateMutability:"nonpayable",type:"function"},"copyOf()":{inputs:[],name:"copyOf",outputs:[{internalType:"contract ICommunity",name:"",type:"address"}],stateMutability:"view",type:"function"},"decreaseStep()":{inputs:[],name:"decreaseStep",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donate(address,uint256)":{inputs:[{internalType:"address",name:"_sender",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"donate",outputs:[],stateMutability:"nonpayable",type:"function"},"getInitialMaxClaim()":{inputs:[],name:"getInitialMaxClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"impactMarketAddress()":{inputs:[],name:"impactMarketAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"},"incrementInterval()":{inputs:[],name:"incrementInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"initialize(address,address[],uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"address[]",name:"_managers",type:"address[]"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"},{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"},{internalType:"uint256",name:"_maxBeneficiaries",type:"uint256"},{internalType:"contract ICommunity",name:"_previousCommunity",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function"},"isSelfFunding()":{inputs:[],name:"isSelfFunding",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"lastFundRequest()":{inputs:[],name:"lastFundRequest",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lastInterval(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"lastInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lock()":{inputs:[],name:"lock",outputs:[],stateMutability:"nonpayable",type:"function"},"lockBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"lockBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"lockBeneficiariesUsingSignature(address[],uint256,bytes)":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"},{internalType:"uint256",name:"_expirationTimestamp",type:"uint256"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"lockBeneficiariesUsingSignature",outputs:[],stateMutability:"nonpayable",type:"function"},"lockBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"lockBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"locked()":{inputs:[],name:"locked",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"maxBeneficiaries()":{inputs:[],name:"maxBeneficiaries",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"maxClaim()":{inputs:[],name:"maxClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"maxTotalClaim()":{inputs:[],name:"maxTotalClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"maxTranche()":{inputs:[],name:"maxTranche",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minTranche()":{inputs:[],name:"minTranche",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"originalClaimAmount()":{inputs:[],name:"originalClaimAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"previousCommunity()":{inputs:[],name:"previousCommunity",outputs:[{internalType:"contract ICommunity",name:"",type:"address"}],stateMutability:"view",type:"function"},"privateFunds()":{inputs:[],name:"privateFunds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"removeBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"removeBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"removeBeneficiariesUsingSignature(address[],uint256,bytes)":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"},{internalType:"uint256",name:"_expirationTimestamp",type:"uint256"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"removeBeneficiariesUsingSignature",outputs:[],stateMutability:"nonpayable",type:"function"},"removeBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"removeBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"removeManager(address)":{inputs:[{internalType:"address",name:"_managerAddress",type:"address"}],name:"removeManager",outputs:[],stateMutability:"nonpayable",type:"function"},"requestFunds()":{inputs:[],name:"requestFunds",outputs:[],stateMutability:"nonpayable",type:"function"},"setBeneficiaryState(address,uint8)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"},{internalType:"enum ICommunity.BeneficiaryState",name:"_state",type:"uint8"}],name:"setBeneficiaryState",outputs:[],stateMutability:"nonpayable",type:"function"},"token()":{inputs:[],name:"token",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"tokenList()":{inputs:[],name:"tokenList",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function"},"tokenUpdates(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"tokenUpdates",outputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"ratio",type:"uint256"},{internalType:"uint256",name:"startBlock",type:"uint256"}],stateMutability:"view",type:"function"},"tokenUpdatesLength()":{inputs:[],name:"tokenUpdatesLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"treasuryFunds()":{inputs:[],name:"treasuryFunds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"unlock()":{inputs:[],name:"unlock",outputs:[],stateMutability:"nonpayable",type:"function"},"unlockBeneficiaries(address[])":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"}],name:"unlockBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"unlockBeneficiariesUsingSignature(address[],uint256,bytes)":{inputs:[{internalType:"address[]",name:"_beneficiaryAddresses",type:"address[]"},{internalType:"uint256",name:"_expirationTimestamp",type:"uint256"},{internalType:"bytes",name:"_signature",type:"bytes"}],name:"unlockBeneficiariesUsingSignature",outputs:[],stateMutability:"nonpayable",type:"function"},"unlockBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"unlockBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"updateBeneficiaryParams(uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"}],name:"updateBeneficiaryParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityAdmin(address)":{inputs:[{internalType:"contract ICommunityAdmin",name:"_communityAdmin",type:"address"}],name:"updateCommunityAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityParams(uint256,uint256)":{inputs:[{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"}],name:"updateCommunityParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateMaxBeneficiaries(uint256)":{inputs:[{internalType:"uint256",name:"_newMaxBeneficiaries",type:"uint256"}],name:"updateMaxBeneficiaries",outputs:[],stateMutability:"nonpayable",type:"function"},"updatePreviousCommunity(address)":{inputs:[{internalType:"contract ICommunity",name:"_newPreviousCommunity",type:"address"}],name:"updatePreviousCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"updateToken(address,address[],uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_newToken",type:"address"},{internalType:"address[]",name:"_exchangePath",type:"address[]"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"}],name:"updateToken",outputs:[],stateMutability:"nonpayable",type:"function"},"validBeneficiaryCount()":{inputs:[],name:"validBeneficiaryCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/community/interfaces/ICommunityAdmin.sol:ICommunityAdmin":{source:"contracts/community/interfaces/ICommunityAdmin.sol",name:"ICommunityAdmin",methods:{"addCommunity(address,address[],address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"address[]",name:"_managers",type:"address[]"},{internalType:"address",name:"_ambassador",type:"address"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"},{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"},{internalType:"uint256",name:"_maxBeneficiaries",type:"uint256"}],name:"addCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"ambassadors()":{inputs:[],name:"ambassadors",outputs:[{internalType:"contract IAmbassadors",name:"",type:"address"}],stateMutability:"view",type:"function"},"authorizedWalletAddress()":{inputs:[],name:"authorizedWalletAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"calculateCommunityTrancheAmount(address)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"}],name:"calculateCommunityTrancheAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"communities(address)":{inputs:[{internalType:"address",name:"_community",type:"address"}],name:"communities",outputs:[{internalType:"enum ICommunityAdmin.CommunityState",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"communityImplementation()":{inputs:[],name:"communityImplementation",outputs:[{internalType:"contract ICommunity",name:"",type:"address"}],stateMutability:"view",type:"function"},"communityListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"communityListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"communityListLength()":{inputs:[],name:"communityListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"communityMiddleProxy()":{inputs:[],name:"communityMiddleProxy",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"communityProxyAdmin()":{inputs:[],name:"communityProxyAdmin",outputs:[{internalType:"contract ProxyAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"fundCommunity()":{inputs:[],name:"fundCommunity",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"getCommunityProxyImplementation(address)":{inputs:[{internalType:"address",name:"_communityProxyAddress",type:"address"}],name:"getCommunityProxyImplementation",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"impactMarketCouncil()":{inputs:[],name:"impactMarketCouncil",outputs:[{internalType:"contract IImpactMarketCouncil",name:"",type:"address"}],stateMutability:"view",type:"function"},"isAmbassadorOrEntityOfCommunity(address,address)":{inputs:[{internalType:"address",name:"_community",type:"address"},{internalType:"address",name:"_ambassadorOrEntity",type:"address"}],name:"isAmbassadorOrEntityOfCommunity",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"migrateCommunity(address[],address)":{inputs:[{internalType:"address[]",name:"_managers",type:"address[]"},{internalType:"contract ICommunity",name:"_previousCommunity",type:"address"}],name:"migrateCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"minClaimAmountRatio()":{inputs:[],name:"minClaimAmountRatio",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minClaimAmountRatioPrecision()":{inputs:[],name:"minClaimAmountRatioPrecision",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"removeCommunity(address)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"}],name:"removeCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"setCommunityToAmbassador(address,address)":{inputs:[{internalType:"address",name:"_ambassador",type:"address"},{internalType:"contract ICommunity",name:"_communityAddress",type:"address"}],name:"setCommunityToAmbassador",outputs:[],stateMutability:"nonpayable",type:"function"},"splitCommunity(address,uint256,address,address[])":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_numberOfCopies",type:"uint256"},{internalType:"address",name:"_ambassador",type:"address"},{internalType:"address[]",name:"_managers",type:"address[]"}],name:"splitCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"transferFromCommunity(address,address,address,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transferFromCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"contract ITreasury",name:"",type:"address"}],stateMutability:"view",type:"function"},"treasuryMinBalance()":{inputs:[],name:"treasuryMinBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"treasurySafetyPercentage()":{inputs:[],name:"treasurySafetyPercentage",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"updateAmbassadors(address)":{inputs:[{internalType:"contract IAmbassadors",name:"_newAmbassadors",type:"address"}],name:"updateAmbassadors",outputs:[],stateMutability:"nonpayable",type:"function"},"updateAuthorizedWalletAddress(address)":{inputs:[{internalType:"address",name:"_newSignerAddress",type:"address"}],name:"updateAuthorizedWalletAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"updateBeneficiaryParams(address,uint256,uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"},{internalType:"uint256",name:"_maxBeneficiaries",type:"uint256"}],name:"updateBeneficiaryParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityImplementation(address)":{inputs:[{internalType:"contract ICommunity",name:"_communityImplementation_",type:"address"}],name:"updateCommunityImplementation",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityMiddleProxy(address)":{inputs:[{internalType:"address",name:"_communityMiddleProxy",type:"address"}],name:"updateCommunityMiddleProxy",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityParams(address,uint256,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"}],name:"updateCommunityParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityToken(address,address,address[],uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"contract IERC20Upgradeable",name:"_newToken",type:"address"},{internalType:"address[]",name:"_exchangePath",type:"address[]"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"}],name:"updateCommunityToken",outputs:[],stateMutability:"nonpayable",type:"function"},"updateImpactMarketCouncil(address)":{inputs:[{internalType:"contract IImpactMarketCouncil",name:"_newImpactMarketCouncil",type:"address"}],name:"updateImpactMarketCouncil",outputs:[],stateMutability:"nonpayable",type:"function"},"updateMinClaimAmountRatio(uint256)":{inputs:[{internalType:"uint256",name:"_newMinClaimAmountRatio",type:"uint256"}],name:"updateMinClaimAmountRatio",outputs:[],stateMutability:"nonpayable",type:"function"},"updateProxyImplementation(address,address)":{inputs:[{internalType:"address",name:"_communityMiddleProxy",type:"address"},{internalType:"address",name:"_newLogic",type:"address"}],name:"updateProxyImplementation",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasury(address)":{inputs:[{internalType:"contract ITreasury",name:"_newTreasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasuryMinBalance(uint256)":{inputs:[{internalType:"uint256",name:"_newTreasuryMinBalance",type:"uint256"}],name:"updateTreasuryMinBalance",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasurySafetyPercentage(uint256)":{inputs:[{internalType:"uint256",name:"_newTreasurySafetyPercentage",type:"uint256"}],name:"updateTreasurySafetyPercentage",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/community/interfaces/IPreviousCommunity.sol:IPreviousCommunity":{source:"contracts/community/interfaces/IPreviousCommunity.sol",name:"IPreviousCommunity",methods:{"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"claimAmount()":{inputs:[],name:"claimAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"}}},"contracts/deposit/DepositImplementation.sol:DepositImplementation":{source:"contracts/deposit/DepositImplementation.sol",name:"DepositImplementation",events:{"DepositAdded(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"depositorAddress",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"DepositAdded",type:"event",params:{amount:"Amount of the deposit",depositorAddress:"The address of the depositor that makes the deposit",token:"ERC20 token address"},notice:"Triggered when an amount of an ERC20 has been deposited"},"DonateInterest(address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"depositorAddress",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"interest",type:"uint256"}],name:"DonateInterest",type:"event",params:{amount:"Amount of the withdrawal",depositorAddress:"The address of the depositor",interest:"Interest earned (and donated to DonationMiner)",token:"ERC20 token address"},notice:"Triggered when the interest of an amount of an ERC20 has been donated"},"DonationMinerUpdated(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldDonationMiner",type:"address"},{indexed:!0,internalType:"address",name:"newDonationMiner",type:"address"}],name:"DonationMinerUpdated",type:"event",params:{newDonationMiner:"New donationMiner address",oldDonationMiner:"Old donationMiner address"},notice:"Triggered when the donationMiner address has been updated"},"LendingPoolUpdated(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldLendingPool",type:"address"},{indexed:!0,internalType:"address",name:"newLendingPool",type:"address"}],name:"LendingPoolUpdated",type:"event",params:{newLendingPool:"New lendingPool address",oldLendingPool:"Old lendingPool address"},notice:"Triggered when LendingPool has been updated"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"TokenAdded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tokenAddress",type:"address"}],name:"TokenAdded",type:"event",params:{tokenAddress:"Address of the token"},notice:"Triggered when a token has been added"},"TokenRemoved(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tokenAddress",type:"address"}],name:"TokenRemoved",type:"event",params:{tokenAddress:"Address of the token"},notice:"Triggered when a token has been removed"},"TreasuryUpdated(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldTreasury",type:"address"},{indexed:!0,internalType:"address",name:"newTreasury",type:"address"}],name:"TreasuryUpdated",type:"event",params:{newTreasury:"New treasury address",oldTreasury:"Old treasury address"},notice:"Triggered when the treasury address has been updated"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Withdraw(address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"depositorAddress",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"interest",type:"uint256"}],name:"Withdraw",type:"event",params:{amount:"Amount of the withdrawal",depositorAddress:"The address of the depositor that makes the withdrawal",interest:"Interest earned (and donated to DonationMiner)",token:"ERC20 token address"},notice:"Triggered when an amount of an ERC20 has been withdrawn"}},methods:{"addToken(address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"}],name:"addToken",outputs:[],stateMutability:"nonpayable",type:"function"},"deposit(address,uint256)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"deposit",outputs:[],stateMutability:"nonpayable",type:"function"},"donateInterest(address,address,uint256)":{inputs:[{internalType:"address",name:"_depositorAddress",type:"address"},{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"donateInterest",outputs:[],stateMutability:"nonpayable",type:"function"},"donationMiner()":{inputs:[],name:"donationMiner",outputs:[{internalType:"contract IDonationMiner",name:"",type:"address"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function",notice:"Returns the current implementation version"},"initialize(address,address,address,address[])":{inputs:[{internalType:"contract ITreasury",name:"_treasury",type:"address"},{internalType:"contract IDonationMiner",name:"_donationMiner",type:"address"},{internalType:"contract ILendingPool",name:"_lendingPool",type:"address"},{internalType:"address[]",name:"_tokenList",type:"address[]"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_lendingPool:"Address of the LendingPool",_treasury:"Address of the Treasury"},notice:"Used to initialize a new DonationMiner contract"},"interest(address,address,uint256)":{inputs:[{internalType:"address",name:"_depositorAddress",type:"address"},{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"interest",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"isToken(address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"}],name:"isToken",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_tokenAddress:"token address to be checked"},returns:{_0:"bool true if the tokenAddress is an accepted token"},notice:"Returns if an address is an accepted token"},"lendingPool()":{inputs:[],name:"lendingPool",outputs:[{internalType:"contract ILendingPool",name:"",type:"address"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if the contract is paused, and false otherwise."},"removeToken(address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"}],name:"removeToken",outputs:[],stateMutability:"nonpayable",type:"function"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"token(address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"}],name:"token",outputs:[{internalType:"uint256",name:"totalAmount",type:"uint256"},{internalType:"uint256",name:"depositorListLength",type:"uint256"}],stateMutability:"view",type:"function"},"tokenDepositor(address,address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"address",name:"_depositorAddress",type:"address"}],name:"tokenDepositor",outputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"scaledBalance",type:"uint256"}],stateMutability:"view",type:"function"},"tokenDepositorListAt(address,uint256)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_index",type:"uint256"}],name:"tokenDepositorListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tokenListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"tokenListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{_index:"index of the token"},returns:{_0:"address of the token"},notice:"Returns the address of a token from tokenList"},"tokenListLength()":{inputs:[],name:"tokenListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"uint256 number of tokens"},notice:"Returns the number of tokens"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"contract ITreasury",name:"",type:"address"}],stateMutability:"view",type:"function"},"updateDonationMiner(address)":{inputs:[{internalType:"contract IDonationMiner",name:"_newDonationMiner",type:"address"}],name:"updateDonationMiner",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newDonationMiner:"address of new donationMiner contract"},notice:"Updates DonationMiner address"},"updateLendingPool(address)":{inputs:[{internalType:"contract ILendingPool",name:"_newLendingPool",type:"address"}],name:"updateLendingPool",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newLendingPool:"address of the new LendingPool contract"},notice:"Updates the LendingPool contract address"},"updateTreasury(address)":{inputs:[{internalType:"contract ITreasury",name:"_newTreasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newTreasury:"address of new treasury contract"},notice:"Updates Treasury address"},"withdraw(address,uint256)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/deposit/DepositProxy.sol:DepositProxy":{source:"contracts/deposit/DepositProxy.sol",name:"DepositProxy",constructor:{inputs:[{internalType:"address",name:"_logic",type:"address"},{internalType:"address",name:"_proxyAdmin",type:"address"}],stateMutability:"nonpayable",type:"constructor"},fallback:{stateMutability:"payable",type:"fallback"},receive:{stateMutability:"payable",type:"receive"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"admin()":{inputs:[],name:"admin",outputs:[{internalType:"address",name:"admin_",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Returns the current admin. NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}. TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`"},"changeAdmin(address)":{inputs:[{internalType:"address",name:"newAdmin",type:"address"}],name:"changeAdmin",outputs:[],stateMutability:"nonpayable",type:"function",details:"Changes the admin of the proxy. Emits an {AdminChanged} event. NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}."},"implementation()":{inputs:[],name:"implementation",outputs:[{internalType:"address",name:"implementation_",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Returns the current implementation. NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}. TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy. NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy, and then call a function from the new implementation as specified by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the proxied contract. NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}."}}},"contracts/deposit/interfaces/DepositStorageV1.sol:DepositStorageV1":{source:"contracts/deposit/interfaces/DepositStorageV1.sol",name:"DepositStorageV1",title:"Storage for Deposit",notice:"For future upgrades, do not change DepositStorageV1. Create a new contract which implements DepositStorageV1 and following the naming convention DepositStorageVx.",methods:{"addToken(address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"}],name:"addToken",outputs:[],stateMutability:"nonpayable",type:"function"},"deposit(address,uint256)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"deposit",outputs:[],stateMutability:"nonpayable",type:"function"},"donateInterest(address,address,uint256)":{inputs:[{internalType:"address",name:"_depositorAddress",type:"address"},{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"donateInterest",outputs:[],stateMutability:"nonpayable",type:"function"},"donationMiner()":{inputs:[],name:"donationMiner",outputs:[{internalType:"contract IDonationMiner",name:"",type:"address"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"interest(address,address,uint256)":{inputs:[{internalType:"address",name:"_depositorAddress",type:"address"},{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"interest",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"isToken(address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"}],name:"isToken",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"lendingPool()":{inputs:[],name:"lendingPool",outputs:[{internalType:"contract ILendingPool",name:"",type:"address"}],stateMutability:"view",type:"function"},"removeToken(address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"}],name:"removeToken",outputs:[],stateMutability:"nonpayable",type:"function"},"token(address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"}],name:"token",outputs:[{internalType:"uint256",name:"totalAmount",type:"uint256"},{internalType:"uint256",name:"depositorListLength",type:"uint256"}],stateMutability:"view",type:"function"},"tokenDepositor(address,address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"address",name:"_depositorAddress",type:"address"}],name:"tokenDepositor",outputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"scaledBalance",type:"uint256"}],stateMutability:"view",type:"function"},"tokenDepositorListAt(address,uint256)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_index",type:"uint256"}],name:"tokenDepositorListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tokenListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"tokenListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tokenListLength()":{inputs:[],name:"tokenListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"contract ITreasury",name:"",type:"address"}],stateMutability:"view",type:"function"},"updateDonationMiner(address)":{inputs:[{internalType:"contract IDonationMiner",name:"_newDonationMiner",type:"address"}],name:"updateDonationMiner",outputs:[],stateMutability:"nonpayable",type:"function"},"updateLendingPool(address)":{inputs:[{internalType:"contract ILendingPool",name:"_lendingPool",type:"address"}],name:"updateLendingPool",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasury(address)":{inputs:[{internalType:"contract ITreasury",name:"_newTreasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function"},"withdraw(address,uint256)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/deposit/interfaces/IDeposit.sol:IDeposit":{source:"contracts/deposit/interfaces/IDeposit.sol",name:"IDeposit",methods:{"addToken(address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"}],name:"addToken",outputs:[],stateMutability:"nonpayable",type:"function"},"deposit(address,uint256)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"deposit",outputs:[],stateMutability:"nonpayable",type:"function"},"donateInterest(address,address,uint256)":{inputs:[{internalType:"address",name:"_depositorAddress",type:"address"},{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"donateInterest",outputs:[],stateMutability:"nonpayable",type:"function"},"donationMiner()":{inputs:[],name:"donationMiner",outputs:[{internalType:"contract IDonationMiner",name:"",type:"address"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"interest(address,address,uint256)":{inputs:[{internalType:"address",name:"_depositorAddress",type:"address"},{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"interest",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"isToken(address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"}],name:"isToken",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"lendingPool()":{inputs:[],name:"lendingPool",outputs:[{internalType:"contract ILendingPool",name:"",type:"address"}],stateMutability:"view",type:"function"},"removeToken(address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"}],name:"removeToken",outputs:[],stateMutability:"nonpayable",type:"function"},"token(address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"}],name:"token",outputs:[{internalType:"uint256",name:"totalAmount",type:"uint256"},{internalType:"uint256",name:"depositorListLength",type:"uint256"}],stateMutability:"view",type:"function"},"tokenDepositor(address,address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"address",name:"_depositorAddress",type:"address"}],name:"tokenDepositor",outputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"scaledBalance",type:"uint256"}],stateMutability:"view",type:"function"},"tokenDepositorListAt(address,uint256)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_index",type:"uint256"}],name:"tokenDepositorListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tokenListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"tokenListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tokenListLength()":{inputs:[],name:"tokenListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"contract ITreasury",name:"",type:"address"}],stateMutability:"view",type:"function"},"updateDonationMiner(address)":{inputs:[{internalType:"contract IDonationMiner",name:"_newDonationMiner",type:"address"}],name:"updateDonationMiner",outputs:[],stateMutability:"nonpayable",type:"function"},"updateLendingPool(address)":{inputs:[{internalType:"contract ILendingPool",name:"_lendingPool",type:"address"}],name:"updateLendingPool",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasury(address)":{inputs:[{internalType:"contract ITreasury",name:"_newTreasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function"},"withdraw(address,uint256)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/donationMiner/DonationMinerImplementation.sol:DonationMinerImplementation":{source:"contracts/donationMiner/DonationMinerImplementation.sol",name:"DonationMinerImplementation",events:{"AgainstPeriodsUpdated(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldAgainstPeriods",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newAgainstPeriods",type:"uint256"}],name:"AgainstPeriodsUpdated",type:"event",params:{newAgainstPeriods:"New againstPeriods value",oldAgainstPeriods:"Old againstPeriods value"},notice:"Triggered when the againstPeriods value has been updated"},"ClaimDelayUpdated(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldClaimDelay",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newClaimDelay",type:"uint256"}],name:"ClaimDelayUpdated",type:"event",params:{newClaimDelay:"New claimDelay value",oldClaimDelay:"Old claimDelay value"},notice:"Triggered when the claimDelay value has been updated"},"CommunityDonationRatioUpdated(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldCommunityDonationRatio",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newCommunityDonationRatio",type:"uint256"}],name:"CommunityDonationRatioUpdated",type:"event",params:{newCommunityDonationRatio:"New communityDonationRatio value",oldCommunityDonationRatio:"Old communityDonationRatio value"},notice:"Triggered when the communityDonationRatio value has been updated"},"DonationAdded(uint256,address,uint256,address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"donationId",type:"uint256"},{indexed:!0,internalType:"address",name:"delegateAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"initialAmount",type:"uint256"},{indexed:!0,internalType:"address",name:"target",type:"address"}],name:"DonationAdded",type:"event",params:{amount:"Number of token donated",delegateAddress:"Address of the delegate",donationId:"Id of the donation",target:"Address of the receiver (community or treasury)                          or address of the DonationMiner contract otherwise",token:"Address of the token after conversion"},notice:"Triggered when a donation has been added"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"RewardClaimed(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"donor",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"RewardClaimed",type:"event",params:{amount:"Value of the reward",donor:"Address of the donner"},notice:"Triggered when a donor has claimed his reward"},"RewardClaimedPartial(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"donor",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"lastRewardPeriod",type:"uint256"}],name:"RewardClaimedPartial",type:"event",params:{amount:"Value of the reward",donor:"Address of the donner",lastRewardPeriod:"Number of the last reward period for witch the claim was made"},notice:"Triggered when a donor has claimed his reward"},"RewardPeriodParamsUpdated(uint256,uint256,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldRewardPeriodSize",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldDecayNumerator",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldDecayDenominator",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newRewardPeriodSize",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newDecayNumerator",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newDecayDenominator",type:"uint256"}],name:"RewardPeriodParamsUpdated",type:"event",params:{newDecayDenominator:"New decayDenominator value For further information regarding each parameter, see *DonationMiner* smart contract initialize method.",newDecayNumerator:"New decayNumerator value",newRewardPeriodSize:"New rewardPeriodSize value",oldDecayDenominator:"Old decayDenominator value",oldDecayNumerator:"Old decayNumerator value",oldRewardPeriodSize:"Old rewardPeriodSize value"},notice:"Triggered when reward period params have been updated"},"RewardStaked(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"donor",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"RewardStaked",type:"event",params:{amount:"Value of the reward",donor:"Address of the donner"},notice:"Triggered when a donor has staked his reward"},"RewardStakedPartial(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"donor",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"lastRewardPeriod",type:"uint256"}],name:"RewardStakedPartial",type:"event",params:{amount:"Value of the reward",donor:"Address of the donner",lastRewardPeriod:"Number of the last reward period for witch tha stake was made"},notice:"Triggered when a donor has staked his reward"},"StakingDonationRatioUpdated(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldStakingDonationRatio",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newStakingDonationRatio",type:"uint256"}],name:"StakingDonationRatioUpdated",type:"event",params:{newStakingDonationRatio:"New stakingDonationRatio value",oldStakingDonationRatio:"Old stakingDonationRatio value"},notice:"Triggered when the stakingDonationRatio value has been updated"},"StakingUpdated(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldStaking",type:"address"},{indexed:!0,internalType:"address",name:"newStaking",type:"address"}],name:"StakingUpdated",type:"event",params:{newStaking:"New staking address",oldStaking:"Old staking address"},notice:"Triggered when the staking address has been updated"},"TransferERC20(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"TransferERC20",type:"event",params:{amount:"Amount of the transaction",to:"Address of the receiver",token:"ERC20 token address"},notice:"Triggered when an amount of an ERC20 has been transferred from this contract to an address"},"TreasuryUpdated(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldTreasury",type:"address"},{indexed:!0,internalType:"address",name:"newTreasury",type:"address"}],name:"TreasuryUpdated",type:"event",params:{newTreasury:"New treasury address",oldTreasury:"Old treasury address"},notice:"Triggered when the treasury address has been updated"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"}},methods:{"PACT()":{inputs:[],name:"PACT",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"againstPeriods()":{inputs:[],name:"againstPeriods",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"apr(address)":{inputs:[{internalType:"address",name:"_stakeholderAddress",type:"address"}],name:"apr",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_stakeholderAddress:"address of the stakeHolder"},returns:{_0:"uint256 APR of the user"},notice:"Calculates the APR of a user based on his staking"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"calculateClaimableRewards(address)":{inputs:[{internalType:"address",name:"_donorAddress",type:"address"}],name:"calculateClaimableRewards",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_donorAddress:"address of the donor"},returns:{_0:"claimAmount uint256 sum of all donor's rewards that has not been claimed until _lastPeriodNumber"},notice:"Calculates the rewards from ended reward periods of a donor"},"calculateClaimableRewardsByPeriodNumber(address,uint256)":{inputs:[{internalType:"address",name:"_donorAddress",type:"address"},{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"calculateClaimableRewardsByPeriodNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_donorAddress:"address of the donor",_lastPeriodNumber:"last reward period number to be computed"},returns:{_0:"uint256 sum of all donor's rewards that has not been claimed until _lastPeriodNumber"},notice:"Calculates the rewards from ended reward periods of a donor"},"claimDelay()":{inputs:[],name:"claimDelay",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimRewards()":{inputs:[],name:"claimRewards",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Transfers to the sender the rewards"},"claimRewardsPartial(uint256)":{inputs:[{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"claimRewardsPartial",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Transfers to the sender the rewards"},"communityDonationRatio()":{inputs:[],name:"communityDonationRatio",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"currentRewardPeriodNumber()":{inputs:[],name:"currentRewardPeriodNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decayDenominator()":{inputs:[],name:"decayDenominator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decayNumerator()":{inputs:[],name:"decayNumerator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donate(address,uint256,address)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"},{internalType:"address",name:"_delegateAddress",type:"address"}],name:"donate",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"Amount of cUSD tokens to deposit.",_delegateAddress:"the address that will claim the reward for the donation",_token:"address of the token"},notice:"Transfers cUSD tokens to the treasury contract"},"donateToCommunity(address,address,uint256,address)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"},{internalType:"address",name:"_delegateAddress",type:"address"}],name:"donateToCommunity",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers tokens to the community contract",params:{_amount:"amount of cUSD tokens to deposit",_community:"address of the community",_delegateAddress:"the address that will claim the reward for the donation",_token:"address of the token"}},"donationCount()":{inputs:[],name:"donationCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donations(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"donations",outputs:[{internalType:"address",name:"donor",type:"address"},{internalType:"address",name:"target",type:"address"},{internalType:"uint256",name:"rewardPeriod",type:"uint256"},{internalType:"uint256",name:"blockNumber",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"contract IERC20Upgradeable",name:"token",type:"address"},{internalType:"uint256",name:"initialAmount",type:"uint256"}],stateMutability:"view",type:"function"},"donorRewardPeriod(address,uint256)":{inputs:[{internalType:"address",name:"_donor",type:"address"},{internalType:"uint256",name:"_rewardPeriodIndex",type:"uint256"}],name:"donorRewardPeriod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_donor:"address of the donor",_rewardPeriodIndex:"index of the reward period"},returns:{_0:"uint256 number of the reward period"},notice:"Returns a reward period number from a donor reward period list"},"donorScore(address)":{inputs:[{internalType:"address",name:"_donorAddress",type:"address"}],name:"donorScore",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Calculate the score of a user based as this ratio (his donation and staking) / (all donation and staking) E.G. score = 0.01 * 1e18 => the donor have have 1% score      so he will get 1% of the reward",params:{_donorAddress:"address of the donor"},returns:{_0:"uint256    donor's score"}},"donors(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"donors",outputs:[{internalType:"uint256",name:"lastClaim",type:"uint256"},{internalType:"uint256",name:"rewardPeriodsCount",type:"uint256"},{internalType:"uint256",name:"lastClaimPeriod",type:"uint256"}],stateMutability:"view",type:"function"},"estimateClaimableReward(address)":{inputs:[{internalType:"address",name:"_donorAddress",type:"address"}],name:"estimateClaimableReward",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_donorAddress:"address of the donor"},returns:{_0:"uint256 reward that donor will receive in current reward period if there isn't another donation"},notice:"Calculates the estimate reward of a donor for current reward period"},"estimateClaimableRewardAdvance(address)":{inputs:[{internalType:"address",name:"_donorAddress",type:"address"}],name:"estimateClaimableRewardAdvance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_donorAddress:"address of the donor"},returns:{_0:"uint256 reward that donor will receive in current reward period if there isn't another donation"},notice:"Calculates the estimate reward of a donor for the next x reward periods"},"estimateClaimableRewardByStaking(address)":{inputs:[{internalType:"address",name:"_donorAddress",type:"address"}],name:"estimateClaimableRewardByStaking",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"uint256 estimated reward by donor stakes"},notice:"Calculates the estimate reward of a donor for current reward period based on his staking"},"generalApr()":{inputs:[],name:"generalApr",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"uint256 APR"},notice:"Calculates the APR"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function",notice:"Returns the current implementation version"},"initialize(address,address,address,uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_cUSD",type:"address"},{internalType:"contract IERC20Upgradeable",name:"_PACT",type:"address"},{internalType:"contract ITreasury",name:"_treasury",type:"address"},{internalType:"uint256",name:"_firstRewardPerBlock",type:"uint256"},{internalType:"uint256",name:"_rewardPeriodSize",type:"uint256"},{internalType:"uint256",name:"_startingBlock",type:"uint256"},{internalType:"uint256",name:"_decayNumerator",type:"uint256"},{internalType:"uint256",name:"_decayDenominator",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_PACT:"Address of the PACT Token",_cUSD:"Address of the cUSD token",_decayDenominator:"Decay denominator used for calculating the new reward per block based on the previous reward per block",_decayNumerator:"Decay numerator used for calculating the new reward per block based on the previous reward per block",_firstRewardPerBlock:"Number of PACTs given for each block                              from the first reward period",_rewardPeriodSize:"Number of blocks of the reward period",_startingBlock:"First block of the first reward period",_treasury:"Address of the Treasury"},notice:"Used to initialize a new DonationMiner contract"},"lastPeriodsDonations(address)":{inputs:[{internalType:"address",name:"_donorAddress",type:"address"}],name:"lastPeriodsDonations",outputs:[{internalType:"uint256",name:"donorAmount",type:"uint256"},{internalType:"uint256",name:"totalAmount",type:"uint256"}],stateMutability:"view",type:"function",details:"Calculate all donations on the last X epochs as well as everyone else in the same period.",params:{_donorAddress:"address of the donor"},returns:{donorAmount:"uint256    sum of donor's donations",totalAmount:"uint256    sum of all donations"}},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if the contract is paused, and false otherwise."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"rewardPeriodCount()":{inputs:[],name:"rewardPeriodCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodDonorAmount(uint256,address)":{inputs:[{internalType:"uint256",name:"_period",type:"uint256"},{internalType:"address",name:"_donor",type:"address"}],name:"rewardPeriodDonorAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_donor:"address of the donor",_period:"number of the reward period"},returns:{_0:"uint256 amount of cUSD donated by the user in this reward period"},notice:"Returns the amount of cUSD donated by a user in a reward period"},"rewardPeriodDonorStakeAmounts(uint256,address)":{inputs:[{internalType:"uint256",name:"_period",type:"uint256"},{internalType:"address",name:"_donor",type:"address"}],name:"rewardPeriodDonorStakeAmounts",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_donor:"address of the donor",_period:"reward period number"},returns:{_0:"uint256 amount of PACT staked by a user at the and of the reward period"},notice:"Returns the amount of PACT staked by a user at the and of the reward period"},"rewardPeriodSize()":{inputs:[],name:"rewardPeriodSize",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriods(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"rewardPeriods",outputs:[{internalType:"uint256",name:"rewardPerBlock",type:"uint256"},{internalType:"uint256",name:"rewardAmount",type:"uint256"},{internalType:"uint256",name:"startBlock",type:"uint256"},{internalType:"uint256",name:"endBlock",type:"uint256"},{internalType:"uint256",name:"donationsAmount",type:"uint256"},{internalType:"uint256",name:"againstPeriods",type:"uint256"},{internalType:"uint256",name:"stakesAmount",type:"uint256"},{internalType:"uint256",name:"stakingDonationRatio",type:"uint256"}],stateMutability:"view",type:"function"},"setStakingAmounts(address,uint256,uint256)":{inputs:[{internalType:"address",name:"_holderAddress",type:"address"},{internalType:"uint256",name:"_holderAmount",type:"uint256"},{internalType:"uint256",name:"_totalAmount",type:"uint256"}],name:"setStakingAmounts",outputs:[],stateMutability:"nonpayable",type:"function"},"stakeRewards()":{inputs:[],name:"stakeRewards",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Stakes the reward"},"stakeRewardsPartial(uint256)":{inputs:[{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"stakeRewardsPartial",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Stakes the reward"},"staking()":{inputs:[],name:"staking",outputs:[{internalType:"contract IStaking",name:"",type:"address"}],stateMutability:"view",type:"function"},"stakingDonationRatio()":{inputs:[],name:"stakingDonationRatio",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"amount of the transaction",_to:"address of the receiver",_token:"address of the ERC20 token"},notice:"Transfers an amount of an ERC20 from this contract to an address"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"contract ITreasury",name:"",type:"address"}],stateMutability:"view",type:"function"},"updateAgainstPeriods(uint256)":{inputs:[{internalType:"uint256",name:"_newAgainstPeriods",type:"uint256"}],name:"updateAgainstPeriods",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newAgainstPeriods:"Number of reward periods for the backward computation"},notice:"Updates againstPeriods value"},"updateClaimDelay(uint256)":{inputs:[{internalType:"uint256",name:"_newClaimDelay",type:"uint256"}],name:"updateClaimDelay",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newClaimDelay:"Number of reward periods a donor has to wait after                            a donation until he will be able to claim his reward"},notice:"Updates claimDelay value"},"updateCommunityDonationRatio(uint256)":{inputs:[{internalType:"uint256",name:"_newCommunityDonationRatio",type:"uint256"}],name:"updateCommunityDonationRatio",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newCommunityDonationRatio:"Ratio between 1USD donated into the treasury vs 1USD donated to a community"},notice:"Updates communityDonationRatio value"},"updateRewardPeriodParams(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_newRewardPeriodSize",type:"uint256"},{internalType:"uint256",name:"_newDecayNumerator",type:"uint256"},{internalType:"uint256",name:"_newDecayDenominator",type:"uint256"}],name:"updateRewardPeriodParams",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newDecayDenominator:"value of new decayDenominator",_newDecayNumerator:"value of new decayNumerator",_newRewardPeriodSize:"value of new rewardPeriodSize"},notice:"Updates reward period default params"},"updateStaking(address)":{inputs:[{internalType:"contract IStaking",name:"_newStaking",type:"address"}],name:"updateStaking",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newStaking:"address of new Staking contract"},notice:"Updates Staking address"},"updateStakingDonationRatio(uint256)":{inputs:[{internalType:"uint256",name:"_newStakingDonationRatio",type:"uint256"}],name:"updateStakingDonationRatio",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newStakingDonationRatio:"Number of tokens that need to be staked to be counted as 1 PACT donated"},notice:"Updates stakingDonationRatio value"},"updateTreasury(address)":{inputs:[{internalType:"contract ITreasury",name:"_newTreasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newTreasury:"address of new treasury_ contract"},notice:"Updates Treasury address"}}},"contracts/donationMiner/DonationMinerProxy.sol:DonationMinerProxy":{source:"contracts/donationMiner/DonationMinerProxy.sol",name:"DonationMinerProxy",constructor:{inputs:[{internalType:"address",name:"_logic",type:"address"},{internalType:"address",name:"_proxyAdmin",type:"address"}],stateMutability:"nonpayable",type:"constructor"},fallback:{stateMutability:"payable",type:"fallback"},receive:{stateMutability:"payable",type:"receive"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"admin()":{inputs:[],name:"admin",outputs:[{internalType:"address",name:"admin_",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Returns the current admin. NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}. TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`"},"changeAdmin(address)":{inputs:[{internalType:"address",name:"newAdmin",type:"address"}],name:"changeAdmin",outputs:[],stateMutability:"nonpayable",type:"function",details:"Changes the admin of the proxy. Emits an {AdminChanged} event. NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}."},"implementation()":{inputs:[],name:"implementation",outputs:[{internalType:"address",name:"implementation_",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Returns the current implementation. NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}. TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy. NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy, and then call a function from the new implementation as specified by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the proxied contract. NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}."}}},"contracts/donationMiner/interfaces/DonationMinerStorageV1.sol:DonationMinerStorageV1":{source:"contracts/donationMiner/interfaces/DonationMinerStorageV1.sol",name:"DonationMinerStorageV1",title:"Storage for DonationMiner",notice:"For future upgrades, do not change DonationMinerStorageV1. Create a new contract which implements DonationMinerStorageV1 and following the naming convention DonationMinerStorageVX.",methods:{"PACT()":{inputs:[],name:"PACT",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"againstPeriods()":{inputs:[],name:"againstPeriods",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"apr(address)":{inputs:[{internalType:"address",name:"_stakeholderAddress",type:"address"}],name:"apr",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"calculateClaimableRewards(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"calculateClaimableRewards",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"calculateClaimableRewardsByPeriodNumber(address,uint256)":{inputs:[{internalType:"address",name:"_donor",type:"address"},{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"calculateClaimableRewardsByPeriodNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"claimDelay()":{inputs:[],name:"claimDelay",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimRewards()":{inputs:[],name:"claimRewards",outputs:[],stateMutability:"nonpayable",type:"function"},"claimRewardsPartial(uint256)":{inputs:[{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"claimRewardsPartial",outputs:[],stateMutability:"nonpayable",type:"function"},"communityDonationRatio()":{inputs:[],name:"communityDonationRatio",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"currentRewardPeriodNumber()":{inputs:[],name:"currentRewardPeriodNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decayDenominator()":{inputs:[],name:"decayDenominator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decayNumerator()":{inputs:[],name:"decayNumerator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donate(address,uint256,address)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"},{internalType:"address",name:"_delegateAddress",type:"address"}],name:"donate",outputs:[],stateMutability:"nonpayable",type:"function"},"donateToCommunity(address,address,uint256,address)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"},{internalType:"address",name:"_delegateAddress",type:"address"}],name:"donateToCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"donationCount()":{inputs:[],name:"donationCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donations(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"donations",outputs:[{internalType:"address",name:"donor",type:"address"},{internalType:"address",name:"target",type:"address"},{internalType:"uint256",name:"rewardPeriod",type:"uint256"},{internalType:"uint256",name:"blockNumber",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"contract IERC20Upgradeable",name:"token",type:"address"},{internalType:"uint256",name:"initialAmount",type:"uint256"}],stateMutability:"view",type:"function"},"donorRewardPeriod(address,uint256)":{inputs:[{internalType:"address",name:"_donor",type:"address"},{internalType:"uint256",name:"_rewardPeriodIndex",type:"uint256"}],name:"donorRewardPeriod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donors(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"donors",outputs:[{internalType:"uint256",name:"lastClaim",type:"uint256"},{internalType:"uint256",name:"rewardPeriodsCount",type:"uint256"},{internalType:"uint256",name:"lastClaimPeriod",type:"uint256"}],stateMutability:"view",type:"function"},"estimateClaimableReward(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"estimateClaimableReward",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"estimateClaimableRewardAdvance(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"estimateClaimableRewardAdvance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"estimateClaimableRewardByStaking(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"estimateClaimableRewardByStaking",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"generalApr()":{inputs:[],name:"generalApr",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"lastPeriodsDonations(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"lastPeriodsDonations",outputs:[{internalType:"uint256",name:"donorAmount",type:"uint256"},{internalType:"uint256",name:"totalAmount",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodCount()":{inputs:[],name:"rewardPeriodCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodDonorAmount(uint256,address)":{inputs:[{internalType:"uint256",name:"_period",type:"uint256"},{internalType:"address",name:"_donor",type:"address"}],name:"rewardPeriodDonorAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodDonorStakeAmounts(uint256,address)":{inputs:[{internalType:"uint256",name:"_period",type:"uint256"},{internalType:"address",name:"_donor",type:"address"}],name:"rewardPeriodDonorStakeAmounts",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodSize()":{inputs:[],name:"rewardPeriodSize",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriods(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"rewardPeriods",outputs:[{internalType:"uint256",name:"rewardPerBlock",type:"uint256"},{internalType:"uint256",name:"rewardAmount",type:"uint256"},{internalType:"uint256",name:"startBlock",type:"uint256"},{internalType:"uint256",name:"endBlock",type:"uint256"},{internalType:"uint256",name:"donationsAmount",type:"uint256"},{internalType:"uint256",name:"againstPeriods",type:"uint256"},{internalType:"uint256",name:"stakesAmount",type:"uint256"},{internalType:"uint256",name:"stakingDonationRatio",type:"uint256"}],stateMutability:"view",type:"function"},"setStakingAmounts(address,uint256,uint256)":{inputs:[{internalType:"address",name:"_holderAddress",type:"address"},{internalType:"uint256",name:"_holderStakeAmount",type:"uint256"},{internalType:"uint256",name:"_totalStakesAmount",type:"uint256"}],name:"setStakingAmounts",outputs:[],stateMutability:"nonpayable",type:"function"},"stakeRewards()":{inputs:[],name:"stakeRewards",outputs:[],stateMutability:"nonpayable",type:"function"},"stakeRewardsPartial(uint256)":{inputs:[{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"stakeRewardsPartial",outputs:[],stateMutability:"nonpayable",type:"function"},"staking()":{inputs:[],name:"staking",outputs:[{internalType:"contract IStaking",name:"",type:"address"}],stateMutability:"view",type:"function"},"stakingDonationRatio()":{inputs:[],name:"stakingDonationRatio",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"contract ITreasury",name:"",type:"address"}],stateMutability:"view",type:"function"},"updateAgainstPeriods(uint256)":{inputs:[{internalType:"uint256",name:"_newAgainstPeriods",type:"uint256"}],name:"updateAgainstPeriods",outputs:[],stateMutability:"nonpayable",type:"function"},"updateClaimDelay(uint256)":{inputs:[{internalType:"uint256",name:"_newClaimDelay",type:"uint256"}],name:"updateClaimDelay",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityDonationRatio(uint256)":{inputs:[{internalType:"uint256",name:"_newCommunityDonationRatio",type:"uint256"}],name:"updateCommunityDonationRatio",outputs:[],stateMutability:"nonpayable",type:"function"},"updateRewardPeriodParams(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_newRewardPeriodSize",type:"uint256"},{internalType:"uint256",name:"_newDecayNumerator",type:"uint256"},{internalType:"uint256",name:"_newDecayDenominator",type:"uint256"}],name:"updateRewardPeriodParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateStaking(address)":{inputs:[{internalType:"contract IStaking",name:"_newStaking",type:"address"}],name:"updateStaking",outputs:[],stateMutability:"nonpayable",type:"function"},"updateStakingDonationRatio(uint256)":{inputs:[{internalType:"uint256",name:"_newStakingDonationRatio",type:"uint256"}],name:"updateStakingDonationRatio",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasury(address)":{inputs:[{internalType:"contract ITreasury",name:"_newTreasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/donationMiner/interfaces/DonationMinerStorageV2.sol:DonationMinerStorageV2":{source:"contracts/donationMiner/interfaces/DonationMinerStorageV2.sol",name:"DonationMinerStorageV2",title:"Storage for DonationMiner",notice:"For future upgrades, do not change DonationMinerStorageV2. Create a new contract which implements DonationMinerStorageV2 and following the naming convention DonationMinerStorageVX.",methods:{"PACT()":{inputs:[],name:"PACT",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"againstPeriods()":{inputs:[],name:"againstPeriods",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"apr(address)":{inputs:[{internalType:"address",name:"_stakeholderAddress",type:"address"}],name:"apr",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"calculateClaimableRewards(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"calculateClaimableRewards",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"calculateClaimableRewardsByPeriodNumber(address,uint256)":{inputs:[{internalType:"address",name:"_donor",type:"address"},{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"calculateClaimableRewardsByPeriodNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"claimDelay()":{inputs:[],name:"claimDelay",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimRewards()":{inputs:[],name:"claimRewards",outputs:[],stateMutability:"nonpayable",type:"function"},"claimRewardsPartial(uint256)":{inputs:[{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"claimRewardsPartial",outputs:[],stateMutability:"nonpayable",type:"function"},"communityDonationRatio()":{inputs:[],name:"communityDonationRatio",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"currentRewardPeriodNumber()":{inputs:[],name:"currentRewardPeriodNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decayDenominator()":{inputs:[],name:"decayDenominator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decayNumerator()":{inputs:[],name:"decayNumerator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donate(address,uint256,address)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"},{internalType:"address",name:"_delegateAddress",type:"address"}],name:"donate",outputs:[],stateMutability:"nonpayable",type:"function"},"donateToCommunity(address,address,uint256,address)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"},{internalType:"address",name:"_delegateAddress",type:"address"}],name:"donateToCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"donationCount()":{inputs:[],name:"donationCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donations(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"donations",outputs:[{internalType:"address",name:"donor",type:"address"},{internalType:"address",name:"target",type:"address"},{internalType:"uint256",name:"rewardPeriod",type:"uint256"},{internalType:"uint256",name:"blockNumber",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"contract IERC20Upgradeable",name:"token",type:"address"},{internalType:"uint256",name:"initialAmount",type:"uint256"}],stateMutability:"view",type:"function"},"donorRewardPeriod(address,uint256)":{inputs:[{internalType:"address",name:"_donor",type:"address"},{internalType:"uint256",name:"_rewardPeriodIndex",type:"uint256"}],name:"donorRewardPeriod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donors(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"donors",outputs:[{internalType:"uint256",name:"lastClaim",type:"uint256"},{internalType:"uint256",name:"rewardPeriodsCount",type:"uint256"},{internalType:"uint256",name:"lastClaimPeriod",type:"uint256"}],stateMutability:"view",type:"function"},"estimateClaimableReward(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"estimateClaimableReward",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"estimateClaimableRewardAdvance(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"estimateClaimableRewardAdvance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"estimateClaimableRewardByStaking(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"estimateClaimableRewardByStaking",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"generalApr()":{inputs:[],name:"generalApr",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"lastPeriodsDonations(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"lastPeriodsDonations",outputs:[{internalType:"uint256",name:"donorAmount",type:"uint256"},{internalType:"uint256",name:"totalAmount",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodCount()":{inputs:[],name:"rewardPeriodCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodDonorAmount(uint256,address)":{inputs:[{internalType:"uint256",name:"_period",type:"uint256"},{internalType:"address",name:"_donor",type:"address"}],name:"rewardPeriodDonorAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodDonorStakeAmounts(uint256,address)":{inputs:[{internalType:"uint256",name:"_period",type:"uint256"},{internalType:"address",name:"_donor",type:"address"}],name:"rewardPeriodDonorStakeAmounts",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodSize()":{inputs:[],name:"rewardPeriodSize",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriods(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"rewardPeriods",outputs:[{internalType:"uint256",name:"rewardPerBlock",type:"uint256"},{internalType:"uint256",name:"rewardAmount",type:"uint256"},{internalType:"uint256",name:"startBlock",type:"uint256"},{internalType:"uint256",name:"endBlock",type:"uint256"},{internalType:"uint256",name:"donationsAmount",type:"uint256"},{internalType:"uint256",name:"againstPeriods",type:"uint256"},{internalType:"uint256",name:"stakesAmount",type:"uint256"},{internalType:"uint256",name:"stakingDonationRatio",type:"uint256"}],stateMutability:"view",type:"function"},"setStakingAmounts(address,uint256,uint256)":{inputs:[{internalType:"address",name:"_holderAddress",type:"address"},{internalType:"uint256",name:"_holderStakeAmount",type:"uint256"},{internalType:"uint256",name:"_totalStakesAmount",type:"uint256"}],name:"setStakingAmounts",outputs:[],stateMutability:"nonpayable",type:"function"},"stakeRewards()":{inputs:[],name:"stakeRewards",outputs:[],stateMutability:"nonpayable",type:"function"},"stakeRewardsPartial(uint256)":{inputs:[{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"stakeRewardsPartial",outputs:[],stateMutability:"nonpayable",type:"function"},"staking()":{inputs:[],name:"staking",outputs:[{internalType:"contract IStaking",name:"",type:"address"}],stateMutability:"view",type:"function"},"stakingDonationRatio()":{inputs:[],name:"stakingDonationRatio",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"contract ITreasury",name:"",type:"address"}],stateMutability:"view",type:"function"},"updateAgainstPeriods(uint256)":{inputs:[{internalType:"uint256",name:"_newAgainstPeriods",type:"uint256"}],name:"updateAgainstPeriods",outputs:[],stateMutability:"nonpayable",type:"function"},"updateClaimDelay(uint256)":{inputs:[{internalType:"uint256",name:"_newClaimDelay",type:"uint256"}],name:"updateClaimDelay",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityDonationRatio(uint256)":{inputs:[{internalType:"uint256",name:"_newCommunityDonationRatio",type:"uint256"}],name:"updateCommunityDonationRatio",outputs:[],stateMutability:"nonpayable",type:"function"},"updateRewardPeriodParams(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_newRewardPeriodSize",type:"uint256"},{internalType:"uint256",name:"_newDecayNumerator",type:"uint256"},{internalType:"uint256",name:"_newDecayDenominator",type:"uint256"}],name:"updateRewardPeriodParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateStaking(address)":{inputs:[{internalType:"contract IStaking",name:"_newStaking",type:"address"}],name:"updateStaking",outputs:[],stateMutability:"nonpayable",type:"function"},"updateStakingDonationRatio(uint256)":{inputs:[{internalType:"uint256",name:"_newStakingDonationRatio",type:"uint256"}],name:"updateStakingDonationRatio",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasury(address)":{inputs:[{internalType:"contract ITreasury",name:"_newTreasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/donationMiner/interfaces/DonationMinerStorageV3.sol:DonationMinerStorageV3":{source:"contracts/donationMiner/interfaces/DonationMinerStorageV3.sol",name:"DonationMinerStorageV3",title:"Storage for DonationMiner",notice:"For future upgrades, do not change DonationMinerStorageV3. Create a new contract which implements DonationMinerStorageV3 and following the naming convention DonationMinerStorageVX.",methods:{"PACT()":{inputs:[],name:"PACT",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"againstPeriods()":{inputs:[],name:"againstPeriods",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"apr(address)":{inputs:[{internalType:"address",name:"_stakeholderAddress",type:"address"}],name:"apr",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"calculateClaimableRewards(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"calculateClaimableRewards",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"calculateClaimableRewardsByPeriodNumber(address,uint256)":{inputs:[{internalType:"address",name:"_donor",type:"address"},{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"calculateClaimableRewardsByPeriodNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"claimDelay()":{inputs:[],name:"claimDelay",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimRewards()":{inputs:[],name:"claimRewards",outputs:[],stateMutability:"nonpayable",type:"function"},"claimRewardsPartial(uint256)":{inputs:[{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"claimRewardsPartial",outputs:[],stateMutability:"nonpayable",type:"function"},"communityDonationRatio()":{inputs:[],name:"communityDonationRatio",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"currentRewardPeriodNumber()":{inputs:[],name:"currentRewardPeriodNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decayDenominator()":{inputs:[],name:"decayDenominator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decayNumerator()":{inputs:[],name:"decayNumerator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donate(address,uint256,address)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"},{internalType:"address",name:"_delegateAddress",type:"address"}],name:"donate",outputs:[],stateMutability:"nonpayable",type:"function"},"donateToCommunity(address,address,uint256,address)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"},{internalType:"address",name:"_delegateAddress",type:"address"}],name:"donateToCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"donationCount()":{inputs:[],name:"donationCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donations(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"donations",outputs:[{internalType:"address",name:"donor",type:"address"},{internalType:"address",name:"target",type:"address"},{internalType:"uint256",name:"rewardPeriod",type:"uint256"},{internalType:"uint256",name:"blockNumber",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"contract IERC20Upgradeable",name:"token",type:"address"},{internalType:"uint256",name:"initialAmount",type:"uint256"}],stateMutability:"view",type:"function"},"donorRewardPeriod(address,uint256)":{inputs:[{internalType:"address",name:"_donor",type:"address"},{internalType:"uint256",name:"_rewardPeriodIndex",type:"uint256"}],name:"donorRewardPeriod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donors(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"donors",outputs:[{internalType:"uint256",name:"lastClaim",type:"uint256"},{internalType:"uint256",name:"rewardPeriodsCount",type:"uint256"},{internalType:"uint256",name:"lastClaimPeriod",type:"uint256"}],stateMutability:"view",type:"function"},"estimateClaimableReward(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"estimateClaimableReward",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"estimateClaimableRewardAdvance(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"estimateClaimableRewardAdvance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"estimateClaimableRewardByStaking(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"estimateClaimableRewardByStaking",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"generalApr()":{inputs:[],name:"generalApr",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"lastPeriodsDonations(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"lastPeriodsDonations",outputs:[{internalType:"uint256",name:"donorAmount",type:"uint256"},{internalType:"uint256",name:"totalAmount",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodCount()":{inputs:[],name:"rewardPeriodCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodDonorAmount(uint256,address)":{inputs:[{internalType:"uint256",name:"_period",type:"uint256"},{internalType:"address",name:"_donor",type:"address"}],name:"rewardPeriodDonorAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodDonorStakeAmounts(uint256,address)":{inputs:[{internalType:"uint256",name:"_period",type:"uint256"},{internalType:"address",name:"_donor",type:"address"}],name:"rewardPeriodDonorStakeAmounts",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodSize()":{inputs:[],name:"rewardPeriodSize",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriods(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"rewardPeriods",outputs:[{internalType:"uint256",name:"rewardPerBlock",type:"uint256"},{internalType:"uint256",name:"rewardAmount",type:"uint256"},{internalType:"uint256",name:"startBlock",type:"uint256"},{internalType:"uint256",name:"endBlock",type:"uint256"},{internalType:"uint256",name:"donationsAmount",type:"uint256"},{internalType:"uint256",name:"againstPeriods",type:"uint256"},{internalType:"uint256",name:"stakesAmount",type:"uint256"},{internalType:"uint256",name:"stakingDonationRatio",type:"uint256"}],stateMutability:"view",type:"function"},"setStakingAmounts(address,uint256,uint256)":{inputs:[{internalType:"address",name:"_holderAddress",type:"address"},{internalType:"uint256",name:"_holderStakeAmount",type:"uint256"},{internalType:"uint256",name:"_totalStakesAmount",type:"uint256"}],name:"setStakingAmounts",outputs:[],stateMutability:"nonpayable",type:"function"},"stakeRewards()":{inputs:[],name:"stakeRewards",outputs:[],stateMutability:"nonpayable",type:"function"},"stakeRewardsPartial(uint256)":{inputs:[{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"stakeRewardsPartial",outputs:[],stateMutability:"nonpayable",type:"function"},"staking()":{inputs:[],name:"staking",outputs:[{internalType:"contract IStaking",name:"",type:"address"}],stateMutability:"view",type:"function"},"stakingDonationRatio()":{inputs:[],name:"stakingDonationRatio",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"contract ITreasury",name:"",type:"address"}],stateMutability:"view",type:"function"},"updateAgainstPeriods(uint256)":{inputs:[{internalType:"uint256",name:"_newAgainstPeriods",type:"uint256"}],name:"updateAgainstPeriods",outputs:[],stateMutability:"nonpayable",type:"function"},"updateClaimDelay(uint256)":{inputs:[{internalType:"uint256",name:"_newClaimDelay",type:"uint256"}],name:"updateClaimDelay",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityDonationRatio(uint256)":{inputs:[{internalType:"uint256",name:"_newCommunityDonationRatio",type:"uint256"}],name:"updateCommunityDonationRatio",outputs:[],stateMutability:"nonpayable",type:"function"},"updateRewardPeriodParams(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_newRewardPeriodSize",type:"uint256"},{internalType:"uint256",name:"_newDecayNumerator",type:"uint256"},{internalType:"uint256",name:"_newDecayDenominator",type:"uint256"}],name:"updateRewardPeriodParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateStaking(address)":{inputs:[{internalType:"contract IStaking",name:"_newStaking",type:"address"}],name:"updateStaking",outputs:[],stateMutability:"nonpayable",type:"function"},"updateStakingDonationRatio(uint256)":{inputs:[{internalType:"uint256",name:"_newStakingDonationRatio",type:"uint256"}],name:"updateStakingDonationRatio",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasury(address)":{inputs:[{internalType:"contract ITreasury",name:"_newTreasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/donationMiner/interfaces/DonationMinerStorageV4.sol:DonationMinerStorageV4":{source:"contracts/donationMiner/interfaces/DonationMinerStorageV4.sol",name:"DonationMinerStorageV4",title:"Storage for DonationMiner",notice:"For future upgrades, do not change DonationMinerStorageV4. Create a new contract which implements DonationMinerStorageV4 and following the naming convention DonationMinerStorageVX.",methods:{"PACT()":{inputs:[],name:"PACT",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"againstPeriods()":{inputs:[],name:"againstPeriods",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"apr(address)":{inputs:[{internalType:"address",name:"_stakeholderAddress",type:"address"}],name:"apr",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"calculateClaimableRewards(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"calculateClaimableRewards",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"calculateClaimableRewardsByPeriodNumber(address,uint256)":{inputs:[{internalType:"address",name:"_donor",type:"address"},{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"calculateClaimableRewardsByPeriodNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"claimDelay()":{inputs:[],name:"claimDelay",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimRewards()":{inputs:[],name:"claimRewards",outputs:[],stateMutability:"nonpayable",type:"function"},"claimRewardsPartial(uint256)":{inputs:[{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"claimRewardsPartial",outputs:[],stateMutability:"nonpayable",type:"function"},"communityDonationRatio()":{inputs:[],name:"communityDonationRatio",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"currentRewardPeriodNumber()":{inputs:[],name:"currentRewardPeriodNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decayDenominator()":{inputs:[],name:"decayDenominator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decayNumerator()":{inputs:[],name:"decayNumerator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donate(address,uint256,address)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"},{internalType:"address",name:"_delegateAddress",type:"address"}],name:"donate",outputs:[],stateMutability:"nonpayable",type:"function"},"donateToCommunity(address,address,uint256,address)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"},{internalType:"address",name:"_delegateAddress",type:"address"}],name:"donateToCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"donationCount()":{inputs:[],name:"donationCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donations(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"donations",outputs:[{internalType:"address",name:"donor",type:"address"},{internalType:"address",name:"target",type:"address"},{internalType:"uint256",name:"rewardPeriod",type:"uint256"},{internalType:"uint256",name:"blockNumber",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"contract IERC20Upgradeable",name:"token",type:"address"},{internalType:"uint256",name:"initialAmount",type:"uint256"}],stateMutability:"view",type:"function"},"donorRewardPeriod(address,uint256)":{inputs:[{internalType:"address",name:"_donor",type:"address"},{internalType:"uint256",name:"_rewardPeriodIndex",type:"uint256"}],name:"donorRewardPeriod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donors(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"donors",outputs:[{internalType:"uint256",name:"lastClaim",type:"uint256"},{internalType:"uint256",name:"rewardPeriodsCount",type:"uint256"},{internalType:"uint256",name:"lastClaimPeriod",type:"uint256"}],stateMutability:"view",type:"function"},"estimateClaimableReward(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"estimateClaimableReward",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"estimateClaimableRewardAdvance(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"estimateClaimableRewardAdvance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"estimateClaimableRewardByStaking(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"estimateClaimableRewardByStaking",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"generalApr()":{inputs:[],name:"generalApr",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"lastPeriodsDonations(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"lastPeriodsDonations",outputs:[{internalType:"uint256",name:"donorAmount",type:"uint256"},{internalType:"uint256",name:"totalAmount",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodCount()":{inputs:[],name:"rewardPeriodCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodDonorAmount(uint256,address)":{inputs:[{internalType:"uint256",name:"_period",type:"uint256"},{internalType:"address",name:"_donor",type:"address"}],name:"rewardPeriodDonorAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodDonorStakeAmounts(uint256,address)":{inputs:[{internalType:"uint256",name:"_period",type:"uint256"},{internalType:"address",name:"_donor",type:"address"}],name:"rewardPeriodDonorStakeAmounts",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodSize()":{inputs:[],name:"rewardPeriodSize",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriods(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"rewardPeriods",outputs:[{internalType:"uint256",name:"rewardPerBlock",type:"uint256"},{internalType:"uint256",name:"rewardAmount",type:"uint256"},{internalType:"uint256",name:"startBlock",type:"uint256"},{internalType:"uint256",name:"endBlock",type:"uint256"},{internalType:"uint256",name:"donationsAmount",type:"uint256"},{internalType:"uint256",name:"againstPeriods",type:"uint256"},{internalType:"uint256",name:"stakesAmount",type:"uint256"},{internalType:"uint256",name:"stakingDonationRatio",type:"uint256"}],stateMutability:"view",type:"function"},"setStakingAmounts(address,uint256,uint256)":{inputs:[{internalType:"address",name:"_holderAddress",type:"address"},{internalType:"uint256",name:"_holderStakeAmount",type:"uint256"},{internalType:"uint256",name:"_totalStakesAmount",type:"uint256"}],name:"setStakingAmounts",outputs:[],stateMutability:"nonpayable",type:"function"},"stakeRewards()":{inputs:[],name:"stakeRewards",outputs:[],stateMutability:"nonpayable",type:"function"},"stakeRewardsPartial(uint256)":{inputs:[{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"stakeRewardsPartial",outputs:[],stateMutability:"nonpayable",type:"function"},"staking()":{inputs:[],name:"staking",outputs:[{internalType:"contract IStaking",name:"",type:"address"}],stateMutability:"view",type:"function"},"stakingDonationRatio()":{inputs:[],name:"stakingDonationRatio",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"contract ITreasury",name:"",type:"address"}],stateMutability:"view",type:"function"},"updateAgainstPeriods(uint256)":{inputs:[{internalType:"uint256",name:"_newAgainstPeriods",type:"uint256"}],name:"updateAgainstPeriods",outputs:[],stateMutability:"nonpayable",type:"function"},"updateClaimDelay(uint256)":{inputs:[{internalType:"uint256",name:"_newClaimDelay",type:"uint256"}],name:"updateClaimDelay",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityDonationRatio(uint256)":{inputs:[{internalType:"uint256",name:"_newCommunityDonationRatio",type:"uint256"}],name:"updateCommunityDonationRatio",outputs:[],stateMutability:"nonpayable",type:"function"},"updateRewardPeriodParams(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_newRewardPeriodSize",type:"uint256"},{internalType:"uint256",name:"_newDecayNumerator",type:"uint256"},{internalType:"uint256",name:"_newDecayDenominator",type:"uint256"}],name:"updateRewardPeriodParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateStaking(address)":{inputs:[{internalType:"contract IStaking",name:"_newStaking",type:"address"}],name:"updateStaking",outputs:[],stateMutability:"nonpayable",type:"function"},"updateStakingDonationRatio(uint256)":{inputs:[{internalType:"uint256",name:"_newStakingDonationRatio",type:"uint256"}],name:"updateStakingDonationRatio",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasury(address)":{inputs:[{internalType:"contract ITreasury",name:"_newTreasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/donationMiner/interfaces/IDonationMiner.sol:IDonationMiner":{source:"contracts/donationMiner/interfaces/IDonationMiner.sol",name:"IDonationMiner",methods:{"PACT()":{inputs:[],name:"PACT",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"againstPeriods()":{inputs:[],name:"againstPeriods",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"apr(address)":{inputs:[{internalType:"address",name:"_stakeholderAddress",type:"address"}],name:"apr",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"calculateClaimableRewards(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"calculateClaimableRewards",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"calculateClaimableRewardsByPeriodNumber(address,uint256)":{inputs:[{internalType:"address",name:"_donor",type:"address"},{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"calculateClaimableRewardsByPeriodNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"claimDelay()":{inputs:[],name:"claimDelay",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimRewards()":{inputs:[],name:"claimRewards",outputs:[],stateMutability:"nonpayable",type:"function"},"claimRewardsPartial(uint256)":{inputs:[{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"claimRewardsPartial",outputs:[],stateMutability:"nonpayable",type:"function"},"communityDonationRatio()":{inputs:[],name:"communityDonationRatio",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"currentRewardPeriodNumber()":{inputs:[],name:"currentRewardPeriodNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decayDenominator()":{inputs:[],name:"decayDenominator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decayNumerator()":{inputs:[],name:"decayNumerator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donate(address,uint256,address)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"},{internalType:"address",name:"_delegateAddress",type:"address"}],name:"donate",outputs:[],stateMutability:"nonpayable",type:"function"},"donateToCommunity(address,address,uint256,address)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"},{internalType:"address",name:"_delegateAddress",type:"address"}],name:"donateToCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"donationCount()":{inputs:[],name:"donationCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donations(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"donations",outputs:[{internalType:"address",name:"donor",type:"address"},{internalType:"address",name:"target",type:"address"},{internalType:"uint256",name:"rewardPeriod",type:"uint256"},{internalType:"uint256",name:"blockNumber",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"contract IERC20Upgradeable",name:"token",type:"address"},{internalType:"uint256",name:"initialAmount",type:"uint256"}],stateMutability:"view",type:"function"},"donorRewardPeriod(address,uint256)":{inputs:[{internalType:"address",name:"_donor",type:"address"},{internalType:"uint256",name:"_rewardPeriodIndex",type:"uint256"}],name:"donorRewardPeriod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donors(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"donors",outputs:[{internalType:"uint256",name:"rewardPeriodsCount",type:"uint256"},{internalType:"uint256",name:"lastClaim",type:"uint256"},{internalType:"uint256",name:"lastClaimPeriod",type:"uint256"}],stateMutability:"view",type:"function"},"estimateClaimableReward(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"estimateClaimableReward",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"estimateClaimableRewardAdvance(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"estimateClaimableRewardAdvance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"estimateClaimableRewardByStaking(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"estimateClaimableRewardByStaking",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"generalApr()":{inputs:[],name:"generalApr",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"lastPeriodsDonations(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"lastPeriodsDonations",outputs:[{internalType:"uint256",name:"donorAmount",type:"uint256"},{internalType:"uint256",name:"totalAmount",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodCount()":{inputs:[],name:"rewardPeriodCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodDonorAmount(uint256,address)":{inputs:[{internalType:"uint256",name:"_period",type:"uint256"},{internalType:"address",name:"_donor",type:"address"}],name:"rewardPeriodDonorAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodDonorStakeAmounts(uint256,address)":{inputs:[{internalType:"uint256",name:"_period",type:"uint256"},{internalType:"address",name:"_donor",type:"address"}],name:"rewardPeriodDonorStakeAmounts",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodSize()":{inputs:[],name:"rewardPeriodSize",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriods(uint256)":{inputs:[{internalType:"uint256",name:"_period",type:"uint256"}],name:"rewardPeriods",outputs:[{internalType:"uint256",name:"rewardPerBlock",type:"uint256"},{internalType:"uint256",name:"rewardAmount",type:"uint256"},{internalType:"uint256",name:"startBlock",type:"uint256"},{internalType:"uint256",name:"endBlock",type:"uint256"},{internalType:"uint256",name:"donationsAmount",type:"uint256"},{internalType:"uint256",name:"againstPeriods",type:"uint256"},{internalType:"uint256",name:"stakesAmount",type:"uint256"},{internalType:"uint256",name:"stakingDonationRatio",type:"uint256"}],stateMutability:"view",type:"function"},"setStakingAmounts(address,uint256,uint256)":{inputs:[{internalType:"address",name:"_holderAddress",type:"address"},{internalType:"uint256",name:"_holderStakeAmount",type:"uint256"},{internalType:"uint256",name:"_totalStakesAmount",type:"uint256"}],name:"setStakingAmounts",outputs:[],stateMutability:"nonpayable",type:"function"},"stakeRewards()":{inputs:[],name:"stakeRewards",outputs:[],stateMutability:"nonpayable",type:"function"},"stakeRewardsPartial(uint256)":{inputs:[{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"stakeRewardsPartial",outputs:[],stateMutability:"nonpayable",type:"function"},"staking()":{inputs:[],name:"staking",outputs:[{internalType:"contract IStaking",name:"",type:"address"}],stateMutability:"view",type:"function"},"stakingDonationRatio()":{inputs:[],name:"stakingDonationRatio",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"contract ITreasury",name:"",type:"address"}],stateMutability:"view",type:"function"},"updateAgainstPeriods(uint256)":{inputs:[{internalType:"uint256",name:"_newAgainstPeriods",type:"uint256"}],name:"updateAgainstPeriods",outputs:[],stateMutability:"nonpayable",type:"function"},"updateClaimDelay(uint256)":{inputs:[{internalType:"uint256",name:"_newClaimDelay",type:"uint256"}],name:"updateClaimDelay",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityDonationRatio(uint256)":{inputs:[{internalType:"uint256",name:"_newCommunityDonationRatio",type:"uint256"}],name:"updateCommunityDonationRatio",outputs:[],stateMutability:"nonpayable",type:"function"},"updateRewardPeriodParams(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_newRewardPeriodSize",type:"uint256"},{internalType:"uint256",name:"_newDecayNumerator",type:"uint256"},{internalType:"uint256",name:"_newDecayDenominator",type:"uint256"}],name:"updateRewardPeriodParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateStaking(address)":{inputs:[{internalType:"contract IStaking",name:"_newStaking",type:"address"}],name:"updateStaking",outputs:[],stateMutability:"nonpayable",type:"function"},"updateStakingDonationRatio(uint256)":{inputs:[{internalType:"uint256",name:"_newStakingDonationRatio",type:"uint256"}],name:"updateStakingDonationRatio",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasury(address)":{inputs:[{internalType:"contract ITreasury",name:"_newTreasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/externalInterfaces/aave/DataTypes.sol:DataTypes":{source:"contracts/externalInterfaces/aave/DataTypes.sol",name:"DataTypes"},"contracts/externalInterfaces/aave/IAToken.sol:IAToken":{source:"contracts/externalInterfaces/aave/IAToken.sol",name:"IAToken",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"BalanceTransfer(address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"},{indexed:!1,internalType:"uint256",name:"index",type:"uint256"}],name:"BalanceTransfer",type:"event",details:"Emitted during the transfer action",params:{from:"The user whose tokens are being transferred",index:"The new liquidity index of the reserve*",to:"The recipient",value:"The amount being transferred"}},"Burn(address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"target",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"},{indexed:!1,internalType:"uint256",name:"index",type:"uint256"}],name:"Burn",type:"event",details:"Emitted after aTokens are burned",params:{from:"The owner of the aTokens, getting them burned",index:"The new liquidity index of the reserve*",target:"The address that will receive the underlying",value:"The amount being burned"}},"Initialized(address,address,address,address,uint8,string,string,bytes)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"underlyingAsset",type:"address"},{indexed:!0,internalType:"address",name:"pool",type:"address"},{indexed:!1,internalType:"address",name:"treasury",type:"address"},{indexed:!1,internalType:"address",name:"incentivesController",type:"address"},{indexed:!1,internalType:"uint8",name:"aTokenDecimals",type:"uint8"},{indexed:!1,internalType:"string",name:"aTokenName",type:"string"},{indexed:!1,internalType:"string",name:"aTokenSymbol",type:"string"},{indexed:!1,internalType:"bytes",name:"params",type:"bytes"}],name:"Initialized",type:"event"},"Mint(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"},{indexed:!1,internalType:"uint256",name:"index",type:"uint256"}],name:"Mint",type:"event",details:"Emitted after the mint action",params:{from:"The address performing the mint",index:"The new liquidity index of the reserve*",value:"The amount being"}},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"UNDERLYING_ASSET_ADDRESS()":{inputs:[],name:"UNDERLYING_ASSET_ADDRESS",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)*"},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"burn(address,address,uint256,uint256)":{inputs:[{internalType:"address",name:"user",type:"address"},{internalType:"address",name:"receiverOfUnderlying",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"index",type:"uint256"}],name:"burn",outputs:[],stateMutability:"nonpayable",type:"function",details:"Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`",params:{amount:"The amount being burned",index:"The new liquidity index of the reserve*",receiverOfUnderlying:"The address that will receive the underlying",user:"The owner of the aTokens, getting them burned"}},"getIncentivesController()":{inputs:[],name:"getIncentivesController",outputs:[{internalType:"contract IAaveIncentivesController",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the incentives controller contract*"},"getScaledUserBalanceAndSupply(address)":{inputs:[{internalType:"address",name:"user",type:"address"}],name:"getScaledUserBalanceAndSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the scaled balance of the user and the scaled total supply.",params:{user:"The address of the user"},returns:{_0:"The scaled balance of the user",_1:"The scaled balance and the scaled total supply*"}},"handleRepayment(address,uint256)":{inputs:[{internalType:"address",name:"user",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"handleRepayment",outputs:[],stateMutability:"nonpayable",type:"function",details:"Invoked to execute actions on the aToken side after a repayment.",params:{amount:"The amount getting repaid*",user:"The user executing the repayment"}},"initialize(address,address,address,address,uint8,string,string,bytes)":{inputs:[{internalType:"contract ILendingPool",name:"pool",type:"address"},{internalType:"address",name:"treasury",type:"address"},{internalType:"address",name:"underlyingAsset",type:"address"},{internalType:"contract IAaveIncentivesController",name:"incentivesController",type:"address"},{internalType:"uint8",name:"aTokenDecimals",type:"uint8"},{internalType:"string",name:"aTokenName",type:"string"},{internalType:"string",name:"aTokenSymbol",type:"string"},{internalType:"bytes",name:"params",type:"bytes"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"Initializes the aToken",params:{aTokenDecimals:"The decimals of the aToken, same as the underlying asset's",aTokenName:"The name of the aToken",aTokenSymbol:"The symbol of the aToken",incentivesController:"The smart contract managing potential incentives distribution",pool:"The address of the lending pool where this aToken will be used",treasury:"The address of the Aave treasury, receiving the fees on this aToken",underlyingAsset:"The address of the underlying asset of this aToken (E.g. WETH for aWETH)"}},"mint(address,uint256,uint256)":{inputs:[{internalType:"address",name:"user",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"index",type:"uint256"}],name:"mint",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Mints `amount` aTokens to `user`",params:{amount:"The amount of tokens getting minted",index:"The new liquidity index of the reserve",user:"The address receiving the minted tokens"},returns:{_0:"`true` if the the previous balance of the user was 0"}},"mintToTreasury(uint256,uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"index",type:"uint256"}],name:"mintToTreasury",outputs:[],stateMutability:"nonpayable",type:"function",details:"Mints aTokens to the reserve treasury",params:{amount:"The amount of tokens getting minted",index:"The new liquidity index of the reserve"}},"scaledBalanceOf(address)":{inputs:[{internalType:"address",name:"user",type:"address"}],name:"scaledBalanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the scaled balance of the user. The scaled balance is the sum of all the updated stored balance divided by the reserve's liquidity index at the moment of the update",params:{user:"The user whose balance is calculated"},returns:{_0:"The scaled balance of the user*"}},"scaledTotalSupply()":{inputs:[],name:"scaledTotalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the scaled total supply of the variable debt token. Represents sum(debt/index)",returns:{_0:"The scaled total supply*"}},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferOnLiquidation(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"transferOnLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken",params:{from:"The address getting liquidated, current owner of the aTokens",to:"The recipient",value:"The amount of tokens getting transferred*"}},"transferUnderlyingTo(address,uint256)":{inputs:[{internalType:"address",name:"user",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferUnderlyingTo",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"Transfers the underlying asset to `target`. Used by the LendingPool to transfer assets in borrow(), withdraw() and flashLoan()",params:{amount:"The amount getting transferred",user:"The recipient of the underlying"},returns:{_0:"The amount transferred*"}}}},"contracts/externalInterfaces/aave/IAaveIncentivesController.sol:IAaveIncentivesController":{source:"contracts/externalInterfaces/aave/IAaveIncentivesController.sol",name:"IAaveIncentivesController",events:{"ClaimerSet(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!0,internalType:"address",name:"claimer",type:"address"}],name:"ClaimerSet",type:"event"},"RewardsAccrued(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"RewardsAccrued",type:"event"},"RewardsClaimed(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"RewardsClaimed",type:"event"},"RewardsClaimed(address,address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"address",name:"claimer",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"RewardsClaimed",type:"event"}},methods:{"DISTRIBUTION_END()":{inputs:[],name:"DISTRIBUTION_END",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Gets the distribution end timestamp of the emissions"},"PRECISION()":{inputs:[],name:"PRECISION",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"for backward compatibility with previous implementation of the Incentives controller"},"REWARD_TOKEN()":{inputs:[],name:"REWARD_TOKEN",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"for backward compatibility with previous implementation of the Incentives controller"},"assets(address)":{inputs:[{internalType:"address",name:"asset",type:"address"}],name:"assets",outputs:[{internalType:"uint128",name:"",type:"uint128"},{internalType:"uint128",name:"",type:"uint128"},{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimRewards(address[],uint256,address)":{inputs:[{internalType:"address[]",name:"assets",type:"address[]"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"address",name:"to",type:"address"}],name:"claimRewards",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards",params:{amount:"Amount of rewards to claim",to:"Address that will be receiving the rewards"},returns:{_0:"Rewards claimed*"}},"claimRewardsOnBehalf(address[],uint256,address,address)":{inputs:[{internalType:"address[]",name:"assets",type:"address[]"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"address",name:"user",type:"address"},{internalType:"address",name:"to",type:"address"}],name:"claimRewardsOnBehalf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:'Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must be whitelisted via "allowClaimOnBehalf" function by the RewardsAdmin role manager',params:{amount:"Amount of rewards to claim",to:"Address that will be receiving the rewards",user:"Address to check and claim rewards"},returns:{_0:"Rewards claimed*"}},"configureAssets(address[],uint256[])":{inputs:[{internalType:"address[]",name:"assets",type:"address[]"},{internalType:"uint256[]",name:"emissionsPerSecond",type:"uint256[]"}],name:"configureAssets",outputs:[],stateMutability:"nonpayable",type:"function",details:"Configure assets for a certain rewards emission",params:{assets:"The assets to incentivize",emissionsPerSecond:"The emission for each asset"}},"getAssetData(address)":{inputs:[{internalType:"address",name:"asset",type:"address"}],name:"getAssetData",outputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getClaimer(address)":{inputs:[{internalType:"address",name:"user",type:"address"}],name:"getClaimer",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the whitelisted claimer for a certain address (0x0 if not set)",params:{user:"The address of the user"},returns:{_0:"The claimer address"}},"getRewardsBalance(address[],address)":{inputs:[{internalType:"address[]",name:"assets",type:"address[]"},{internalType:"address",name:"user",type:"address"}],name:"getRewardsBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the total of rewards of an user, already accrued + not yet accrued",params:{user:"The address of the user"},returns:{_0:"The rewards*"}},"getUserAssetData(address,address)":{inputs:[{internalType:"address",name:"user",type:"address"},{internalType:"address",name:"asset",type:"address"}],name:"getUserAssetData",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"returns the unclaimed rewards of the user",params:{asset:"The asset to incentivize",user:"the address of the user"},returns:{_0:"the user index for the asset"}},"getUserUnclaimedRewards(address)":{inputs:[{internalType:"address",name:"user",type:"address"}],name:"getUserUnclaimedRewards",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"returns the unclaimed rewards of the user",params:{user:"the address of the user"},returns:{_0:"the unclaimed user rewards"}},"handleAction(address,uint256,uint256)":{inputs:[{internalType:"address",name:"asset",type:"address"},{internalType:"uint256",name:"userBalance",type:"uint256"},{internalType:"uint256",name:"totalSupply",type:"uint256"}],name:"handleAction",outputs:[],stateMutability:"nonpayable",type:"function",details:"Called by the corresponding asset on any update that affects the rewards distribution",params:{asset:"The address of the user",totalSupply:"The total supply of the asset in the lending pool*",userBalance:"The balance of the user of the asset in the lending pool"}},"setClaimer(address,address)":{inputs:[{internalType:"address",name:"user",type:"address"},{internalType:"address",name:"claimer",type:"address"}],name:"setClaimer",outputs:[],stateMutability:"nonpayable",type:"function",details:"Whitelists an address to claim the rewards on behalf of another address",params:{claimer:"The address of the claimer",user:"The address of the user"}}}},"contracts/externalInterfaces/aave/IInitializableAToken.sol:IInitializableAToken":{source:"contracts/externalInterfaces/aave/IInitializableAToken.sol",name:"IInitializableAToken",title:"IInitializableAToken",author:"Aave*",notice:"Interface for the initialize function on AToken",events:{"Initialized(address,address,address,address,uint8,string,string,bytes)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"underlyingAsset",type:"address"},{indexed:!0,internalType:"address",name:"pool",type:"address"},{indexed:!1,internalType:"address",name:"treasury",type:"address"},{indexed:!1,internalType:"address",name:"incentivesController",type:"address"},{indexed:!1,internalType:"uint8",name:"aTokenDecimals",type:"uint8"},{indexed:!1,internalType:"string",name:"aTokenName",type:"string"},{indexed:!1,internalType:"string",name:"aTokenSymbol",type:"string"},{indexed:!1,internalType:"bytes",name:"params",type:"bytes"}],name:"Initialized",type:"event",details:"Emitted when an aToken is initialized",params:{aTokenDecimals:"the decimals of the underlying",aTokenName:"the name of the aToken",aTokenSymbol:"the symbol of the aToken",incentivesController:"The address of the incentives controller for this aToken",params:"A set of encoded parameters for additional initialization*",pool:"The address of the associated lending pool",treasury:"The address of the treasury",underlyingAsset:"The address of the underlying asset"}}},methods:{"initialize(address,address,address,address,uint8,string,string,bytes)":{inputs:[{internalType:"contract ILendingPool",name:"pool",type:"address"},{internalType:"address",name:"treasury",type:"address"},{internalType:"address",name:"underlyingAsset",type:"address"},{internalType:"contract IAaveIncentivesController",name:"incentivesController",type:"address"},{internalType:"uint8",name:"aTokenDecimals",type:"uint8"},{internalType:"string",name:"aTokenName",type:"string"},{internalType:"string",name:"aTokenSymbol",type:"string"},{internalType:"bytes",name:"params",type:"bytes"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"Initializes the aToken",params:{aTokenDecimals:"The decimals of the aToken, same as the underlying asset's",aTokenName:"The name of the aToken",aTokenSymbol:"The symbol of the aToken",incentivesController:"The smart contract managing potential incentives distribution",pool:"The address of the lending pool where this aToken will be used",treasury:"The address of the Aave treasury, receiving the fees on this aToken",underlyingAsset:"The address of the underlying asset of this aToken (E.g. WETH for aWETH)"}}}},"contracts/externalInterfaces/aave/ILendingPool.sol:ILendingPool":{source:"contracts/externalInterfaces/aave/ILendingPool.sol",name:"ILendingPool",events:{"Borrow(address,address,address,uint256,uint256,uint256,uint16)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"reserve",type:"address"},{indexed:!1,internalType:"address",name:"user",type:"address"},{indexed:!0,internalType:"address",name:"onBehalfOf",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"borrowRateMode",type:"uint256"},{indexed:!1,internalType:"uint256",name:"borrowRate",type:"uint256"},{indexed:!0,internalType:"uint16",name:"referral",type:"uint16"}],name:"Borrow",type:"event",details:"Emitted on borrow() and flashLoan() when debt needs to be opened",params:{amount:"The amount borrowed out",borrowRate:"The numeric rate at which the user has borrowed",borrowRateMode:"The rate mode: 1 for Stable, 2 for Variable",onBehalfOf:"The address that will be getting the debt",referral:"The referral code used*",reserve:"The address of the underlying asset being borrowed",user:"The address of the user initiating the borrow(), receiving the funds on borrow() or just initiator of the transaction on flashLoan()"}},"Deposit(address,address,address,uint256,uint16)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"reserve",type:"address"},{indexed:!1,internalType:"address",name:"user",type:"address"},{indexed:!0,internalType:"address",name:"onBehalfOf",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!0,internalType:"uint16",name:"referral",type:"uint16"}],name:"Deposit",type:"event",details:"Emitted on deposit()",params:{amount:"The amount deposited",onBehalfOf:"The beneficiary of the deposit, receiving the aTokens",referral:"The referral code used*",reserve:"The address of the underlying asset of the reserve",user:"The address initiating the deposit"}},"FlashLoan(address,address,address,uint256,uint256,uint16)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"target",type:"address"},{indexed:!0,internalType:"address",name:"initiator",type:"address"},{indexed:!0,internalType:"address",name:"asset",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"premium",type:"uint256"},{indexed:!1,internalType:"uint16",name:"referralCode",type:"uint16"}],name:"FlashLoan",type:"event",details:"Emitted on flashLoan()",params:{amount:"The amount flash borrowed",asset:"The address of the asset being flash borrowed",initiator:"The address initiating the flash loan",premium:"The fee flash borrowed",referralCode:"The referral code used*",target:"The address of the flash loan receiver contract"}},"LiquidationCall(address,address,address,uint256,uint256,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"collateralAsset",type:"address"},{indexed:!0,internalType:"address",name:"debtAsset",type:"address"},{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"debtToCover",type:"uint256"},{indexed:!1,internalType:"uint256",name:"liquidatedCollateralAmount",type:"uint256"},{indexed:!1,internalType:"address",name:"liquidator",type:"address"},{indexed:!1,internalType:"bool",name:"receiveAToken",type:"bool"}],name:"LiquidationCall",type:"event",details:"Emitted when a borrower is liquidated. This event is emitted by the LendingPool via LendingPoolCollateral manager using a DELEGATECALL This allows to have the events in the generated ABI for LendingPool.",params:{collateralAsset:"The address of the underlying asset used as collateral, to receive as result of the liquidation",debtAsset:"The address of the underlying borrowed asset to be repaid with the liquidation",debtToCover:"The debt amount of borrowed `asset` the liquidator wants to cover",liquidatedCollateralAmount:"The amount of collateral received by the liiquidator",liquidator:"The address of the liquidator",receiveAToken:"`true` if the liquidators wants to receive the collateral aTokens, `false` if he wants to receive the underlying collateral asset directly*",user:"The address of the borrower getting liquidated"}},"Paused()":{anonymous:!1,inputs:[],name:"Paused",type:"event",details:"Emitted when the pause is triggered."},"RebalanceStableBorrowRate(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"reserve",type:"address"},{indexed:!0,internalType:"address",name:"user",type:"address"}],name:"RebalanceStableBorrowRate",type:"event",details:"Emitted on rebalanceStableBorrowRate()",params:{reserve:"The address of the underlying asset of the reserve",user:"The address of the user for which the rebalance has been executed*"}},"Repay(address,address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"reserve",type:"address"},{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!0,internalType:"address",name:"repayer",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Repay",type:"event",details:"Emitted on repay()",params:{amount:"The amount repaid*",repayer:"The address of the user initiating the repay(), providing the funds",reserve:"The address of the underlying asset of the reserve",user:"The beneficiary of the repayment, getting his debt reduced"}},"ReserveDataUpdated(address,uint256,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"reserve",type:"address"},{indexed:!1,internalType:"uint256",name:"liquidityRate",type:"uint256"},{indexed:!1,internalType:"uint256",name:"stableBorrowRate",type:"uint256"},{indexed:!1,internalType:"uint256",name:"variableBorrowRate",type:"uint256"},{indexed:!1,internalType:"uint256",name:"liquidityIndex",type:"uint256"},{indexed:!1,internalType:"uint256",name:"variableBorrowIndex",type:"uint256"}],name:"ReserveDataUpdated",type:"event",details:"Emitted when the state of a reserve is updated. NOTE: This event is actually declared in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal, the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it gets added to the LendingPool ABI",params:{liquidityIndex:"The new liquidity index",liquidityRate:"The new liquidity rate",reserve:"The address of the underlying asset of the reserve",stableBorrowRate:"The new stable borrow rate",variableBorrowIndex:"The new variable borrow index*",variableBorrowRate:"The new variable borrow rate"}},"ReserveUsedAsCollateralDisabled(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"reserve",type:"address"},{indexed:!0,internalType:"address",name:"user",type:"address"}],name:"ReserveUsedAsCollateralDisabled",type:"event",details:"Emitted on setUserUseReserveAsCollateral()",params:{reserve:"The address of the underlying asset of the reserve",user:"The address of the user enabling the usage as collateral*"}},"ReserveUsedAsCollateralEnabled(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"reserve",type:"address"},{indexed:!0,internalType:"address",name:"user",type:"address"}],name:"ReserveUsedAsCollateralEnabled",type:"event",details:"Emitted on setUserUseReserveAsCollateral()",params:{reserve:"The address of the underlying asset of the reserve",user:"The address of the user enabling the usage as collateral*"}},"Swap(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"reserve",type:"address"},{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"rateMode",type:"uint256"}],name:"Swap",type:"event",details:"Emitted on swapBorrowRateMode()",params:{rateMode:"The rate mode that the user wants to swap to*",reserve:"The address of the underlying asset of the reserve",user:"The address of the user swapping his rate mode"}},"Unpaused()":{anonymous:!1,inputs:[],name:"Unpaused",type:"event",details:"Emitted when the pause is lifted."},"Withdraw(address,address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"reserve",type:"address"},{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Withdraw",type:"event",details:"Emitted on withdraw()",params:{amount:"The amount to be withdrawn*",reserve:"The address of the underlyng asset being withdrawn",to:"Address that will receive the underlying",user:"The address initiating the withdrawal, owner of aTokens"}}},methods:{"borrow(address,uint256,uint256,uint16,address)":{inputs:[{internalType:"address",name:"asset",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"interestRateMode",type:"uint256"},{internalType:"uint16",name:"referralCode",type:"uint16"},{internalType:"address",name:"onBehalfOf",type:"address"}],name:"borrow",outputs:[],stateMutability:"nonpayable",type:"function",details:"Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower already deposited enough collateral, or he was given enough allowance by a credit delegator on the corresponding debt token (StableDebtToken or VariableDebtToken) - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet   and 100 stable/variable debt tokens, depending on the `interestRateMode`",params:{amount:"The amount to be borrowed",asset:"The address of the underlying asset to borrow",interestRateMode:"The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable",onBehalfOf:"Address of the user who will receive the debt. Should be the address of the borrower itself calling the function if he wants to borrow against his own collateral, or the address of the credit delegator if he has been given credit delegation allowance*",referralCode:"Code used to register the integrator originating the operation, for potential rewards.   0 if the action is executed directly by the user, without any middle-man"}},"deposit(address,uint256,address,uint16)":{inputs:[{internalType:"address",name:"asset",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"address",name:"onBehalfOf",type:"address"},{internalType:"uint16",name:"referralCode",type:"uint16"}],name:"deposit",outputs:[],stateMutability:"nonpayable",type:"function",details:"Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens. - E.g. User deposits 100 USDC and gets in return 100 aUSDC",params:{amount:"The amount to be deposited",asset:"The address of the underlying asset to deposit",onBehalfOf:"The address that will receive the aTokens, same as msg.sender if the user   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens   is a different wallet",referralCode:"Code used to register the integrator originating the operation, for potential rewards.   0 if the action is executed directly by the user, without any middle-man*"}},"finalizeTransfer(address,address,address,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"asset",type:"address"},{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"balanceFromAfter",type:"uint256"},{internalType:"uint256",name:"balanceToBefore",type:"uint256"}],name:"finalizeTransfer",outputs:[],stateMutability:"nonpayable",type:"function"},"flashLoan(address,address[],uint256[],uint256[],address,bytes,uint16)":{inputs:[{internalType:"address",name:"receiverAddress",type:"address"},{internalType:"address[]",name:"assets",type:"address[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256[]",name:"modes",type:"uint256[]"},{internalType:"address",name:"onBehalfOf",type:"address"},{internalType:"bytes",name:"params",type:"bytes"},{internalType:"uint16",name:"referralCode",type:"uint16"}],name:"flashLoan",outputs:[],stateMutability:"nonpayable",type:"function",details:"Allows smartcontracts to access the liquidity of the pool within one transaction, as long as the amount taken plus a fee is returned. IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration. For further details please visit https://developers.aave.com",params:{amounts:"The amounts amounts being flash-borrowed",assets:"The addresses of the assets being flash-borrowed",modes:"Types of the debt to open if the flash loan is not returned:   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address",onBehalfOf:"The address  that will receive the debt in the case of using on `modes` 1 or 2",params:"Variadic packed params to pass to the receiver as extra information",receiverAddress:"The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface",referralCode:"Code used to register the integrator originating the operation, for potential rewards.   0 if the action is executed directly by the user, without any middle-man*"}},"getAddressesProvider()":{inputs:[],name:"getAddressesProvider",outputs:[{internalType:"contract ILendingPoolAddressesProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getConfiguration(address)":{inputs:[{internalType:"address",name:"asset",type:"address"}],name:"getConfiguration",outputs:[{components:[{internalType:"uint256",name:"data",type:"uint256"}],internalType:"struct DataTypes.ReserveConfigurationMap",name:"",type:"tuple"}],stateMutability:"view",type:"function",details:"Returns the configuration of the reserve",params:{asset:"The address of the underlying asset of the reserve"},returns:{_0:"The configuration of the reserve*"}},"getReserveData(address)":{inputs:[{internalType:"address",name:"asset",type:"address"}],name:"getReserveData",outputs:[{components:[{components:[{internalType:"uint256",name:"data",type:"uint256"}],internalType:"struct DataTypes.ReserveConfigurationMap",name:"configuration",type:"tuple"},{internalType:"uint128",name:"liquidityIndex",type:"uint128"},{internalType:"uint128",name:"variableBorrowIndex",type:"uint128"},{internalType:"uint128",name:"currentLiquidityRate",type:"uint128"},{internalType:"uint128",name:"currentVariableBorrowRate",type:"uint128"},{internalType:"uint128",name:"currentStableBorrowRate",type:"uint128"},{internalType:"uint40",name:"lastUpdateTimestamp",type:"uint40"},{internalType:"address",name:"aTokenAddress",type:"address"},{internalType:"address",name:"stableDebtTokenAddress",type:"address"},{internalType:"address",name:"variableDebtTokenAddress",type:"address"},{internalType:"address",name:"interestRateStrategyAddress",type:"address"},{internalType:"uint8",name:"id",type:"uint8"}],internalType:"struct DataTypes.ReserveData",name:"",type:"tuple"}],stateMutability:"view",type:"function",details:"Returns the state and configuration of the reserve",params:{asset:"The address of the underlying asset of the reserve"},returns:{_0:"The state of the reserve*"}},"getReserveNormalizedIncome(address)":{inputs:[{internalType:"address",name:"asset",type:"address"}],name:"getReserveNormalizedIncome",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the normalized income normalized income of the reserve",params:{asset:"The address of the underlying asset of the reserve"},returns:{_0:"The reserve's normalized income"}},"getReserveNormalizedVariableDebt(address)":{inputs:[{internalType:"address",name:"asset",type:"address"}],name:"getReserveNormalizedVariableDebt",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the normalized variable debt per unit of asset",params:{asset:"The address of the underlying asset of the reserve"},returns:{_0:"The reserve normalized variable debt"}},"getReservesList()":{inputs:[],name:"getReservesList",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function"},"getUserAccountData(address)":{inputs:[{internalType:"address",name:"user",type:"address"}],name:"getUserAccountData",outputs:[{internalType:"uint256",name:"totalCollateralETH",type:"uint256"},{internalType:"uint256",name:"totalDebtETH",type:"uint256"},{internalType:"uint256",name:"availableBorrowsETH",type:"uint256"},{internalType:"uint256",name:"currentLiquidationThreshold",type:"uint256"},{internalType:"uint256",name:"ltv",type:"uint256"},{internalType:"uint256",name:"healthFactor",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the user account data across all the reserves",params:{user:"The address of the user"},returns:{availableBorrowsETH:"the borrowing power left of the user",currentLiquidationThreshold:"the liquidation threshold of the user",healthFactor:"the current health factor of the user*",ltv:"the loan to value of the user",totalCollateralETH:"the total collateral in ETH of the user",totalDebtETH:"the total debt in ETH of the user"}},"getUserConfiguration(address)":{inputs:[{internalType:"address",name:"user",type:"address"}],name:"getUserConfiguration",outputs:[{components:[{internalType:"uint256",name:"data",type:"uint256"}],internalType:"struct DataTypes.UserConfigurationMap",name:"",type:"tuple"}],stateMutability:"view",type:"function",details:"Returns the configuration of the user across all the reserves",params:{user:"The user address"},returns:{_0:"The configuration of the user*"}},"initReserve(address,address,address,address,address)":{inputs:[{internalType:"address",name:"reserve",type:"address"},{internalType:"address",name:"aTokenAddress",type:"address"},{internalType:"address",name:"stableDebtAddress",type:"address"},{internalType:"address",name:"variableDebtAddress",type:"address"},{internalType:"address",name:"interestRateStrategyAddress",type:"address"}],name:"initReserve",outputs:[],stateMutability:"nonpayable",type:"function"},"liquidationCall(address,address,address,uint256,bool)":{inputs:[{internalType:"address",name:"collateralAsset",type:"address"},{internalType:"address",name:"debtAsset",type:"address"},{internalType:"address",name:"user",type:"address"},{internalType:"uint256",name:"debtToCover",type:"uint256"},{internalType:"bool",name:"receiveAToken",type:"bool"}],name:"liquidationCall",outputs:[],stateMutability:"nonpayable",type:"function",details:"Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1 - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk",params:{collateralAsset:"The address of the underlying asset used as collateral, to receive as result of the liquidation",debtAsset:"The address of the underlying borrowed asset to be repaid with the liquidation",debtToCover:"The debt amount of borrowed `asset` the liquidator wants to cover",receiveAToken:"`true` if the liquidators wants to receive the collateral aTokens, `false` if he wants to receive the underlying collateral asset directly*",user:"The address of the borrower getting liquidated"}},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"rebalanceStableBorrowRate(address,address)":{inputs:[{internalType:"address",name:"asset",type:"address"},{internalType:"address",name:"user",type:"address"}],name:"rebalanceStableBorrowRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"Rebalances the stable interest rate of a user to the current stable rate defined on the reserve. - Users can be rebalanced if the following conditions are satisfied:     1. Usage ratio is above 95%     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been        borrowed at a stable rate and depositors are not earning enough",params:{asset:"The address of the underlying asset borrowed",user:"The address of the user to be rebalanced*"}},"repay(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"asset",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"rateMode",type:"uint256"},{internalType:"address",name:"onBehalfOf",type:"address"}],name:"repay",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amount:"The amount to repay - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`",asset:"The address of the borrowed underlying asset previously borrowed",onBehalfOf:"Address of the user who will get his debt reduced/removed. Should be the address of the user calling the function if he wants to reduce/remove his own debt, or the address of any other other borrower whose debt should be removed",rateMode:"The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable"},returns:{_0:"The final amount repaid*"},notice:"Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address"},"setConfiguration(address,uint256)":{inputs:[{internalType:"address",name:"reserve",type:"address"},{internalType:"uint256",name:"configuration",type:"uint256"}],name:"setConfiguration",outputs:[],stateMutability:"nonpayable",type:"function"},"setPause(bool)":{inputs:[{internalType:"bool",name:"val",type:"bool"}],name:"setPause",outputs:[],stateMutability:"nonpayable",type:"function"},"setReserveInterestRateStrategyAddress(address,address)":{inputs:[{internalType:"address",name:"reserve",type:"address"},{internalType:"address",name:"rateStrategyAddress",type:"address"}],name:"setReserveInterestRateStrategyAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"setUserUseReserveAsCollateral(address,bool)":{inputs:[{internalType:"address",name:"asset",type:"address"},{internalType:"bool",name:"useAsCollateral",type:"bool"}],name:"setUserUseReserveAsCollateral",outputs:[],stateMutability:"nonpayable",type:"function",details:"Allows depositors to enable/disable a specific deposited asset as collateral",params:{asset:"The address of the underlying asset deposited",useAsCollateral:"`true` if the user wants to use the deposit as collateral, `false` otherwise*"}},"swapBorrowRateMode(address,uint256)":{inputs:[{internalType:"address",name:"asset",type:"address"},{internalType:"uint256",name:"rateMode",type:"uint256"}],name:"swapBorrowRateMode",outputs:[],stateMutability:"nonpayable",type:"function",details:"Allows a borrower to swap his debt between stable and variable mode, or viceversa",params:{asset:"The address of the underlying asset borrowed",rateMode:"The rate mode that the user wants to swap to*"}},"withdraw(address,uint256,address)":{inputs:[{internalType:"address",name:"asset",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"address",name:"to",type:"address"}],name:"withdraw",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC",params:{amount:"The underlying amount to be withdrawn   - Send the value type(uint256).max in order to withdraw the whole aToken balance",asset:"The address of the underlying asset to withdraw",to:"Address that will receive the underlying, same as msg.sender if the user   wants to receive it on his own wallet, or a different address if the beneficiary is a   different wallet"},returns:{_0:"The final amount withdrawn*"}}}},"contracts/externalInterfaces/aave/ILendingPoolAddressesProvider.sol:ILendingPoolAddressesProvider":{source:"contracts/externalInterfaces/aave/ILendingPoolAddressesProvider.sol",name:"ILendingPoolAddressesProvider",title:"LendingPoolAddressesProvider contract",author:"Aave*",details:"Main registry of addresses part of or connected to the protocol, including permissioned roles - Acting also as factory of proxies and admin of those, so with right to change its implementations - Owned by the Aave Governance",events:{"AddressSet(bytes32,address,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bytes32",name:"id",type:"bytes32"},{indexed:!0,internalType:"address",name:"newAddress",type:"address"},{indexed:!1,internalType:"bool",name:"hasProxy",type:"bool"}],name:"AddressSet",type:"event"},"ConfigurationAdminUpdated(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"newAddress",type:"address"}],name:"ConfigurationAdminUpdated",type:"event"},"EmergencyAdminUpdated(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"newAddress",type:"address"}],name:"EmergencyAdminUpdated",type:"event"},"LendingPoolCollateralManagerUpdated(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"newAddress",type:"address"}],name:"LendingPoolCollateralManagerUpdated",type:"event"},"LendingPoolConfiguratorUpdated(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"newAddress",type:"address"}],name:"LendingPoolConfiguratorUpdated",type:"event"},"LendingPoolUpdated(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"newAddress",type:"address"}],name:"LendingPoolUpdated",type:"event"},"LendingRateOracleUpdated(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"newAddress",type:"address"}],name:"LendingRateOracleUpdated",type:"event"},"MarketIdSet(string)":{anonymous:!1,inputs:[{indexed:!1,internalType:"string",name:"newMarketId",type:"string"}],name:"MarketIdSet",type:"event"},"PriceOracleUpdated(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"newAddress",type:"address"}],name:"PriceOracleUpdated",type:"event"},"ProxyCreated(bytes32,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bytes32",name:"id",type:"bytes32"},{indexed:!0,internalType:"address",name:"newAddress",type:"address"}],name:"ProxyCreated",type:"event"}},methods:{"getAddress(bytes32)":{inputs:[{internalType:"bytes32",name:"id",type:"bytes32"}],name:"getAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getEmergencyAdmin()":{inputs:[],name:"getEmergencyAdmin",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getLendingPool()":{inputs:[],name:"getLendingPool",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getLendingPoolCollateralManager()":{inputs:[],name:"getLendingPoolCollateralManager",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getLendingPoolConfigurator()":{inputs:[],name:"getLendingPoolConfigurator",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getLendingRateOracle()":{inputs:[],name:"getLendingRateOracle",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getMarketId()":{inputs:[],name:"getMarketId",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"getPoolAdmin()":{inputs:[],name:"getPoolAdmin",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getPriceOracle()":{inputs:[],name:"getPriceOracle",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"setAddress(bytes32,address)":{inputs:[{internalType:"bytes32",name:"id",type:"bytes32"},{internalType:"address",name:"newAddress",type:"address"}],name:"setAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"setAddressAsProxy(bytes32,address)":{inputs:[{internalType:"bytes32",name:"id",type:"bytes32"},{internalType:"address",name:"impl",type:"address"}],name:"setAddressAsProxy",outputs:[],stateMutability:"nonpayable",type:"function"},"setEmergencyAdmin(address)":{inputs:[{internalType:"address",name:"admin",type:"address"}],name:"setEmergencyAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},"setLendingPoolCollateralManager(address)":{inputs:[{internalType:"address",name:"manager",type:"address"}],name:"setLendingPoolCollateralManager",outputs:[],stateMutability:"nonpayable",type:"function"},"setLendingPoolConfiguratorImpl(address)":{inputs:[{internalType:"address",name:"configurator",type:"address"}],name:"setLendingPoolConfiguratorImpl",outputs:[],stateMutability:"nonpayable",type:"function"},"setLendingPoolImpl(address)":{inputs:[{internalType:"address",name:"pool",type:"address"}],name:"setLendingPoolImpl",outputs:[],stateMutability:"nonpayable",type:"function"},"setLendingRateOracle(address)":{inputs:[{internalType:"address",name:"lendingRateOracle",type:"address"}],name:"setLendingRateOracle",outputs:[],stateMutability:"nonpayable",type:"function"},"setMarketId(string)":{inputs:[{internalType:"string",name:"marketId",type:"string"}],name:"setMarketId",outputs:[],stateMutability:"nonpayable",type:"function"},"setPoolAdmin(address)":{inputs:[{internalType:"address",name:"admin",type:"address"}],name:"setPoolAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},"setPriceOracle(address)":{inputs:[{internalType:"address",name:"priceOracle",type:"address"}],name:"setPriceOracle",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/externalInterfaces/aave/IScaledBalanceToken.sol:IScaledBalanceToken":{source:"contracts/externalInterfaces/aave/IScaledBalanceToken.sol",name:"IScaledBalanceToken",methods:{"getScaledUserBalanceAndSupply(address)":{inputs:[{internalType:"address",name:"user",type:"address"}],name:"getScaledUserBalanceAndSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the scaled balance of the user and the scaled total supply.",params:{user:"The address of the user"},returns:{_0:"The scaled balance of the user",_1:"The scaled balance and the scaled total supply*"}},"scaledBalanceOf(address)":{inputs:[{internalType:"address",name:"user",type:"address"}],name:"scaledBalanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the scaled balance of the user. The scaled balance is the sum of all the updated stored balance divided by the reserve's liquidity index at the moment of the update",params:{user:"The user whose balance is calculated"},returns:{_0:"The scaled balance of the user*"}},"scaledTotalSupply()":{inputs:[],name:"scaledTotalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the scaled total supply of the variable debt token. Represents sum(debt/index)",returns:{_0:"The scaled total supply*"}}}},"contracts/externalInterfaces/openzeppelin/IMintableERC20.sol:IMintableERC20":{source:"contracts/externalInterfaces/openzeppelin/IMintableERC20.sol",name:"IMintableERC20",methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"address",name:"_spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"_spender",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"balanceOf(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"burn(address,uint96)":{inputs:[{internalType:"address",name:"_account",type:"address"},{internalType:"uint96",name:"_amount",type:"uint96"}],name:"burn",outputs:[],stateMutability:"nonpayable",type:"function"},"mint(address,uint96)":{inputs:[{internalType:"address",name:"_account",type:"address"},{internalType:"uint96",name:"_amount",type:"uint96"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"_recipient",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"_sender",type:"address"},{internalType:"address",name:"_recipient",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"}}},"contracts/externalInterfaces/openzeppelin/IOwnable.sol:IOwnable":{source:"contracts/externalInterfaces/openzeppelin/IOwnable.sol",name:"IOwnable",methods:{"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/externalInterfaces/openzeppelin/IProxyAdmin.sol:IProxyAdmin":{source:"contracts/externalInterfaces/openzeppelin/IProxyAdmin.sol",name:"IProxyAdmin",methods:{"changeProxyAdmin(address,address)":{inputs:[{internalType:"contract TransparentUpgradeableProxy",name:"proxy",type:"address"},{internalType:"address",name:"newAdmin",type:"address"}],name:"changeProxyAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},"getProxyAdmin(address)":{inputs:[{internalType:"contract TransparentUpgradeableProxy",name:"proxy",type:"address"}],name:"getProxyAdmin",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getProxyImplementation(address)":{inputs:[{internalType:"contract TransparentUpgradeableProxy",name:"proxy",type:"address"}],name:"getProxyImplementation",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"upgrade(address,address)":{inputs:[{internalType:"contract TransparentUpgradeableProxy",name:"proxy",type:"address"},{internalType:"address",name:"implementation",type:"address"}],name:"upgrade",outputs:[],stateMutability:"nonpayable",type:"function"},"upgradeAndCall(address,address,bytes)":{inputs:[{internalType:"contract TransparentUpgradeableProxy",name:"proxy",type:"address"},{internalType:"address",name:"implementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeAndCall",outputs:[],stateMutability:"payable",type:"function"}}},"contracts/externalInterfaces/openzeppelin/ITransparentUpgradeableProxy.sol:ITransparentUpgradeableProxy":{source:"contracts/externalInterfaces/openzeppelin/ITransparentUpgradeableProxy.sol",name:"ITransparentUpgradeableProxy",methods:{"admin()":{inputs:[],name:"admin",outputs:[{internalType:"address",name:"admin_",type:"address"}],stateMutability:"view",type:"function"},"changeAdmin(address)":{inputs:[{internalType:"address",name:"newAdmin",type:"address"}],name:"changeAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},"implementation()":{inputs:[],name:"implementation",outputs:[{internalType:"address",name:"implementation_",type:"address"}],stateMutability:"nonpayable",type:"function"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function"},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function"}}},"contracts/governor/ImpactProxyAdmin.sol:ImpactProxyAdmin":{source:"contracts/governor/ImpactProxyAdmin.sol",name:"ImpactProxyAdmin",events:{"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"}},methods:{"changeProxyAdmin(address,address)":{inputs:[{internalType:"contract TransparentUpgradeableProxy",name:"proxy",type:"address"},{internalType:"address",name:"newAdmin",type:"address"}],name:"changeProxyAdmin",outputs:[],stateMutability:"nonpayable",type:"function",details:"Changes the admin of `proxy` to `newAdmin`. Requirements: - This contract must be the current admin of `proxy`."},"getProxyAdmin(address)":{inputs:[{internalType:"contract TransparentUpgradeableProxy",name:"proxy",type:"address"}],name:"getProxyAdmin",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the current admin of `proxy`. Requirements: - This contract must be the admin of `proxy`."},"getProxyImplementation(address)":{inputs:[{internalType:"contract TransparentUpgradeableProxy",name:"proxy",type:"address"}],name:"getProxyImplementation",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the current implementation of `proxy`. Requirements: - This contract must be the admin of `proxy`."},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"upgrade(address,address)":{inputs:[{internalType:"contract TransparentUpgradeableProxy",name:"proxy",type:"address"},{internalType:"address",name:"implementation",type:"address"}],name:"upgrade",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}. Requirements: - This contract must be the admin of `proxy`."},"upgradeAndCall(address,address,bytes)":{inputs:[{internalType:"contract TransparentUpgradeableProxy",name:"proxy",type:"address"},{internalType:"address",name:"implementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrades `proxy` to `implementation` and calls a function on the new implementation. See {TransparentUpgradeableProxy-upgradeToAndCall}. Requirements: - This contract must be the admin of `proxy`."}}},"contracts/governor/PACTDelegate.sol:PACTDelegate":{source:"contracts/governor/PACTDelegate.sol",name:"PACTDelegate",events:{"NewAdmin(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"NewAdmin",type:"event",notice:"Emitted when pendingAdmin is accepted, which means admin is updated"},"NewImplementation(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldImplementation",type:"address"},{indexed:!1,internalType:"address",name:"newImplementation",type:"address"}],name:"NewImplementation",type:"event",notice:"Emitted when implementation is changed"},"NewPendingAdmin(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldPendingAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newPendingAdmin",type:"address"}],name:"NewPendingAdmin",type:"event",notice:"Emitted when pendingAdmin is changed"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"ProposalCanceled(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"id",type:"uint256"}],name:"ProposalCanceled",type:"event",notice:"An event emitted when a proposal has been canceled"},"ProposalCreated(uint256,address,address[],uint256[],string[],bytes[],uint256,uint256,string)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"id",type:"uint256"},{indexed:!1,internalType:"address",name:"proposer",type:"address"},{indexed:!1,internalType:"address[]",name:"targets",type:"address[]"},{indexed:!1,internalType:"uint256[]",name:"values",type:"uint256[]"},{indexed:!1,internalType:"string[]",name:"signatures",type:"string[]"},{indexed:!1,internalType:"bytes[]",name:"calldatas",type:"bytes[]"},{indexed:!1,internalType:"uint256",name:"startBlock",type:"uint256"},{indexed:!1,internalType:"uint256",name:"endBlock",type:"uint256"},{indexed:!1,internalType:"string",name:"description",type:"string"}],name:"ProposalCreated",type:"event",notice:"An event emitted when a new proposal is created"},"ProposalExecuted(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"id",type:"uint256"}],name:"ProposalExecuted",type:"event",notice:"An event emitted when a proposal has been executed in the Timelock"},"ProposalQueued(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"id",type:"uint256"},{indexed:!1,internalType:"uint256",name:"eta",type:"uint256"}],name:"ProposalQueued",type:"event",notice:"An event emitted when a proposal has been queued in the Timelock"},"ProposalThresholdSet(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldProposalThreshold",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newProposalThreshold",type:"uint256"}],name:"ProposalThresholdSet",type:"event",notice:"Emitted when proposal threshold is set"},"QuorumVotesSet(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldQuorumVotes",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newQuorumVotes",type:"uint256"}],name:"QuorumVotesSet",type:"event",notice:"An event emitted when the quorum votes is set"},"ReleaseTokenSet(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldReleaseToken",type:"address"},{indexed:!1,internalType:"address",name:"newReleaseToken",type:"address"}],name:"ReleaseTokenSet",type:"event",notice:"Emitted when release token is set"},"TransferERC20(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"TransferERC20",type:"event",notice:"Triggered when an amount of an ERC20 has been transferred from this contract to an address"},"VoteCast(address,uint256,uint8,uint256,string)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"voter",type:"address"},{indexed:!1,internalType:"uint256",name:"proposalId",type:"uint256"},{indexed:!1,internalType:"uint8",name:"support",type:"uint8"},{indexed:!1,internalType:"uint256",name:"votes",type:"uint256"},{indexed:!1,internalType:"string",name:"reason",type:"string"}],name:"VoteCast",type:"event",notice:"An event emitted when a vote has been cast on a proposal"},"VotingDelaySet(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldVotingDelay",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newVotingDelay",type:"uint256"}],name:"VotingDelaySet",type:"event",notice:"An event emitted when the voting delay is set"},"VotingPeriodSet(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldVotingPeriod",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newVotingPeriod",type:"uint256"}],name:"VotingPeriodSet",type:"event",notice:"An event emitted when the voting period is set"}},methods:{"BALLOT_TYPEHASH()":{inputs:[],name:"BALLOT_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"The EIP-712 typehash for the ballot struct used by the contract"},"DOMAIN_TYPEHASH()":{inputs:[],name:"DOMAIN_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"The EIP-712 typehash for the contract's domain"},"MAX_PROPOSAL_THRESHOLD()":{inputs:[],name:"MAX_PROPOSAL_THRESHOLD",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The maximum setable proposal threshold"},"MAX_VOTING_DELAY()":{inputs:[],name:"MAX_VOTING_DELAY",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The max setable voting delay"},"MAX_VOTING_PERIOD()":{inputs:[],name:"MAX_VOTING_PERIOD",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The max setable voting period"},"MIN_PROPOSAL_THRESHOLD()":{inputs:[],name:"MIN_PROPOSAL_THRESHOLD",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The minimum setable proposal threshold"},"MIN_VOTING_DELAY()":{inputs:[],name:"MIN_VOTING_DELAY",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The min setable voting delay"},"MIN_VOTING_PERIOD()":{inputs:[],name:"MIN_VOTING_PERIOD",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The minimum setable voting period"},"NAME()":{inputs:[],name:"NAME",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",notice:"The name of this contract"},"PROPOSAL_MAX_OPERATIONS()":{inputs:[],name:"PROPOSAL_MAX_OPERATIONS",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The maximum number of actions that can be included in a proposal"},"_setProposalThreshold(uint256)":{inputs:[{internalType:"uint256",name:"_newProposalThreshold",type:"uint256"}],name:"_setProposalThreshold",outputs:[],stateMutability:"nonpayable",type:"function",details:"_newProposalThreshold must be greater than the hardcoded min",params:{_newProposalThreshold:"new proposal threshold"},notice:"Owner function for setting the proposal threshold"},"_setQuorumVotes(uint256)":{inputs:[{internalType:"uint256",name:"_newQuorumVotes",type:"uint256"}],name:"_setQuorumVotes",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newQuorumVotes:"new quorum votes"},notice:"Owner function for setting the quorum votes"},"_setReleaseToken(address)":{inputs:[{internalType:"contract IHasVotes",name:"_newReleaseToken",type:"address"}],name:"_setReleaseToken",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newReleaseToken:"new release token address"},notice:"Owner function for setting the release token"},"_setVotingDelay(uint256)":{inputs:[{internalType:"uint256",name:"_newVotingDelay",type:"uint256"}],name:"_setVotingDelay",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newVotingDelay:"new voting delay, in blocks"},notice:"Owner function for setting the voting delay"},"_setVotingPeriod(uint256)":{inputs:[{internalType:"uint256",name:"_newVotingPeriod",type:"uint256"}],name:"_setVotingPeriod",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newVotingPeriod:"new voting period, in blocks"},notice:"Owner function for setting the voting period"},"cancel(uint256)":{inputs:[{internalType:"uint256",name:"_proposalId",type:"uint256"}],name:"cancel",outputs:[],stateMutability:"nonpayable",type:"function",params:{_proposalId:"The id of the proposal to cancel"},notice:"Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold"},"castVote(uint256,uint8)":{inputs:[{internalType:"uint256",name:"_proposalId",type:"uint256"},{internalType:"uint8",name:"_support",type:"uint8"}],name:"castVote",outputs:[],stateMutability:"nonpayable",type:"function",params:{_proposalId:"The id of the proposal to vote on",_support:"The support value for the vote. 0=against, 1=for, 2=abstain"},notice:"Cast a vote for a proposal"},"castVoteBySig(uint256,uint8,uint8,bytes32,bytes32)":{inputs:[{internalType:"uint256",name:"_proposalId",type:"uint256"},{internalType:"uint8",name:"_support",type:"uint8"},{internalType:"uint8",name:"_v",type:"uint8"},{internalType:"bytes32",name:"_r",type:"bytes32"},{internalType:"bytes32",name:"_s",type:"bytes32"}],name:"castVoteBySig",outputs:[],stateMutability:"nonpayable",type:"function",details:"External function that accepts EIP-712 signatures for voting on proposals.",notice:"Cast a vote for a proposal by signature"},"castVoteWithReason(uint256,uint8,string)":{inputs:[{internalType:"uint256",name:"_proposalId",type:"uint256"},{internalType:"uint8",name:"_support",type:"uint8"},{internalType:"string",name:"_reason",type:"string"}],name:"castVoteWithReason",outputs:[],stateMutability:"nonpayable",type:"function",params:{_proposalId:"The id of the proposal to vote on",_reason:"The reason given for the vote by the voter",_support:"The support value for the vote. 0=against, 1=for, 2=abstain"},notice:"Cast a vote for a proposal with a reason"},"execute(uint256)":{inputs:[{internalType:"uint256",name:"_proposalId",type:"uint256"}],name:"execute",outputs:[],stateMutability:"payable",type:"function",params:{_proposalId:"The id of the proposal to execute"},notice:"Executes a queued proposal if eta has passed"},"getActions(uint256)":{inputs:[{internalType:"uint256",name:"_proposalId",type:"uint256"}],name:"getActions",outputs:[{internalType:"address[]",name:"targets",type:"address[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"},{internalType:"string[]",name:"signatures",type:"string[]"},{internalType:"bytes[]",name:"calldatas",type:"bytes[]"}],stateMutability:"view",type:"function",params:{_proposalId:"Proposal to query."},returns:{calldatas:"Calldatas for proposal calls.",signatures:"Function signatures for proposal calls.",targets:"Target addresses for proposal calls.",values:"Eth values for proposal calls."},notice:"Gets actions of a proposal."},"getPriorVotes(address,uint256)":{inputs:[{internalType:"address",name:"_voter",type:"address"},{internalType:"uint256",name:"_beforeBlock",type:"uint256"}],name:"getPriorVotes",outputs:[{internalType:"uint96",name:"",type:"uint96"}],stateMutability:"view",type:"function"},"getReceipt(uint256,address)":{inputs:[{internalType:"uint256",name:"_proposalId",type:"uint256"},{internalType:"address",name:"_voter",type:"address"}],name:"getReceipt",outputs:[{components:[{internalType:"bool",name:"hasVoted",type:"bool"},{internalType:"uint8",name:"support",type:"uint8"},{internalType:"uint96",name:"votes",type:"uint96"}],internalType:"struct PACTDelegateStorageV1.Receipt",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{_proposalId:"the id of proposal",_voter:"The address of the voter"},returns:{_0:"The voting receipt"},notice:"Gets the receipt for a voter on a given proposal"},"initialize(address,address,address,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"_timelock",type:"address"},{internalType:"address",name:"_token",type:"address"},{internalType:"address",name:"_releaseToken",type:"address"},{internalType:"uint256",name:"_votingPeriod",type:"uint256"},{internalType:"uint256",name:"_votingDelay",type:"uint256"},{internalType:"uint256",name:"_proposalThreshold",type:"uint256"},{internalType:"uint256",name:"_quorumVotes",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_proposalThreshold:"The initial proposal threshold",_quorumVotes:"The initial quorum votes",_releaseToken:'The address of the "Release" voting token. If none, specify the zero address.',_timelock:"The address of the Timelock",_token:"The address of the voting token",_votingDelay:"The initial voting delay",_votingPeriod:"The initial voting period"},notice:"Used to initialize the contract during delegator constructor"},"latestProposalIds(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"latestProposalIds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The latest proposal for each proposer"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"proposalCalldatas(uint256,uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],name:"proposalCalldatas",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"view",type:"function",notice:"The official each proposal's calldatas: An ordered list of calldata to be passed to each call"},"proposalCount()":{inputs:[],name:"proposalCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The total number of proposals"},"proposalReceipts(uint256,address)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"address",name:"",type:"address"}],name:"proposalReceipts",outputs:[{internalType:"bool",name:"hasVoted",type:"bool"},{internalType:"uint8",name:"support",type:"uint8"},{internalType:"uint96",name:"votes",type:"uint96"}],stateMutability:"view",type:"function",notice:"The official each proposal's receipts: Receipts of ballots for the entire set of voters"},"proposalSignatures(uint256,uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],name:"proposalSignatures",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",notice:"The official each proposal's signatures: An ordered list of function signatures to be called"},"proposalTargets(uint256,uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],name:"proposalTargets",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The official each proposal's targets: An ordered list of target addresses for calls to be made"},"proposalThreshold()":{inputs:[],name:"proposalThreshold",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The number of votes required in order for a voter to become a proposer"},"proposalValues(uint256,uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],name:"proposalValues",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The official each proposal's values: An ordered list of values (i.e. msg.value) to be passed to the calls to be made"},"proposals(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"proposals",outputs:[{internalType:"uint256",name:"id",type:"uint256"},{internalType:"address",name:"proposer",type:"address"},{internalType:"uint256",name:"eta",type:"uint256"},{internalType:"uint256",name:"startBlock",type:"uint256"},{internalType:"uint256",name:"endBlock",type:"uint256"},{internalType:"uint256",name:"forVotes",type:"uint256"},{internalType:"uint256",name:"againstVotes",type:"uint256"},{internalType:"uint256",name:"abstainVotes",type:"uint256"},{internalType:"bool",name:"canceled",type:"bool"},{internalType:"bool",name:"executed",type:"bool"}],stateMutability:"view",type:"function",notice:"The official record of all proposals ever proposed"},"propose(address[],uint256[],string[],bytes[],string)":{inputs:[{internalType:"address[]",name:"_targets",type:"address[]"},{internalType:"uint256[]",name:"_values",type:"uint256[]"},{internalType:"string[]",name:"_signatures",type:"string[]"},{internalType:"bytes[]",name:"_calldatas",type:"bytes[]"},{internalType:"string",name:"_description",type:"string"}],name:"propose",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{_calldatas:"Calldatas for proposal calls.",_description:"String description of the proposal.",_signatures:"Function signatures for proposal calls.",_targets:"Target addresses for proposal calls.",_values:"Eth values for proposal calls."},returns:{_0:"Proposal id of new proposal."},notice:"Function used to propose a new proposal. Sender must have delegates above the proposal threshold."},"queue(uint256)":{inputs:[{internalType:"uint256",name:"_proposalId",type:"uint256"}],name:"queue",outputs:[],stateMutability:"nonpayable",type:"function",params:{_proposalId:"The id of the proposal to queue"},notice:"Queues a proposal of state succeeded"},"quorumVotes()":{inputs:[],name:"quorumVotes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed"},"releaseToken()":{inputs:[],name:"releaseToken",outputs:[{internalType:"contract IHasVotes",name:"",type:"address"}],stateMutability:"view",type:"function",notice:'The address of the "Release" governance token'},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"state(uint256)":{inputs:[{internalType:"uint256",name:"_proposalId",type:"uint256"}],name:"state",outputs:[{internalType:"enum PACTDelegateStorageV1.ProposalState",name:"",type:"uint8"}],stateMutability:"view",type:"function",params:{_proposalId:"The id of the proposal"},returns:{_0:"Proposal state"},notice:"Gets the state of a proposal"},"timelock()":{inputs:[],name:"timelock",outputs:[{internalType:"contract TimelockInterface",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the Governance Timelock"},"token()":{inputs:[],name:"token",outputs:[{internalType:"contract IHasVotes",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the governance token"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"amount of the transaction",_to:"address of the receiver",_token:"address of the ERC20 token"},notice:"Transfers an amount of an ERC20 from this contract to an address"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"votingDelay()":{inputs:[],name:"votingDelay",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The delay before voting on a proposal may take place, once proposed, in blocks"},"votingPeriod()":{inputs:[],name:"votingPeriod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The duration of voting on a proposal, in blocks"}}},"contracts/governor/PACTDelegator.sol:PACTDelegator":{source:"contracts/governor/PACTDelegator.sol",name:"PACTDelegator",constructor:{inputs:[{internalType:"address",name:"_logic",type:"address"},{internalType:"address",name:"_proxyAdmin",type:"address"}],stateMutability:"nonpayable",type:"constructor"},fallback:{stateMutability:"payable",type:"fallback"},receive:{stateMutability:"payable",type:"receive"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"admin()":{inputs:[],name:"admin",outputs:[{internalType:"address",name:"admin_",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Returns the current admin. NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}. TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`"},"changeAdmin(address)":{inputs:[{internalType:"address",name:"newAdmin",type:"address"}],name:"changeAdmin",outputs:[],stateMutability:"nonpayable",type:"function",details:"Changes the admin of the proxy. Emits an {AdminChanged} event. NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}."},"implementation()":{inputs:[],name:"implementation",outputs:[{internalType:"address",name:"implementation_",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Returns the current implementation. NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}. TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy. NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy, and then call a function from the new implementation as specified by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the proxied contract. NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}."}}},"contracts/governor/PACTTimelock.sol:PACTTimelock":{source:"contracts/governor/PACTTimelock.sol",name:"PACTTimelock",constructor:{inputs:[{internalType:"address",name:"_admin",type:"address"},{internalType:"uint256",name:"_delay",type:"uint256"}],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},events:{"CancelTransaction(bytes32,address,uint256,string,bytes,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"txHash",type:"bytes32"},{indexed:!0,internalType:"address",name:"target",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"},{indexed:!1,internalType:"string",name:"signature",type:"string"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"uint256",name:"eta",type:"uint256"}],name:"CancelTransaction",type:"event"},"ExecuteTransaction(bytes32,address,uint256,string,bytes,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"txHash",type:"bytes32"},{indexed:!0,internalType:"address",name:"target",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"},{indexed:!1,internalType:"string",name:"signature",type:"string"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"uint256",name:"eta",type:"uint256"}],name:"ExecuteTransaction",type:"event"},"NewAdmin(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"newAdmin",type:"address"}],name:"NewAdmin",type:"event"},"NewDelay(uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"newDelay",type:"uint256"}],name:"NewDelay",type:"event"},"NewPendingAdmin(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"newPendingAdmin",type:"address"}],name:"NewPendingAdmin",type:"event"},"QueueTransaction(bytes32,address,uint256,string,bytes,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"txHash",type:"bytes32"},{indexed:!0,internalType:"address",name:"target",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"},{indexed:!1,internalType:"string",name:"signature",type:"string"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"uint256",name:"eta",type:"uint256"}],name:"QueueTransaction",type:"event"}},methods:{"GRACE_PERIOD()":{inputs:[],name:"GRACE_PERIOD",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"MAXIMUM_DELAY()":{inputs:[],name:"MAXIMUM_DELAY",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"MINIMUM_DELAY()":{inputs:[],name:"MINIMUM_DELAY",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"acceptAdmin()":{inputs:[],name:"acceptAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},"admin()":{inputs:[],name:"admin",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"cancelTransaction(address,uint256,string,bytes,uint256)":{inputs:[{internalType:"address",name:"_target",type:"address"},{internalType:"uint256",name:"_value",type:"uint256"},{internalType:"string",name:"_signature",type:"string"},{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"uint256",name:"_eta",type:"uint256"}],name:"cancelTransaction",outputs:[],stateMutability:"nonpayable",type:"function"},"delay()":{inputs:[],name:"delay",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"executeTransaction(address,uint256,string,bytes,uint256)":{inputs:[{internalType:"address",name:"_target",type:"address"},{internalType:"uint256",name:"_value",type:"uint256"},{internalType:"string",name:"_signature",type:"string"},{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"uint256",name:"_eta",type:"uint256"}],name:"executeTransaction",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function"},"pendingAdmin()":{inputs:[],name:"pendingAdmin",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"queueTransaction(address,uint256,string,bytes,uint256)":{inputs:[{internalType:"address",name:"_target",type:"address"},{internalType:"uint256",name:"_value",type:"uint256"},{internalType:"string",name:"_signature",type:"string"},{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"uint256",name:"_eta",type:"uint256"}],name:"queueTransaction",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"nonpayable",type:"function"},"queuedTransactions(bytes32)":{inputs:[{internalType:"bytes32",name:"",type:"bytes32"}],name:"queuedTransactions",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"setDelay(uint256)":{inputs:[{internalType:"uint256",name:"_delay",type:"uint256"}],name:"setDelay",outputs:[],stateMutability:"nonpayable",type:"function"},"setPendingAdmin(address)":{inputs:[{internalType:"address",name:"_pendingAdmin",type:"address"}],name:"setPendingAdmin",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/governor/impactMarketCouncil/ImpactMarketCouncilImplementation.sol:ImpactMarketCouncilImplementation":{source:"contracts/governor/impactMarketCouncil/ImpactMarketCouncilImplementation.sol",name:"ImpactMarketCouncilImplementation",events:{"MemberAdded(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"member",type:"address"}],name:"MemberAdded",type:"event",notice:"An event emitted when a member is added"},"MemberRemoved(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"member",type:"address"}],name:"MemberRemoved",type:"event",notice:"An event emitted when a member is removed"},"NewImplementation(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldImplementation",type:"address"},{indexed:!1,internalType:"address",name:"newImplementation",type:"address"}],name:"NewImplementation",type:"event",notice:"Emitted when implementation is changed"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"ProposalCanceled(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"id",type:"uint256"}],name:"ProposalCanceled",type:"event",notice:"An event emitted when a proposal has been canceled"},"ProposalCreated(uint256,address,address[],string[],bytes[],uint256,string)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"id",type:"uint256"},{indexed:!1,internalType:"address",name:"proposer",type:"address"},{indexed:!1,internalType:"address[]",name:"targets",type:"address[]"},{indexed:!1,internalType:"string[]",name:"signatures",type:"string[]"},{indexed:!1,internalType:"bytes[]",name:"calldatas",type:"bytes[]"},{indexed:!1,internalType:"uint256",name:"endBlock",type:"uint256"},{indexed:!1,internalType:"string",name:"description",type:"string"}],name:"ProposalCreated",type:"event",notice:"An event emitted when a new proposal is created"},"ProposalExecuted(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"id",type:"uint256"}],name:"ProposalExecuted",type:"event",notice:"An event emitted when a proposal has been executed in the Timelock"},"QuorumVotesSet(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldQuorumVotes",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newQuorumVotes",type:"uint256"}],name:"QuorumVotesSet",type:"event",notice:"An event emitted when the quorum votes is set"},"TransferERC20(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"TransferERC20",type:"event",params:{amount:"Amount of the transaction",to:"Address of the receiver",token:"ERC20 token address"},notice:"Triggered when an amount of an ERC20 has been transferred from this contract to an address"},"VoteCast(address,uint256,uint8,uint256,string)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"voter",type:"address"},{indexed:!1,internalType:"uint256",name:"proposalId",type:"uint256"},{indexed:!1,internalType:"uint8",name:"support",type:"uint8"},{indexed:!1,internalType:"uint256",name:"votes",type:"uint256"},{indexed:!1,internalType:"string",name:"reason",type:"string"}],name:"VoteCast",type:"event",params:{proposalId:"The proposal id which was voted on",reason:"The reason given for the vote by the voter",support:"Support value for the vote. 0=against, 1=for, 2=abstain",voter:"The address which casted a vote",votes:"Number of votes which were cast by the voter"},notice:"An event emitted when a vote has been cast on a proposal"}},methods:{"MAX_VOTING_PERIOD()":{inputs:[],name:"MAX_VOTING_PERIOD",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The max setable voting period"},"PROPOSAL_MAX_OPERATIONS()":{inputs:[],name:"PROPOSAL_MAX_OPERATIONS",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The maximum number of actions that can be included in a proposal"},"addMember(address)":{inputs:[{internalType:"address",name:"_member",type:"address"}],name:"addMember",outputs:[],stateMutability:"nonpayable",type:"function",params:{_member:"Member address."},notice:"Function used to add new members to the impactMarket Council."},"cancel(uint256)":{inputs:[{internalType:"uint256",name:"_proposalId",type:"uint256"}],name:"cancel",outputs:[],stateMutability:"nonpayable",type:"function",params:{_proposalId:"The id of the proposal to cancel"},notice:"Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold"},"castVote(uint256,uint8)":{inputs:[{internalType:"uint256",name:"_proposalId",type:"uint256"},{internalType:"uint8",name:"_support",type:"uint8"}],name:"castVote",outputs:[],stateMutability:"nonpayable",type:"function",params:{_proposalId:"The id of the proposal to vote on",_support:"The support value for the vote. 0=against, 1=for, 2=abstain"},notice:"Cast a vote for a proposal"},"communityAdmin()":{inputs:[],name:"communityAdmin",outputs:[{internalType:"contract ICommunityAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"communityProxyAdmin()":{inputs:[],name:"communityProxyAdmin",outputs:[{internalType:"contract ProxyAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"execute(uint256)":{inputs:[{internalType:"uint256",name:"_proposalId",type:"uint256"}],name:"execute",outputs:[],stateMutability:"payable",type:"function",params:{_proposalId:"The id of the proposal to execute"},notice:"Executes a queued proposal if eta has passed"},"getActions(uint256)":{inputs:[{internalType:"uint256",name:"_proposalId",type:"uint256"}],name:"getActions",outputs:[{internalType:"string[]",name:"signatures",type:"string[]"},{internalType:"bytes[]",name:"calldatas",type:"bytes[]"}],stateMutability:"view",type:"function",params:{_proposalId:"Proposal to query."},returns:{calldatas:"Calldatas for proposal calls.",signatures:"Function signatures for proposal calls."},notice:"Gets actions of a proposal."},"getReceipt(uint256,address)":{inputs:[{internalType:"uint256",name:"_proposalId",type:"uint256"},{internalType:"address",name:"_voter",type:"address"}],name:"getReceipt",outputs:[{components:[{internalType:"bool",name:"hasVoted",type:"bool"},{internalType:"uint8",name:"support",type:"uint8"},{internalType:"uint96",name:"votes",type:"uint96"}],internalType:"struct IImpactMarketCouncil.Receipt",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{_proposalId:"the id of proposal",_voter:"The address of the voter"},returns:{_0:"The voting receipt"},notice:"Gets the receipt for a voter on a given proposal"},"initialize(uint256,address,address[])":{inputs:[{internalType:"uint256",name:"_quorumVotes",type:"uint256"},{internalType:"contract ICommunityAdmin",name:"_communityAdmin",type:"address"},{internalType:"address[]",name:"_members",type:"address[]"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_quorumVotes:"The initial quorum votes"},notice:"Used to initialize the contract during delegator constructor"},"latestProposalIds(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"latestProposalIds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The latest proposal for each proposer"},"members(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"members",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"The council members"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"proposalCalldatas(uint256,uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],name:"proposalCalldatas",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"view",type:"function",notice:"The official each proposal's calldatas: An ordered list of calldata to be passed to each call"},"proposalCount()":{inputs:[],name:"proposalCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The total number of proposals"},"proposalReceipts(uint256,address)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"address",name:"",type:"address"}],name:"proposalReceipts",outputs:[{internalType:"bool",name:"hasVoted",type:"bool"},{internalType:"uint8",name:"support",type:"uint8"},{internalType:"uint96",name:"votes",type:"uint96"}],stateMutability:"view",type:"function",notice:"The official each proposal's receipts: Receipts of ballots for the entire set of voters"},"proposalSignatures(uint256,uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],name:"proposalSignatures",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",notice:"The official each proposal's signatures: An ordered list of function signatures to be called"},"proposalTargets(uint256,uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],name:"proposalTargets",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The official each proposal's targets: An ordered list of target addresses for calls to be made"},"proposals(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"proposals",outputs:[{internalType:"uint256",name:"id",type:"uint256"},{internalType:"address",name:"proposer",type:"address"},{internalType:"uint256",name:"endBlock",type:"uint256"},{internalType:"uint256",name:"forVotes",type:"uint256"},{internalType:"uint256",name:"againstVotes",type:"uint256"},{internalType:"uint256",name:"abstainVotes",type:"uint256"},{internalType:"bool",name:"canceled",type:"bool"},{internalType:"bool",name:"executed",type:"bool"}],stateMutability:"view",type:"function",notice:"The official record of all proposals ever proposed"},"propose(address[],string[],bytes[],string)":{inputs:[{internalType:"address[]",name:"_targets",type:"address[]"},{internalType:"string[]",name:"_signatures",type:"string[]"},{internalType:"bytes[]",name:"_calldatas",type:"bytes[]"},{internalType:"string",name:"_description",type:"string"}],name:"propose",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{_calldatas:"Calldatas for proposal calls.",_description:"String description of the proposal.",_signatures:"Function signatures for proposal calls.",_targets:"Target addresses for proposal calls."},returns:{_0:"Proposal id of new proposal."},notice:"Function used to propose a new proposal. Sender must have delegates above the proposal threshold."},"quorumVotes()":{inputs:[],name:"quorumVotes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed"},"removeMember(address)":{inputs:[{internalType:"address",name:"_member",type:"address"}],name:"removeMember",outputs:[],stateMutability:"nonpayable",type:"function",params:{_member:"Member address."},notice:"Function used to remove members from the impactMarket Council."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"setQuorumVotes(uint256)":{inputs:[{internalType:"uint256",name:"_newQuorumVotes",type:"uint256"}],name:"setQuorumVotes",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newQuorumVotes:"new quorum votes"},notice:"Owner function for setting the quorum votes"},"state(uint256)":{inputs:[{internalType:"uint256",name:"_proposalId",type:"uint256"}],name:"state",outputs:[{internalType:"enum IImpactMarketCouncil.ProposalState",name:"",type:"uint8"}],stateMutability:"view",type:"function",params:{_proposalId:"The id of the proposal"},returns:{_0:"Proposal state"},notice:"Gets the state of a proposal"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},"contracts/governor/impactMarketCouncil/ImpactMarketCouncilProxy.sol:ImpactMarketCouncilProxy":{source:"contracts/governor/impactMarketCouncil/ImpactMarketCouncilProxy.sol",name:"ImpactMarketCouncilProxy",constructor:{inputs:[{internalType:"address",name:"_logic",type:"address"},{internalType:"address",name:"_proxyAdmin",type:"address"}],stateMutability:"nonpayable",type:"constructor"},fallback:{stateMutability:"payable",type:"fallback"},receive:{stateMutability:"payable",type:"receive"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"admin()":{inputs:[],name:"admin",outputs:[{internalType:"address",name:"admin_",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Returns the current admin. NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}. TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`"},"changeAdmin(address)":{inputs:[{internalType:"address",name:"newAdmin",type:"address"}],name:"changeAdmin",outputs:[],stateMutability:"nonpayable",type:"function",details:"Changes the admin of the proxy. Emits an {AdminChanged} event. NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}."},"implementation()":{inputs:[],name:"implementation",outputs:[{internalType:"address",name:"implementation_",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Returns the current implementation. NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}. TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy. NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy, and then call a function from the new implementation as specified by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the proxied contract. NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}."}}},"contracts/governor/impactMarketCouncil/interfaces/IImpactMarketCouncil.sol:IImpactMarketCouncil":{source:"contracts/governor/impactMarketCouncil/interfaces/IImpactMarketCouncil.sol",name:"IImpactMarketCouncil"},"contracts/governor/impactMarketCouncil/interfaces/ImpactMarketCouncilStorageV1.sol:ImpactMarketCouncilStorageV1":{source:"contracts/governor/impactMarketCouncil/interfaces/ImpactMarketCouncilStorageV1.sol",name:"ImpactMarketCouncilStorageV1",methods:{"communityAdmin()":{inputs:[],name:"communityAdmin",outputs:[{internalType:"contract ICommunityAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"communityProxyAdmin()":{inputs:[],name:"communityProxyAdmin",outputs:[{internalType:"contract ProxyAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"latestProposalIds(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"latestProposalIds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The latest proposal for each proposer"},"members(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"members",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"The council members"},"proposalCalldatas(uint256,uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],name:"proposalCalldatas",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"view",type:"function",notice:"The official each proposal's calldatas: An ordered list of calldata to be passed to each call"},"proposalCount()":{inputs:[],name:"proposalCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The total number of proposals"},"proposalReceipts(uint256,address)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"address",name:"",type:"address"}],name:"proposalReceipts",outputs:[{internalType:"bool",name:"hasVoted",type:"bool"},{internalType:"uint8",name:"support",type:"uint8"},{internalType:"uint96",name:"votes",type:"uint96"}],stateMutability:"view",type:"function",notice:"The official each proposal's receipts: Receipts of ballots for the entire set of voters"},"proposalSignatures(uint256,uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],name:"proposalSignatures",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",notice:"The official each proposal's signatures: An ordered list of function signatures to be called"},"proposalTargets(uint256,uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],name:"proposalTargets",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The official each proposal's targets: An ordered list of target addresses for calls to be made"},"proposals(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"proposals",outputs:[{internalType:"uint256",name:"id",type:"uint256"},{internalType:"address",name:"proposer",type:"address"},{internalType:"uint256",name:"endBlock",type:"uint256"},{internalType:"uint256",name:"forVotes",type:"uint256"},{internalType:"uint256",name:"againstVotes",type:"uint256"},{internalType:"uint256",name:"abstainVotes",type:"uint256"},{internalType:"bool",name:"canceled",type:"bool"},{internalType:"bool",name:"executed",type:"bool"}],stateMutability:"view",type:"function",notice:"The official record of all proposals ever proposed"},"quorumVotes()":{inputs:[],name:"quorumVotes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed"}}},"contracts/governor/interfaces/PACTDelegateStorageV1.sol:PACTDelegateStorageV1":{source:"contracts/governor/interfaces/PACTDelegateStorageV1.sol",name:"PACTDelegateStorageV1",title:"Storage for Governor Delegate",notice:"For future upgrades, do not change PACTDelegateStorageV1. Create a new contract which implements PACTDelegateStorageV1 and following the naming convention PACTDelegateStorageVX.",methods:{"latestProposalIds(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"latestProposalIds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The latest proposal for each proposer"},"proposalCalldatas(uint256,uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],name:"proposalCalldatas",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"view",type:"function",notice:"The official each proposal's calldatas: An ordered list of calldata to be passed to each call"},"proposalCount()":{inputs:[],name:"proposalCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The total number of proposals"},"proposalReceipts(uint256,address)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"address",name:"",type:"address"}],name:"proposalReceipts",outputs:[{internalType:"bool",name:"hasVoted",type:"bool"},{internalType:"uint8",name:"support",type:"uint8"},{internalType:"uint96",name:"votes",type:"uint96"}],stateMutability:"view",type:"function",notice:"The official each proposal's receipts: Receipts of ballots for the entire set of voters"},"proposalSignatures(uint256,uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],name:"proposalSignatures",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",notice:"The official each proposal's signatures: An ordered list of function signatures to be called"},"proposalTargets(uint256,uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],name:"proposalTargets",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The official each proposal's targets: An ordered list of target addresses for calls to be made"},"proposalThreshold()":{inputs:[],name:"proposalThreshold",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The number of votes required in order for a voter to become a proposer"},"proposalValues(uint256,uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],name:"proposalValues",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The official each proposal's values: An ordered list of values (i.e. msg.value) to be passed to the calls to be made"},"proposals(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"proposals",outputs:[{internalType:"uint256",name:"id",type:"uint256"},{internalType:"address",name:"proposer",type:"address"},{internalType:"uint256",name:"eta",type:"uint256"},{internalType:"uint256",name:"startBlock",type:"uint256"},{internalType:"uint256",name:"endBlock",type:"uint256"},{internalType:"uint256",name:"forVotes",type:"uint256"},{internalType:"uint256",name:"againstVotes",type:"uint256"},{internalType:"uint256",name:"abstainVotes",type:"uint256"},{internalType:"bool",name:"canceled",type:"bool"},{internalType:"bool",name:"executed",type:"bool"}],stateMutability:"view",type:"function",notice:"The official record of all proposals ever proposed"},"quorumVotes()":{inputs:[],name:"quorumVotes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed"},"releaseToken()":{inputs:[],name:"releaseToken",outputs:[{internalType:"contract IHasVotes",name:"",type:"address"}],stateMutability:"view",type:"function",notice:'The address of the "Release" governance token'},"timelock()":{inputs:[],name:"timelock",outputs:[{internalType:"contract TimelockInterface",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the Governance Timelock"},"token()":{inputs:[],name:"token",outputs:[{internalType:"contract IHasVotes",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the governance token"},"votingDelay()":{inputs:[],name:"votingDelay",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The delay before voting on a proposal may take place, once proposed, in blocks"},"votingPeriod()":{inputs:[],name:"votingPeriod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The duration of voting on a proposal, in blocks"}}},"contracts/governor/interfaces/PACTEvents.sol:PACTEvents":{source:"contracts/governor/interfaces/PACTEvents.sol",name:"PACTEvents",events:{"NewAdmin(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"NewAdmin",type:"event",notice:"Emitted when pendingAdmin is accepted, which means admin is updated"},"NewImplementation(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldImplementation",type:"address"},{indexed:!1,internalType:"address",name:"newImplementation",type:"address"}],name:"NewImplementation",type:"event",notice:"Emitted when implementation is changed"},"NewPendingAdmin(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldPendingAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newPendingAdmin",type:"address"}],name:"NewPendingAdmin",type:"event",notice:"Emitted when pendingAdmin is changed"},"ProposalCanceled(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"id",type:"uint256"}],name:"ProposalCanceled",type:"event",notice:"An event emitted when a proposal has been canceled"},"ProposalCreated(uint256,address,address[],uint256[],string[],bytes[],uint256,uint256,string)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"id",type:"uint256"},{indexed:!1,internalType:"address",name:"proposer",type:"address"},{indexed:!1,internalType:"address[]",name:"targets",type:"address[]"},{indexed:!1,internalType:"uint256[]",name:"values",type:"uint256[]"},{indexed:!1,internalType:"string[]",name:"signatures",type:"string[]"},{indexed:!1,internalType:"bytes[]",name:"calldatas",type:"bytes[]"},{indexed:!1,internalType:"uint256",name:"startBlock",type:"uint256"},{indexed:!1,internalType:"uint256",name:"endBlock",type:"uint256"},{indexed:!1,internalType:"string",name:"description",type:"string"}],name:"ProposalCreated",type:"event",notice:"An event emitted when a new proposal is created"},"ProposalExecuted(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"id",type:"uint256"}],name:"ProposalExecuted",type:"event",notice:"An event emitted when a proposal has been executed in the Timelock"},"ProposalQueued(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"id",type:"uint256"},{indexed:!1,internalType:"uint256",name:"eta",type:"uint256"}],name:"ProposalQueued",type:"event",notice:"An event emitted when a proposal has been queued in the Timelock"},"ProposalThresholdSet(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldProposalThreshold",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newProposalThreshold",type:"uint256"}],name:"ProposalThresholdSet",type:"event",notice:"Emitted when proposal threshold is set"},"QuorumVotesSet(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldQuorumVotes",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newQuorumVotes",type:"uint256"}],name:"QuorumVotesSet",type:"event",notice:"An event emitted when the quorum votes is set"},"ReleaseTokenSet(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldReleaseToken",type:"address"},{indexed:!1,internalType:"address",name:"newReleaseToken",type:"address"}],name:"ReleaseTokenSet",type:"event",notice:"Emitted when release token is set"},"TransferERC20(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"TransferERC20",type:"event",params:{amount:"Amount of the transaction",to:"Address of the receiver",token:"ERC20 token address"},notice:"Triggered when an amount of an ERC20 has been transferred from this contract to an address"},"VoteCast(address,uint256,uint8,uint256,string)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"voter",type:"address"},{indexed:!1,internalType:"uint256",name:"proposalId",type:"uint256"},{indexed:!1,internalType:"uint8",name:"support",type:"uint8"},{indexed:!1,internalType:"uint256",name:"votes",type:"uint256"},{indexed:!1,internalType:"string",name:"reason",type:"string"}],name:"VoteCast",type:"event",params:{proposalId:"The proposal id which was voted on",reason:"The reason given for the vote by the voter",support:"Support value for the vote. 0=against, 1=for, 2=abstain",voter:"The address which casted a vote",votes:"Number of votes which were cast by the voter"},notice:"An event emitted when a vote has been cast on a proposal"},"VotingDelaySet(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldVotingDelay",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newVotingDelay",type:"uint256"}],name:"VotingDelaySet",type:"event",notice:"An event emitted when the voting delay is set"},"VotingPeriodSet(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldVotingPeriod",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newVotingPeriod",type:"uint256"}],name:"VotingPeriodSet",type:"event",notice:"An event emitted when the voting period is set"}}},"contracts/governor/interfaces/TimelockInterface.sol:TimelockInterface":{source:"contracts/governor/interfaces/TimelockInterface.sol",name:"TimelockInterface",methods:{"GRACE_PERIOD()":{inputs:[],name:"GRACE_PERIOD",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"acceptAdmin()":{inputs:[],name:"acceptAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},"admin()":{inputs:[],name:"admin",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"cancelTransaction(address,uint256,string,bytes,uint256)":{inputs:[{internalType:"address",name:"_target",type:"address"},{internalType:"uint256",name:"_value",type:"uint256"},{internalType:"string",name:"_signature",type:"string"},{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"uint256",name:"_eta",type:"uint256"}],name:"cancelTransaction",outputs:[],stateMutability:"nonpayable",type:"function"},"delay()":{inputs:[],name:"delay",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"executeTransaction(address,uint256,string,bytes,uint256)":{inputs:[{internalType:"address",name:"_target",type:"address"},{internalType:"uint256",name:"_value",type:"uint256"},{internalType:"string",name:"_signature",type:"string"},{internalType:"bytes",name:"_data",type:"bytes"},{internalType:"uint256",name:"_eta",type:"uint256"}],name:"executeTransaction",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function"},"queueTransaction(address,uint256,string,bytes,uint256)":{inputs:[{internalType:"address",name:"target",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"string",name:"signature",type:"string"},{internalType:"bytes",name:"data",type:"bytes"},{internalType:"uint256",name:"eta",type:"uint256"}],name:"queueTransaction",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"nonpayable",type:"function"},"queuedTransactions(bytes32)":{inputs:[{internalType:"bytes32",name:"_hash",type:"bytes32"}],name:"queuedTransactions",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"}}},"contracts/learnAndEarn/LearnAndEarnImplementation.sol:LearnAndEarnImplementation":{source:"contracts/learnAndEarn/LearnAndEarnImplementation.sol",name:"LearnAndEarnImplementation",events:{"LevelFunded(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"levelId",type:"uint256"},{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"LevelFunded",type:"event",params:{amount:"Amount of the fund",levelId:"Id of the level",sender:"Address of the sender"},notice:"Triggered when a level has been funded"},"LevelStateChanged(uint256,uint8)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"levelId",type:"uint256"},{indexed:!0,internalType:"enum ILearnAndEarn.LevelState",name:"state",type:"uint8"}],name:"LevelStateChanged",type:"event",params:{levelId:"Id of the level",state:"New state of the level"},notice:"Triggered when a level state has been changed"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"RewardClaimed(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beneficiary",type:"address"},{indexed:!0,internalType:"uint256",name:"levelId",type:"uint256"}],name:"RewardClaimed",type:"event",params:{beneficiary:"address of the beneficiary to be rewarded",levelId:"the id of the level"},notice:"Triggered when a reward has been claimed"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"}},methods:{"addLevel(uint256,address)":{inputs:[{internalType:"uint256",name:"_levelId",type:"uint256"},{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"}],name:"addLevel",outputs:[],stateMutability:"nonpayable",type:"function",params:{_levelId:"the id of the level",_token:"the token used for reward"},notice:"Adds a new level"},"cancelLevel(uint256,address)":{inputs:[{internalType:"uint256",name:"_levelId",type:"uint256"},{internalType:"address",name:"_fundRecipient",type:"address"}],name:"cancelLevel",outputs:[],stateMutability:"nonpayable",type:"function",params:{_fundRecipient:"the address of the recipient who will receive the funds allocated for this level",_levelId:"id of the level"},notice:"Cancels a level"},"claimRewardForLevels(address,uint256[],uint256[],bytes[])":{inputs:[{internalType:"address",name:"_beneficiary",type:"address"},{internalType:"uint256[]",name:"_levelIds",type:"uint256[]"},{internalType:"uint256[]",name:"_rewardAmounts",type:"uint256[]"},{internalType:"bytes[]",name:"_signatures",type:"bytes[]"}],name:"claimRewardForLevels",outputs:[],stateMutability:"nonpayable",type:"function",params:{_beneficiary:"address of the beneficiary to be rewarded",_levelIds:"the ids of the levels",_rewardAmounts:"the amounts of the tokens to be send to the beneficiary as reward for each level",_signatures:"the signatures from the backend"},notice:"Allows beneficiaries to claim the reward for a list of levels using a signature"},"communityAdmin()":{inputs:[],name:"communityAdmin",outputs:[{internalType:"contract ICommunityAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"fundLevel(uint256,uint256)":{inputs:[{internalType:"uint256",name:"_levelId",type:"uint256"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"fundLevel",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"the amount to be funded",_levelId:"the id of the level"},notice:"Funds a level"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function",notice:"Returns the current implementation version"},"initialize(address,address)":{inputs:[{internalType:"address",name:"_signerWalletAddress",type:"address"},{internalType:"contract ICommunityAdmin",name:"_communityAdmin",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_signerWalletAddress:"Address of the backend wallet"},notice:"Used to initialize a new CommunityAdmin contract"},"levelClaims(uint256,address)":{inputs:[{internalType:"uint256",name:"_levelId",type:"uint256"},{internalType:"address",name:"_beneficiary",type:"address"}],name:"levelClaims",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_beneficiary:"address of the beneficiary",_levelId:"id of the level"},returns:{_0:"reward amount claimed by the beneficiary for a level"},notice:"Returns the reward amount claimed by a beneficiary for a level"},"levelListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"levelListAt",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_index:"index of the level"},returns:{_0:"id of the level"},notice:"Returns the id of a level from levelList"},"levelListLength()":{inputs:[],name:"levelListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"uint256 number of levels"},notice:"Returns the number of levels"},"levels(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"levels",outputs:[{internalType:"contract IERC20Upgradeable",name:"token",type:"address"},{internalType:"uint256",name:"balance",type:"uint256"},{internalType:"enum ILearnAndEarn.LevelState",name:"state",type:"uint8"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Pauses the contract"},"pauseLevel(uint256)":{inputs:[{internalType:"uint256",name:"_levelId",type:"uint256"}],name:"pauseLevel",outputs:[],stateMutability:"nonpayable",type:"function",params:{_levelId:"id of the level"},notice:"Pauses a level"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if the contract is paused, and false otherwise."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"signerWalletAddress()":{inputs:[],name:"signerWalletAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Unpauses the contract"},"unpauseLevel(uint256)":{inputs:[{internalType:"uint256",name:"_levelId",type:"uint256"}],name:"unpauseLevel",outputs:[],stateMutability:"nonpayable",type:"function",params:{_levelId:"id of the level"},notice:"Unpauses a level"},"updateCommunityAdmin(address)":{inputs:[{internalType:"contract ICommunityAdmin",name:"_newCommunityAdmin",type:"address"}],name:"updateCommunityAdmin",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newCommunityAdmin:"address of the new CommunityAdmin contract"},notice:"Updates the CommunityAdmin contract address"},"updateSignerWalletAddress(address)":{inputs:[{internalType:"address",name:"_newSignerWalletAddress",type:"address"}],name:"updateSignerWalletAddress",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newSignerWalletAddress:"address of the new backend wallet"},notice:"Updates the address of the backend wallet"}}},"contracts/learnAndEarn/LearnAndEarnProxy.sol:LearnAndEarnProxy":{source:"contracts/learnAndEarn/LearnAndEarnProxy.sol",name:"LearnAndEarnProxy",constructor:{inputs:[{internalType:"address",name:"_logic",type:"address"},{internalType:"address",name:"_proxyAdmin",type:"address"}],stateMutability:"nonpayable",type:"constructor"},fallback:{stateMutability:"payable",type:"fallback"},receive:{stateMutability:"payable",type:"receive"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"admin()":{inputs:[],name:"admin",outputs:[{internalType:"address",name:"admin_",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Returns the current admin. NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}. TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`"},"changeAdmin(address)":{inputs:[{internalType:"address",name:"newAdmin",type:"address"}],name:"changeAdmin",outputs:[],stateMutability:"nonpayable",type:"function",details:"Changes the admin of the proxy. Emits an {AdminChanged} event. NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}."},"implementation()":{inputs:[],name:"implementation",outputs:[{internalType:"address",name:"implementation_",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Returns the current implementation. NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}. TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy. NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy, and then call a function from the new implementation as specified by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the proxied contract. NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}."}}},"contracts/learnAndEarn/interfaces/ILearnAndEarn.sol:ILearnAndEarn":{source:"contracts/learnAndEarn/interfaces/ILearnAndEarn.sol",name:"ILearnAndEarn",methods:{"addLevel(uint256,address)":{inputs:[{internalType:"uint256",name:"_levelId",type:"uint256"},{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"}],name:"addLevel",outputs:[],stateMutability:"nonpayable",type:"function"},"cancelLevel(uint256,address)":{inputs:[{internalType:"uint256",name:"_levelId",type:"uint256"},{internalType:"address",name:"_fundRecipient",type:"address"}],name:"cancelLevel",outputs:[],stateMutability:"nonpayable",type:"function"},"claimRewardForLevels(address,uint256[],uint256[],bytes[])":{inputs:[{internalType:"address",name:"_beneficiary",type:"address"},{internalType:"uint256[]",name:"_levelIds",type:"uint256[]"},{internalType:"uint256[]",name:"_rewardAmounts",type:"uint256[]"},{internalType:"bytes[]",name:"_signatures",type:"bytes[]"}],name:"claimRewardForLevels",outputs:[],stateMutability:"nonpayable",type:"function"},"communityAdmin()":{inputs:[],name:"communityAdmin",outputs:[{internalType:"contract ICommunityAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"fundLevel(uint256,uint256)":{inputs:[{internalType:"uint256",name:"_levelId",type:"uint256"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"fundLevel",outputs:[],stateMutability:"nonpayable",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"levelClaims(uint256,address)":{inputs:[{internalType:"uint256",name:"_levelId",type:"uint256"},{internalType:"address",name:"_beneficiary",type:"address"}],name:"levelClaims",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"levelListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"levelListAt",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"levelListLength()":{inputs:[],name:"levelListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"levels(uint256)":{inputs:[{internalType:"uint256",name:"_levelId",type:"uint256"}],name:"levels",outputs:[{internalType:"contract IERC20Upgradeable",name:"token",type:"address"},{internalType:"uint256",name:"balance",type:"uint256"},{internalType:"enum ILearnAndEarn.LevelState",name:"state",type:"uint8"}],stateMutability:"view",type:"function"},"pauseLevel(uint256)":{inputs:[{internalType:"uint256",name:"_levelId",type:"uint256"}],name:"pauseLevel",outputs:[],stateMutability:"nonpayable",type:"function"},"signerWalletAddress()":{inputs:[],name:"signerWalletAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"unpauseLevel(uint256)":{inputs:[{internalType:"uint256",name:"_levelId",type:"uint256"}],name:"unpauseLevel",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityAdmin(address)":{inputs:[{internalType:"contract ICommunityAdmin",name:"_communityAdmin",type:"address"}],name:"updateCommunityAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},"updateSignerWalletAddress(address)":{inputs:[{internalType:"address",name:"_newSignerAddress",type:"address"}],name:"updateSignerWalletAddress",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/learnAndEarn/interfaces/LearnAndEarnStorageV1.sol:LearnAndEarnStorageV1":{source:"contracts/learnAndEarn/interfaces/LearnAndEarnStorageV1.sol",name:"LearnAndEarnStorageV1",title:"Storage for LearnAndEarn",notice:"For future upgrades, do not change LearnAndEarnStorageV1. Create a new contract which implements LearnAndEarnStorageV1 and following the naming convention LearnAndEarnStorageVX.",methods:{"addLevel(uint256,address)":{inputs:[{internalType:"uint256",name:"_levelId",type:"uint256"},{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"}],name:"addLevel",outputs:[],stateMutability:"nonpayable",type:"function"},"cancelLevel(uint256,address)":{inputs:[{internalType:"uint256",name:"_levelId",type:"uint256"},{internalType:"address",name:"_fundRecipient",type:"address"}],name:"cancelLevel",outputs:[],stateMutability:"nonpayable",type:"function"},"claimRewardForLevels(address,uint256[],uint256[],bytes[])":{inputs:[{internalType:"address",name:"_beneficiary",type:"address"},{internalType:"uint256[]",name:"_levelIds",type:"uint256[]"},{internalType:"uint256[]",name:"_rewardAmounts",type:"uint256[]"},{internalType:"bytes[]",name:"_signatures",type:"bytes[]"}],name:"claimRewardForLevels",outputs:[],stateMutability:"nonpayable",type:"function"},"communityAdmin()":{inputs:[],name:"communityAdmin",outputs:[{internalType:"contract ICommunityAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"fundLevel(uint256,uint256)":{inputs:[{internalType:"uint256",name:"_levelId",type:"uint256"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"fundLevel",outputs:[],stateMutability:"nonpayable",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"levelClaims(uint256,address)":{inputs:[{internalType:"uint256",name:"_levelId",type:"uint256"},{internalType:"address",name:"_beneficiary",type:"address"}],name:"levelClaims",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"levelListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"levelListAt",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"levelListLength()":{inputs:[],name:"levelListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"levels(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"levels",outputs:[{internalType:"contract IERC20Upgradeable",name:"token",type:"address"},{internalType:"uint256",name:"balance",type:"uint256"},{internalType:"enum ILearnAndEarn.LevelState",name:"state",type:"uint8"}],stateMutability:"view",type:"function"},"pauseLevel(uint256)":{inputs:[{internalType:"uint256",name:"_levelId",type:"uint256"}],name:"pauseLevel",outputs:[],stateMutability:"nonpayable",type:"function"},"signerWalletAddress()":{inputs:[],name:"signerWalletAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"unpauseLevel(uint256)":{inputs:[{internalType:"uint256",name:"_levelId",type:"uint256"}],name:"unpauseLevel",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityAdmin(address)":{inputs:[{internalType:"contract ICommunityAdmin",name:"_communityAdmin",type:"address"}],name:"updateCommunityAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},"updateSignerWalletAddress(address)":{inputs:[{internalType:"address",name:"_newSignerAddress",type:"address"}],name:"updateSignerWalletAddress",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/mocks/community/CommunityAdminImplementationOld.sol:CommunityAdminImplementationOld":{source:"contracts/mocks/community/CommunityAdminImplementationOld.sol",name:"CommunityAdminImplementationOld",notice:"Welcome to CommunityAdmin, the main contract. This is an administrative (for now) contract where the admins have control over the list of communities. Being only able to add and remove communities",events:{"CommunityAdded(address,address[],uint256,uint256,uint256,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"communityAddress",type:"address"},{indexed:!1,internalType:"address[]",name:"managers",type:"address[]"},{indexed:!1,internalType:"uint256",name:"claimAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"maxClaim",type:"uint256"},{indexed:!1,internalType:"uint256",name:"decreaseStep",type:"uint256"},{indexed:!1,internalType:"uint256",name:"baseInterval",type:"uint256"},{indexed:!1,internalType:"uint256",name:"incrementInterval",type:"uint256"},{indexed:!1,internalType:"uint256",name:"minTranche",type:"uint256"},{indexed:!1,internalType:"uint256",name:"maxTranche",type:"uint256"}],name:"CommunityAdded",type:"event",params:{baseInterval:"Value of the baseInterval",claimAmount:"Value of the claimAmount",communityAddress:"Address of the community that has been added",decreaseStep:"Value of the decreaseStep",incrementInterval:"Value of the incrementInterval",managers:"Addresses of the initial managers",maxClaim:"Value of the maxClaim",maxTranche:"Value of the maxTranche For further information regarding each parameter, see *Community* smart contract initialize method.",minTranche:"Value of the minTranche"},notice:"Triggered when a community has been added"},"CommunityFunded(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"community",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"CommunityFunded",type:"event",params:{amount:"Amount of the funding",community:"Address of the community"},notice:"Triggered when a community has been funded"},"CommunityMigrated(address[],address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address[]",name:"managers",type:"address[]"},{indexed:!0,internalType:"address",name:"communityAddress",type:"address"},{indexed:!0,internalType:"address",name:"previousCommunityAddress",type:"address"}],name:"CommunityMigrated",type:"event",params:{communityAddress:"New community address",managers:"Addresses of the new community's initial managers",previousCommunityAddress:"Old community address"},notice:"Triggered when a community has been migrated"},"CommunityRemoved(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"communityAddress",type:"address"}],name:"CommunityRemoved",type:"event",params:{communityAddress:"Address of the community that has been removed"},notice:"Triggered when a community has been removed"},"CommunityTemplateUpdated(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldCommunityTemplate",type:"address"},{indexed:!0,internalType:"address",name:"newCommunityTemplate",type:"address"}],name:"CommunityTemplateUpdated",type:"event",params:{newCommunityTemplate:"New communityTemplate address",oldCommunityTemplate:"Old communityTemplate address"},notice:"Triggered when the communityTemplate address has been updated"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"TransferERC20(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"TransferERC20",type:"event",params:{amount:"Amount of the transaction",to:"Address of the receiver",token:"ERC20 token address"},notice:"Triggered when an amount of an ERC20 has been transferred from this contract to an address"},"TreasuryUpdated(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldTreasury",type:"address"},{indexed:!0,internalType:"address",name:"newTreasury",type:"address"}],name:"TreasuryUpdated",type:"event",params:{newTreasury:"New treasury address",oldTreasury:"Old treasury address"},notice:"Triggered when the treasury address has been updated"}},methods:{"addCommunity(address[],uint256,uint256,uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"address[]",name:"_managers",type:"address[]"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"},{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"}],name:"addCommunity",outputs:[],stateMutability:"nonpayable",type:"function",params:{_baseInterval:"base interval to start claiming",_claimAmount:"base amount to be claim by the beneficiary",_decreaseStep:"value decreased from maxClaim for every beneficiary added",_incrementInterval:"increment interval used in each claim",_managers:"addresses of the community managers",_maxClaim:"limit that a beneficiary can claim at in total",_maxTranche:"maximum amount that the community will receive when requesting funds",_minTranche:"minimum amount that the community will receive when requesting funds"},notice:"Adds a new community"},"addManagerToCommunity(address,address)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"address",name:"_account",type:"address"}],name:"addManagerToCommunity",outputs:[],stateMutability:"nonpayable",type:"function",params:{_account:"address to be added as community manager",_community:"address of the community"},notice:"Adds a new manager to a community"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"communities(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"communities",outputs:[{internalType:"enum ICommunityAdmin.CommunityState",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"communityListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"communityListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{_index:"index of the community"},returns:{_0:"address of the community"},notice:"Returns the address of a community from communityList"},"communityListLength()":{inputs:[],name:"communityListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"uint256 number of communities"},notice:"Returns the number of communities"},"communityProxyAdmin()":{inputs:[],name:"communityProxyAdmin",outputs:[{internalType:"contract ProxyAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"communityTemplate()":{inputs:[],name:"communityTemplate",outputs:[{internalType:"contract ICommunity",name:"",type:"address"}],stateMutability:"view",type:"function"},"fundCommunity()":{inputs:[],name:"fundCommunity",outputs:[],stateMutability:"nonpayable",type:"function",details:"Funds an existing community if it hasn't enough funds"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function",notice:"Returns the current implementation version"},"initialize(address,address)":{inputs:[{internalType:"contract ICommunity",name:"_communityTemplate",type:"address"},{internalType:"contract IERC20Upgradeable",name:"_cUSD",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_cUSD:"Address of the cUSD token",_communityTemplate:"Address of the Community implementation                              used for deploying new communities"},notice:"Used to initialize a new CommunityAdmin contract"},"migrateCommunity(address[],address)":{inputs:[{internalType:"address[]",name:"_managers",type:"address[]"},{internalType:"contract ICommunity",name:"_previousCommunity",type:"address"}],name:"migrateCommunity",outputs:[],stateMutability:"nonpayable",type:"function",params:{_managers:"address of the community managers",_previousCommunity:"address of the community to be migrated"},notice:"Migrates a community by deploying a new contract."},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"removeCommunity(address)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"}],name:"removeCommunity",outputs:[],stateMutability:"nonpayable",type:"function",params:{_community:"address of the community"},notice:"Removes an existing community. All community funds are transferred to the treasury"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"amount of the transaction",_to:"address of the receiver",_token:"address of the ERC20 token"},notice:"Transfers an amount of an ERC20 from this contract to an address"},"transferFromCommunity(address,address,address,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transferFromCommunity",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"amount of the transaction",_community:"address of the community",_to:"address of the receiver",_token:"address of the ERC20 token"},notice:"Transfers an amount of an ERC20 from  community to an address"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"contract ITreasury",name:"",type:"address"}],stateMutability:"view",type:"function"},"updateBeneficiaryParams(address,uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"}],name:"updateBeneficiaryParams",outputs:[],stateMutability:"nonpayable",type:"function",params:{_baseInterval:"base interval to start claiming",_claimAmount:"base amount to be claim by the beneficiary",_community:"address of the community",_decreaseStep:"value decreased from maxClaim each time a is beneficiary added",_incrementInterval:"increment interval used in each claim",_maxClaim:"limit that a beneficiary can claim  in total"},notice:"Updates the beneficiary params of a community"},"updateCommunityParams(address,uint256,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"}],name:"updateCommunityParams",outputs:[],stateMutability:"nonpayable",type:"function",params:{_community:"address of the community",_maxTranche:"maximum amount that the community will receive when requesting funds",_minTranche:"minimum amount that the community will receive when requesting funds"},notice:"Updates params of a community"},"updateCommunityTemplate(address)":{inputs:[{internalType:"contract ICommunity",name:"_newCommunityTemplate",type:"address"}],name:"updateCommunityTemplate",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newCommunityTemplate:"address of the new communityTemplate contract"},notice:"Updates the address of the the communityTemplate"},"updateProxyImplementation(address,address)":{inputs:[{internalType:"address",name:"_communityProxy",type:"address"},{internalType:"address",name:"_newCommunityTemplate",type:"address"}],name:"updateProxyImplementation",outputs:[],stateMutability:"nonpayable",type:"function",params:{_communityProxy:"address of the community",_newCommunityTemplate:"address of new implementation contract"},notice:"Updates proxy implementation address of a community"},"updateTreasury(address)":{inputs:[{internalType:"contract ITreasury",name:"_newTreasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newTreasury:"address of the new treasury contract"},notice:"Updates the address of the treasury"}}},"contracts/mocks/community/CommunityOld.sol:CommunityOld":{source:"contracts/mocks/community/CommunityOld.sol",name:"CommunityOld",notice:"Welcome to the Community contract. For each community there will be one proxy contract deployed by CommunityAdmin. The implementation of the proxy is this contract. This enable us to save tokens on the contract itself, and avoid the problems of having everything in one single contract. Each community has it's own members and and managers.",events:{"BeneficiaryAdded(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"manager",type:"address"},{indexed:!0,internalType:"address",name:"beneficiary",type:"address"}],name:"BeneficiaryAdded",type:"event",params:{beneficiary:"Address of the beneficiary that has been added",manager:"Address of the manager that triggered the event"},notice:"Triggered when a beneficiary has been added"},"BeneficiaryClaim(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beneficiary",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"BeneficiaryClaim",type:"event",params:{amount:"Amount of the claim",beneficiary:"Address of the beneficiary that has claimed"},notice:"Triggered when a beneficiary has claimed"},"BeneficiaryJoined(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beneficiary",type:"address"}],name:"BeneficiaryJoined",type:"event",params:{beneficiary:"Address of the beneficiary"},notice:"Triggered when a beneficiary from previous community has joined in the current community"},"BeneficiaryLocked(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"manager",type:"address"},{indexed:!0,internalType:"address",name:"beneficiary",type:"address"}],name:"BeneficiaryLocked",type:"event",params:{beneficiary:"Address of the beneficiary that has been locked",manager:"Address of the manager that triggered the event"},notice:"Triggered when a beneficiary has been locked"},"BeneficiaryParamsUpdated(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldClaimAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldMaxClaim",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldDecreaseStep",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldBaseInterval",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldIncrementInterval",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newClaimAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newMaxClaim",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newDecreaseStep",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newBaseInterval",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newIncrementInterval",type:"uint256"}],name:"BeneficiaryParamsUpdated",type:"event",params:{newBaseInterval:"New baseInterval value",newClaimAmount:"New claimAmount value",newDecreaseStep:"New decreaseStep value",newIncrementInterval:"New incrementInterval value For further information regarding each parameter, see *Community* smart contract initialize method.",newMaxClaim:"New maxClaim value",oldBaseInterval:"Old baseInterval value",oldClaimAmount:"Old claimAmount value",oldDecreaseStep:"Old decreaseStep value",oldIncrementInterval:"Old incrementInterval value",oldMaxClaim:"Old maxClaim value"},notice:"Triggered when beneficiary params has been updated"},"BeneficiaryRemoved(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"manager",type:"address"},{indexed:!0,internalType:"address",name:"beneficiary",type:"address"}],name:"BeneficiaryRemoved",type:"event",params:{beneficiary:"Address of the beneficiary that has been removed",manager:"Address of the manager that triggered the event"},notice:"Triggered when a beneficiary has been removed"},"BeneficiaryUnlocked(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"manager",type:"address"},{indexed:!0,internalType:"address",name:"beneficiary",type:"address"}],name:"BeneficiaryUnlocked",type:"event",params:{beneficiary:"Address of the beneficiary that has been unlocked",manager:"Address of the manager that triggered the event"},notice:"Triggered when a beneficiary has been unlocked"},"CommunityAdminUpdated(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldCommunityAdmin",type:"address"},{indexed:!0,internalType:"address",name:"newCommunityAdmin",type:"address"}],name:"CommunityAdminUpdated",type:"event",params:{newCommunityAdmin:"New communityAdmin address",oldCommunityAdmin:"Old communityAdmin address"},notice:"Triggered when communityAdmin has been updated"},"CommunityLocked(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"manager",type:"address"}],name:"CommunityLocked",type:"event",params:{manager:"Address of the manager that triggered the event"},notice:"Triggered when a community has been locked"},"CommunityParamsUpdated(uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldMinTranche",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldMaxTranche",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newMinTranche",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newMaxTranche",type:"uint256"}],name:"CommunityParamsUpdated",type:"event",params:{newMaxTranche:"New maxTranche value For further information regarding each parameter, see *Community* smart contract initialize method.",newMinTranche:"New minTranche value",oldMaxTranche:"Old maxTranche value",oldMinTranche:"Old minTranche value"},notice:"Triggered when community params has been updated"},"CommunityUnlocked(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"manager",type:"address"}],name:"CommunityUnlocked",type:"event",params:{manager:"Address of the manager that triggered the event"},notice:"Triggered when a community has been unlocked"},"Donate(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"donor",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Donate",type:"event",params:{amount:"Amount of the donation",donor:"Address of the donor"},notice:"Triggered when someone has donated cUSD"},"FundsRequested(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"manager",type:"address"}],name:"FundsRequested",type:"event",params:{manager:"Address of the manager that triggered the event"},notice:"Triggered when a manager has requested funds for community"},"ManagerAdded(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"manager",type:"address"},{indexed:!0,internalType:"address",name:"account",type:"address"}],name:"ManagerAdded",type:"event",params:{account:"Address of the manager that has been added",manager:"Address of the manager that triggered the event                          or address of the CommunityAdmin if it's first manager"},notice:"Triggered when a manager has been added"},"ManagerRemoved(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"manager",type:"address"},{indexed:!0,internalType:"address",name:"account",type:"address"}],name:"ManagerRemoved",type:"event",params:{account:"Address of the manager that has been removed",manager:"Address of the manager that triggered the event"},notice:"Triggered when a manager has been removed"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"PreviousCommunityUpdated(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldPreviousCommunity",type:"address"},{indexed:!0,internalType:"address",name:"newPreviousCommunity",type:"address"}],name:"PreviousCommunityUpdated",type:"event",params:{newPreviousCommunity:"New previousCommunity address",oldPreviousCommunity:"Old previousCommunity address"},notice:"Triggered when previousCommunity has been updated"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"TransferERC20(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"TransferERC20",type:"event",params:{amount:"Amount of the transaction",to:"Address of the receiver",token:"ERC20 token address"},notice:"Triggered when an amount of an ERC20 has been transferred from this contract to an address"}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"_firstBlockTimestamp()":{inputs:[],name:"_firstBlockTimestamp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"addBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"addBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function",params:{_beneficiaryAddress:"address of the beneficiary to be added"},notice:"Adds a new beneficiary"},"addManager(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"addManager",outputs:[],stateMutability:"nonpayable",type:"function",params:{_account:"address of the manager to be added"},notice:"Adds a new manager"},"addTreasuryFunds(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"addTreasuryFunds",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"amount to be added to treasuryFunds"},notice:"Increases the treasuryFunds value Used by communityAdmin after an amount of cUSD are sent from the treasury"},"baseInterval()":{inputs:[],name:"baseInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"beneficiaries(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"beneficiaries",outputs:[{internalType:"enum ICommunity.BeneficiaryState",name:"state",type:"uint8"},{internalType:"uint256",name:"claims",type:"uint256"},{internalType:"uint256",name:"claimedAmount",type:"uint256"},{internalType:"uint256",name:"lastClaim",type:"uint256"}],stateMutability:"view",type:"function"},"beneficiaryJoinFromMigrated()":{inputs:[],name:"beneficiaryJoinFromMigrated",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Allows a beneficiary from the previousCommunity to join in this community"},"beneficiaryListAt(uint256)":{inputs:[{internalType:"uint256",name:"index_",type:"uint256"}],name:"beneficiaryListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{index_:"index value"},returns:{_0:"address of the beneficiary"},notice:"Returns an address from the beneficiaryList"},"beneficiaryListLength()":{inputs:[],name:"beneficiaryListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"Returns the length of the beneficiaryList"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Returns the cUSD contract address"},"claim()":{inputs:[],name:"claim",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers cUSD to a valid beneficiary"},"claimAmount()":{inputs:[],name:"claimAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimCooldown(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"claimCooldown",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_beneficiaryAddress:"address of the beneficiary"},returns:{_0:"uint256 number of block when the beneficiary can claim"},notice:"Returns the block number when a beneficiary can claim again"},"communityAdmin()":{inputs:[],name:"communityAdmin",outputs:[{internalType:"contract ICommunityAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"decreaseStep()":{inputs:[],name:"decreaseStep",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donate(address,uint256)":{inputs:[{internalType:"address",name:"_sender",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"donate",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"amount to be donated",_sender:"address of the sender"},notice:"Transfers cUSDs from donor to this community Used by donationToCommunity method from DonationMiner contract"},"getInitialMaxClaim()":{inputs:[],name:"getInitialMaxClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"Returns the initial maxClaim"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function",notice:"Returns the current implementation version"},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"",type:"bytes32"},{internalType:"address",name:"",type:"address"}],name:"grantRole",outputs:[],stateMutability:"pure",type:"function",notice:"Enforces managers to use addManager method"},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"impactMarketAddress()":{inputs:[],name:"impactMarketAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function",notice:"Returns the 0 address only used for backwards compatibility"},"incrementInterval()":{inputs:[],name:"incrementInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"initialize(address[],uint256,uint256,uint256,uint256,uint256,uint256,uint256,address)":{inputs:[{internalType:"address[]",name:"_managers",type:"address[]"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"},{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"},{internalType:"contract ICommunity",name:"_previousCommunity",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_baseInterval:"Base interval to start claiming",_claimAmount:"Base amount to be claim by the beneficiary",_decreaseStep:"Value decreased from maxClaim each time a beneficiary is added",_incrementInterval:"Increment interval used in each claim",_managers:"Community's initial managers.                             Will be able to add others",_maxClaim:"Limit that a beneficiary can claim in total",_maxTranche:"Maximum amount that the community will receive when requesting funds",_minTranche:"Minimum amount that the community will receive when requesting funds",_previousCommunity:"Previous smart contract address of community"},notice:"Used to initialize a new Community contract"},"lastFundRequest()":{inputs:[],name:"lastFundRequest",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lastInterval(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"lastInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_beneficiaryAddress:"address of the beneficiary"},returns:{_0:"uint256 number of blocks for the lastInterval"},notice:"Returns the number of blocks that a beneficiary have to wait between claims"},"lock()":{inputs:[],name:"lock",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Locks the community claims"},"lockBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"lockBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function",params:{_beneficiaryAddress:"address of the beneficiary to be locked"},notice:"Locks a valid beneficiary"},"locked()":{inputs:[],name:"locked",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"maxClaim()":{inputs:[],name:"maxClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"maxTranche()":{inputs:[],name:"maxTranche",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minTranche()":{inputs:[],name:"minTranche",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"previousCommunity()":{inputs:[],name:"previousCommunity",outputs:[{internalType:"contract ICommunity",name:"",type:"address"}],stateMutability:"view",type:"function"},"privateFunds()":{inputs:[],name:"privateFunds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"removeBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"removeBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function",params:{_beneficiaryAddress:"address of the beneficiary to be removed"},notice:"Remove an existing beneficiary"},"removeManager(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"removeManager",outputs:[],stateMutability:"nonpayable",type:"function",params:{_account:"address of the manager to be removed"},notice:"Remove an existing manager"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"requestFunds()":{inputs:[],name:"requestFunds",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Requests treasury funds from the communityAdmin"},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"",type:"bytes32"},{internalType:"address",name:"",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"pure",type:"function",notice:"Enforces managers to use removeManager method"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"amount of the transaction",_to:"address of the receiver",_token:"address of the ERC20 token"},notice:"Transfers an amount of an ERC20 from this contract to an address"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"treasuryFunds()":{inputs:[],name:"treasuryFunds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"unlock()":{inputs:[],name:"unlock",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Unlocks the community claims"},"unlockBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"unlockBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function",params:{_beneficiaryAddress:"address of the beneficiary to be unlocked"},notice:"Unlocks a locked beneficiary"},"updateBeneficiaryParams(uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"}],name:"updateBeneficiaryParams",outputs:[],stateMutability:"nonpayable",type:"function",params:{_baseInterval:"base interval to start claiming",_claimAmount:"base amount to be claim by the beneficiary",_decreaseStep:"value decreased from maxClaim each time a is beneficiary added",_incrementInterval:"increment interval used in each claim",_maxClaim:"limit that a beneficiary can claim  in total"},notice:"Updates beneficiary params"},"updateCommunityAdmin(address)":{inputs:[{internalType:"contract ICommunityAdmin",name:"_newCommunityAdmin",type:"address"}],name:"updateCommunityAdmin",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newCommunityAdmin:"address of the new communityAdmin"},notice:"Updates the address of the communityAdmin"},"updateCommunityParams(uint256,uint256)":{inputs:[{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"}],name:"updateCommunityParams",outputs:[],stateMutability:"nonpayable",type:"function",params:{_maxTranche:"maximum amount that the community will receive when requesting funds",_minTranche:"minimum amount that the community will receive when requesting funds"},notice:"Updates params of a community"},"updatePreviousCommunity(address)":{inputs:[{internalType:"contract ICommunity",name:"_newPreviousCommunity",type:"address"}],name:"updatePreviousCommunity",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newPreviousCommunity:"address of the new previousCommunity"},notice:"Updates the address of the previousCommunity"},"validBeneficiaryCount()":{inputs:[],name:"validBeneficiaryCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/mocks/community/interfaces/CommunityAdminStorageV1.sol:CommunityAdminStorageV1":{source:"contracts/mocks/community/interfaces/CommunityAdminStorageV1.sol",name:"CommunityAdminStorageV1",title:"Storage for CommunityAdmin",notice:"For future upgrades, do not change CommunityAdminStorageV1. Create a new contract which implements CommunityAdminStorageV1 and following the naming convention CommunityAdminStorageVX.",methods:{"addCommunity(address[],uint256,uint256,uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"address[]",name:"_managers",type:"address[]"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"},{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"}],name:"addCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"addManagerToCommunity(address,address)":{inputs:[{internalType:"contract ICommunity",name:"_community_",type:"address"},{internalType:"address",name:"_account_",type:"address"}],name:"addManagerToCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"communities(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"communities",outputs:[{internalType:"enum ICommunityAdmin.CommunityState",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"communityListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"communityListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"communityListLength()":{inputs:[],name:"communityListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"communityProxyAdmin()":{inputs:[],name:"communityProxyAdmin",outputs:[{internalType:"contract ProxyAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"communityTemplate()":{inputs:[],name:"communityTemplate",outputs:[{internalType:"contract ICommunity",name:"",type:"address"}],stateMutability:"view",type:"function"},"fundCommunity()":{inputs:[],name:"fundCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"migrateCommunity(address[],address)":{inputs:[{internalType:"address[]",name:"_managers",type:"address[]"},{internalType:"contract ICommunity",name:"_previousCommunity",type:"address"}],name:"migrateCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"removeCommunity(address)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"}],name:"removeCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"transferFromCommunity(address,address,address,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transferFromCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"contract ITreasury",name:"",type:"address"}],stateMutability:"view",type:"function"},"updateBeneficiaryParams(address,uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"}],name:"updateBeneficiaryParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityParams(address,uint256,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"}],name:"updateCommunityParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityTemplate(address)":{inputs:[{internalType:"contract ICommunity",name:"_communityTemplate_",type:"address"}],name:"updateCommunityTemplate",outputs:[],stateMutability:"nonpayable",type:"function"},"updateProxyImplementation(address,address)":{inputs:[{internalType:"address",name:"_communityProxy",type:"address"},{internalType:"address",name:"_newLogic",type:"address"}],name:"updateProxyImplementation",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasury(address)":{inputs:[{internalType:"contract ITreasury",name:"_newTreasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/mocks/community/interfaces/CommunityStorageV1.sol:CommunityStorageV1":{source:"contracts/mocks/community/interfaces/CommunityStorageV1.sol",name:"CommunityStorageV1",title:"Storage for Community",notice:"For future upgrades, do not change CommunityStorageV1. Create a new contract which implements CommunityStorageV1 and following the naming convention CommunityStorageVX.",methods:{"addBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"addBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"addManager(address)":{inputs:[{internalType:"address",name:"_managerAddress",type:"address"}],name:"addManager",outputs:[],stateMutability:"nonpayable",type:"function"},"addTreasuryFunds(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"addTreasuryFunds",outputs:[],stateMutability:"nonpayable",type:"function"},"baseInterval()":{inputs:[],name:"baseInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"beneficiaries(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"beneficiaries",outputs:[{internalType:"enum ICommunity.BeneficiaryState",name:"state",type:"uint8"},{internalType:"uint256",name:"claims",type:"uint256"},{internalType:"uint256",name:"claimedAmount",type:"uint256"},{internalType:"uint256",name:"lastClaim",type:"uint256"}],stateMutability:"view",type:"function"},"beneficiaryJoinFromMigrated()":{inputs:[],name:"beneficiaryJoinFromMigrated",outputs:[],stateMutability:"nonpayable",type:"function"},"beneficiaryListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"beneficiaryListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"beneficiaryListLength()":{inputs:[],name:"beneficiaryListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"claim()":{inputs:[],name:"claim",outputs:[],stateMutability:"nonpayable",type:"function"},"claimAmount()":{inputs:[],name:"claimAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimCooldown(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"claimCooldown",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"communityAdmin()":{inputs:[],name:"communityAdmin",outputs:[{internalType:"contract ICommunityAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"decreaseStep()":{inputs:[],name:"decreaseStep",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donate(address,uint256)":{inputs:[{internalType:"address",name:"_sender",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"donate",outputs:[],stateMutability:"nonpayable",type:"function"},"getInitialMaxClaim()":{inputs:[],name:"getInitialMaxClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"impactMarketAddress()":{inputs:[],name:"impactMarketAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"},"incrementInterval()":{inputs:[],name:"incrementInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lastFundRequest()":{inputs:[],name:"lastFundRequest",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lastInterval(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"lastInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lock()":{inputs:[],name:"lock",outputs:[],stateMutability:"nonpayable",type:"function"},"lockBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"lockBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"locked()":{inputs:[],name:"locked",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"maxClaim()":{inputs:[],name:"maxClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"maxTranche()":{inputs:[],name:"maxTranche",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minTranche()":{inputs:[],name:"minTranche",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"previousCommunity()":{inputs:[],name:"previousCommunity",outputs:[{internalType:"contract ICommunity",name:"",type:"address"}],stateMutability:"view",type:"function"},"privateFunds()":{inputs:[],name:"privateFunds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"removeBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"removeBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"removeManager(address)":{inputs:[{internalType:"address",name:"_managerAddress",type:"address"}],name:"removeManager",outputs:[],stateMutability:"nonpayable",type:"function"},"requestFunds()":{inputs:[],name:"requestFunds",outputs:[],stateMutability:"nonpayable",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"treasuryFunds()":{inputs:[],name:"treasuryFunds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"unlock()":{inputs:[],name:"unlock",outputs:[],stateMutability:"nonpayable",type:"function"},"unlockBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"unlockBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"updateBeneficiaryParams(uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"}],name:"updateBeneficiaryParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityAdmin(address)":{inputs:[{internalType:"contract ICommunityAdmin",name:"_communityAdmin",type:"address"}],name:"updateCommunityAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityParams(uint256,uint256)":{inputs:[{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"}],name:"updateCommunityParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updatePreviousCommunity(address)":{inputs:[{internalType:"contract ICommunity",name:"_newPreviousCommunity",type:"address"}],name:"updatePreviousCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"validBeneficiaryCount()":{inputs:[],name:"validBeneficiaryCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/mocks/community/interfaces/ICommunity.sol:ICommunity":{source:"contracts/mocks/community/interfaces/ICommunity.sol",name:"ICommunity",methods:{"addBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"addBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"addManager(address)":{inputs:[{internalType:"address",name:"_managerAddress",type:"address"}],name:"addManager",outputs:[],stateMutability:"nonpayable",type:"function"},"addTreasuryFunds(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"addTreasuryFunds",outputs:[],stateMutability:"nonpayable",type:"function"},"baseInterval()":{inputs:[],name:"baseInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"beneficiaries(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"beneficiaries",outputs:[{internalType:"enum ICommunity.BeneficiaryState",name:"state",type:"uint8"},{internalType:"uint256",name:"claims",type:"uint256"},{internalType:"uint256",name:"claimedAmount",type:"uint256"},{internalType:"uint256",name:"lastClaim",type:"uint256"}],stateMutability:"view",type:"function"},"beneficiaryJoinFromMigrated()":{inputs:[],name:"beneficiaryJoinFromMigrated",outputs:[],stateMutability:"nonpayable",type:"function"},"beneficiaryListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"beneficiaryListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"beneficiaryListLength()":{inputs:[],name:"beneficiaryListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"claim()":{inputs:[],name:"claim",outputs:[],stateMutability:"nonpayable",type:"function"},"claimAmount()":{inputs:[],name:"claimAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimCooldown(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"claimCooldown",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"communityAdmin()":{inputs:[],name:"communityAdmin",outputs:[{internalType:"contract ICommunityAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"decreaseStep()":{inputs:[],name:"decreaseStep",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donate(address,uint256)":{inputs:[{internalType:"address",name:"_sender",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"donate",outputs:[],stateMutability:"nonpayable",type:"function"},"getInitialMaxClaim()":{inputs:[],name:"getInitialMaxClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"impactMarketAddress()":{inputs:[],name:"impactMarketAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"},"incrementInterval()":{inputs:[],name:"incrementInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lastFundRequest()":{inputs:[],name:"lastFundRequest",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lastInterval(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"lastInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lock()":{inputs:[],name:"lock",outputs:[],stateMutability:"nonpayable",type:"function"},"lockBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"lockBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"locked()":{inputs:[],name:"locked",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"maxClaim()":{inputs:[],name:"maxClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"maxTranche()":{inputs:[],name:"maxTranche",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minTranche()":{inputs:[],name:"minTranche",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"previousCommunity()":{inputs:[],name:"previousCommunity",outputs:[{internalType:"contract ICommunity",name:"",type:"address"}],stateMutability:"view",type:"function"},"privateFunds()":{inputs:[],name:"privateFunds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"removeBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"removeBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"removeManager(address)":{inputs:[{internalType:"address",name:"_managerAddress",type:"address"}],name:"removeManager",outputs:[],stateMutability:"nonpayable",type:"function"},"requestFunds()":{inputs:[],name:"requestFunds",outputs:[],stateMutability:"nonpayable",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"treasuryFunds()":{inputs:[],name:"treasuryFunds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"unlock()":{inputs:[],name:"unlock",outputs:[],stateMutability:"nonpayable",type:"function"},"unlockBeneficiary(address)":{inputs:[{internalType:"address",name:"_beneficiaryAddress",type:"address"}],name:"unlockBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"updateBeneficiaryParams(uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"}],name:"updateBeneficiaryParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityAdmin(address)":{inputs:[{internalType:"contract ICommunityAdmin",name:"_communityAdmin",type:"address"}],name:"updateCommunityAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityParams(uint256,uint256)":{inputs:[{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"}],name:"updateCommunityParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updatePreviousCommunity(address)":{inputs:[{internalType:"contract ICommunity",name:"_newPreviousCommunity",type:"address"}],name:"updatePreviousCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"validBeneficiaryCount()":{inputs:[],name:"validBeneficiaryCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/mocks/community/interfaces/ICommunityAdmin.sol:ICommunityAdmin":{source:"contracts/mocks/community/interfaces/ICommunityAdmin.sol",name:"ICommunityAdmin",methods:{"addCommunity(address[],uint256,uint256,uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"address[]",name:"_managers",type:"address[]"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"},{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"}],name:"addCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"addManagerToCommunity(address,address)":{inputs:[{internalType:"contract ICommunity",name:"_community_",type:"address"},{internalType:"address",name:"_account_",type:"address"}],name:"addManagerToCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"communities(address)":{inputs:[{internalType:"address",name:"_community",type:"address"}],name:"communities",outputs:[{internalType:"enum ICommunityAdmin.CommunityState",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"communityListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"communityListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"communityListLength()":{inputs:[],name:"communityListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"communityProxyAdmin()":{inputs:[],name:"communityProxyAdmin",outputs:[{internalType:"contract ProxyAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"communityTemplate()":{inputs:[],name:"communityTemplate",outputs:[{internalType:"contract ICommunity",name:"",type:"address"}],stateMutability:"view",type:"function"},"fundCommunity()":{inputs:[],name:"fundCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"migrateCommunity(address[],address)":{inputs:[{internalType:"address[]",name:"_managers",type:"address[]"},{internalType:"contract ICommunity",name:"_previousCommunity",type:"address"}],name:"migrateCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"removeCommunity(address)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"}],name:"removeCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"transferFromCommunity(address,address,address,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transferFromCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"contract ITreasury",name:"",type:"address"}],stateMutability:"view",type:"function"},"updateBeneficiaryParams(address,uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_decreaseStep",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"}],name:"updateBeneficiaryParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityParams(address,uint256,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_minTranche",type:"uint256"},{internalType:"uint256",name:"_maxTranche",type:"uint256"}],name:"updateCommunityParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityTemplate(address)":{inputs:[{internalType:"contract ICommunity",name:"_communityTemplate_",type:"address"}],name:"updateCommunityTemplate",outputs:[],stateMutability:"nonpayable",type:"function"},"updateProxyImplementation(address,address)":{inputs:[{internalType:"address",name:"_communityProxy",type:"address"},{internalType:"address",name:"_newLogic",type:"address"}],name:"updateProxyImplementation",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasury(address)":{inputs:[{internalType:"contract ITreasury",name:"_newTreasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/mocks/community/interfaces/ICommunityOld.sol:ICommunityOld":{source:"contracts/mocks/community/interfaces/ICommunityOld.sol",name:"ICommunityOld",methods:{"addBeneficiary(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"addBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"addManager(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"addManager",outputs:[],stateMutability:"nonpayable",type:"function"},"baseInterval()":{inputs:[],name:"baseInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"beneficiaries(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"beneficiaries",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"cUSDAddress()":{inputs:[],name:"cUSDAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function"},"claim()":{inputs:[],name:"claim",outputs:[],stateMutability:"nonpayable",type:"function"},"claimAmount()":{inputs:[],name:"claimAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"claimed(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"claimed",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"cooldown(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"cooldown",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"edit(uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_claimAmount",type:"uint256"},{internalType:"uint256",name:"_maxClaim",type:"uint256"},{internalType:"uint256",name:"_baseInterval",type:"uint256"},{internalType:"uint256",name:"_incrementInterval",type:"uint256"}],name:"edit",outputs:[],stateMutability:"nonpayable",type:"function"},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"impactMarketAddress()":{inputs:[],name:"impactMarketAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function"},"incrementInterval()":{inputs:[],name:"incrementInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"lastInterval(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"lastInterval",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"lock()":{inputs:[],name:"lock",outputs:[],stateMutability:"nonpayable",type:"function"},"lockBeneficiary(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"lockBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"locked()":{inputs:[],name:"locked",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"maxClaim()":{inputs:[],name:"maxClaim",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"migrateFunds(address,address)":{inputs:[{internalType:"address",name:"_newCommunity",type:"address"},{internalType:"address",name:"_newCommunityManager",type:"address"}],name:"migrateFunds",outputs:[],stateMutability:"nonpayable",type:"function"},"previousCommunityContract()":{inputs:[],name:"previousCommunityContract",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function"},"removeBeneficiary(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"removeBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"},"removeManager(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"removeManager",outputs:[],stateMutability:"nonpayable",type:"function"},"unlock()":{inputs:[],name:"unlock",outputs:[],stateMutability:"nonpayable",type:"function"},"unlockBeneficiary(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"unlockBeneficiary",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/mocks/donationMiner/DonationMinerImplementationOld.sol:DonationMinerImplementationOld":{source:"contracts/mocks/donationMiner/DonationMinerImplementationOld.sol",name:"DonationMinerImplementationOld",events:{"AgainstPeriodsUpdated(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldAgainstPeriods",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newAgainstPeriods",type:"uint256"}],name:"AgainstPeriodsUpdated",type:"event",params:{newAgainstPeriods:"New againstPeriods value",oldAgainstPeriods:"Old againstPeriods value"},notice:"Triggered when the againstPeriods value has been updated"},"ClaimDelayUpdated(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldClaimDelay",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newClaimDelay",type:"uint256"}],name:"ClaimDelayUpdated",type:"event",params:{newClaimDelay:"New claimDelay value",oldClaimDelay:"Old claimDelay value"},notice:"Triggered when the claimDelay value has been updated"},"DonationAdded(uint256,address,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"donationId",type:"uint256"},{indexed:!0,internalType:"address",name:"donor",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!0,internalType:"address",name:"target",type:"address"}],name:"DonationAdded",type:"event",params:{amount:"Value of the donation",donationId:"Id of the donation",donor:"Address of the donner",target:"Address of the receiver (community or treasury)                    or address of the DonationMiner contract otherwise"},notice:"Triggered when a donation has been added"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"RewardClaimed(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"donor",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"RewardClaimed",type:"event",params:{amount:"Value of the reward",donor:"Address of the donner"},notice:"Triggered when a donor has claimed his reward"},"RewardClaimedPartial(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"donor",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"lastRewardPeriod",type:"uint256"}],name:"RewardClaimedPartial",type:"event",params:{amount:"Value of the reward",donor:"Address of the donner",lastRewardPeriod:"Number of the last reward period for witch tha claim was made"},notice:"Triggered when a donor has claimed his reward"},"RewardPeriodParamsUpdated(uint256,uint256,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldRewardPeriodSize",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldDecayNumerator",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldDecayDenominator",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newRewardPeriodSize",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newDecayNumerator",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newDecayDenominator",type:"uint256"}],name:"RewardPeriodParamsUpdated",type:"event",params:{newDecayDenominator:"New decayDenominator value For further information regarding each parameter, see *DonationMiner* smart contract initialize method.",newDecayNumerator:"New decayNumerator value",newRewardPeriodSize:"New rewardPeriodSize value",oldDecayDenominator:"Old decayDenominator value",oldDecayNumerator:"Old decayNumerator value",oldRewardPeriodSize:"Old rewardPeriodSize value"},notice:"Triggered when reward period params have been updated"},"TransferERC20(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"TransferERC20",type:"event",params:{amount:"Amount of the transaction",to:"Address of the receiver",token:"ERC20 token address"},notice:"Triggered when an amount of an ERC20 has been transferred from this contract to an address"},"TreasuryUpdated(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldTreasury",type:"address"},{indexed:!0,internalType:"address",name:"newTreasury",type:"address"}],name:"TreasuryUpdated",type:"event",params:{newTreasury:"New treasury address",oldTreasury:"Old treasury address"},notice:"Triggered when the treasury address has been updated"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"}},methods:{"PACT()":{inputs:[],name:"PACT",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"againstPeriods()":{inputs:[],name:"againstPeriods",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"calculateClaimableRewards(address)":{inputs:[{internalType:"address",name:"_donorAddress",type:"address"}],name:"calculateClaimableRewards",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_donorAddress:"address of the donor"},returns:{_0:"uint256 sum of all donor's rewards that has not been claimed"},notice:"Calculates the rewards from ended reward periods of a donor"},"calculateClaimableRewardsByPeriodNumber(address,uint256)":{inputs:[{internalType:"address",name:"_donorAddress",type:"address"},{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"calculateClaimableRewardsByPeriodNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_donorAddress:"address of the donor",_lastPeriodNumber:"last reward period number to be computed"},returns:{_0:"uint256 sum of all donor's rewards that has not been claimed until _lastPeriodNumber"},notice:"Calculates the rewards from ended reward periods of a donor"},"claimDelay()":{inputs:[],name:"claimDelay",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimRewards()":{inputs:[],name:"claimRewards",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Transfers to the sender the rewards"},"claimRewardsPartial(uint256)":{inputs:[{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"claimRewardsPartial",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Transfers to the sender the rewards"},"decayDenominator()":{inputs:[],name:"decayDenominator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decayNumerator()":{inputs:[],name:"decayNumerator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donate(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"donate",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"Amount of cUSD tokens to deposit."},notice:"Transfers cUSD tokens to the treasury contract"},"donateToCommunity(address,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"donateToCommunity",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers cUSD tokens to the community contract",params:{_amount:"amount of cUSD tokens to deposit",_community:"address of the community"}},"donationCount()":{inputs:[],name:"donationCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donations(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"donations",outputs:[{internalType:"address",name:"donor",type:"address"},{internalType:"address",name:"target",type:"address"},{internalType:"uint256",name:"rewardPeriod",type:"uint256"},{internalType:"uint256",name:"blockNumber",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"contract IERC20Upgradeable",name:"token",type:"address"},{internalType:"uint256",name:"tokenPrice",type:"uint256"}],stateMutability:"view",type:"function"},"donorRewardPeriod(address,uint256)":{inputs:[{internalType:"address",name:"_donor",type:"address"},{internalType:"uint256",name:"_rewardPeriodIndex",type:"uint256"}],name:"donorRewardPeriod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_donor:"address of the donor",_rewardPeriodIndex:"index of the reward period"},returns:{_0:"uint256 number of the reward period"},notice:"Returns a reward period number from a donor reward period list"},"donors(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"donors",outputs:[{internalType:"uint256",name:"lastClaim",type:"uint256"},{internalType:"uint256",name:"rewardPeriodsCount",type:"uint256"},{internalType:"uint256",name:"lastClaimPeriod",type:"uint256"}],stateMutability:"view",type:"function"},"estimateClaimableReward(address)":{inputs:[{internalType:"address",name:"_donorAddress",type:"address"}],name:"estimateClaimableReward",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_donorAddress:"address of the donor"},returns:{_0:"uint256 reward that donor will receive in current reward period if there isn't another donation"},notice:"Calculates the estimate reward of a donor for current reward period"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function",notice:"Returns the current implementation version"},"initialize(address,address,address,uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_cUSD",type:"address"},{internalType:"contract IERC20Upgradeable",name:"_PACT",type:"address"},{internalType:"contract ITreasury",name:"_treasury",type:"address"},{internalType:"uint256",name:"_firstRewardPerBlock",type:"uint256"},{internalType:"uint256",name:"_rewardPeriodSize",type:"uint256"},{internalType:"uint256",name:"_startingBlock",type:"uint256"},{internalType:"uint256",name:"_decayNumerator",type:"uint256"},{internalType:"uint256",name:"_decayDenominator",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_PACT:"Address of the PACT Token",_cUSD:"Address of the cUSD token",_decayDenominator:"Decay denominator used for calculating the new reward per block based on the previous reward per block",_decayNumerator:"Decay numerator used for calculating the new reward per block based on the previous reward per block",_firstRewardPerBlock:"Number of PACTs given for each block                              from the first reward period",_rewardPeriodSize:"Number of blocks of the reward period",_startingBlock:"First block of the first reward period",_treasury:"Address of the Treasury"},notice:"Used to initialize a new DonationMiner contract"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if the contract is paused, and false otherwise."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"rewardPeriodCount()":{inputs:[],name:"rewardPeriodCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodDonorAmount(uint256,address)":{inputs:[{internalType:"uint256",name:"_period",type:"uint256"},{internalType:"address",name:"_donor",type:"address"}],name:"rewardPeriodDonorAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_donor:"address of the donor",_period:"number of the reward period"},returns:{_0:"uint256 amount of cUSD donated by the user in this reward period"},notice:"Returns the amount of cUSD donated by a user in a reward period"},"rewardPeriodSize()":{inputs:[],name:"rewardPeriodSize",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriods(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"rewardPeriods",outputs:[{internalType:"uint256",name:"rewardPerBlock",type:"uint256"},{internalType:"uint256",name:"rewardAmount",type:"uint256"},{internalType:"uint256",name:"startBlock",type:"uint256"},{internalType:"uint256",name:"endBlock",type:"uint256"},{internalType:"uint256",name:"donationsAmount",type:"uint256"},{internalType:"uint256",name:"againstPeriods",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"amount of the transaction",_to:"address of the receiver",_token:"address of the ERC20 token"},notice:"Transfers an amount of an ERC20 from this contract to an address"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"contract ITreasury",name:"",type:"address"}],stateMutability:"view",type:"function"},"updateAgainstPeriods(uint256)":{inputs:[{internalType:"uint256",name:"_newAgainstPeriods",type:"uint256"}],name:"updateAgainstPeriods",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newAgainstPeriods:"Number of reward periods for the backward computation"},notice:"Updates againstPeriods value"},"updateClaimDelay(uint256)":{inputs:[{internalType:"uint256",name:"_newClaimDelay",type:"uint256"}],name:"updateClaimDelay",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newClaimDelay:"Number of reward periods a donor has to wait after                            a donation until he will be able to claim his reward"},notice:"Updates claimDelay value"},"updateRewardPeriodParams(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_newRewardPeriodSize",type:"uint256"},{internalType:"uint256",name:"_newDecayNumerator",type:"uint256"},{internalType:"uint256",name:"_newDecayDenominator",type:"uint256"}],name:"updateRewardPeriodParams",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newDecayDenominator:"value of new decayDenominator",_newDecayNumerator:"value of new decayNumerator",_newRewardPeriodSize:"value of new rewardPeriodSize"},notice:"Updates reward period default params"},"updateTreasury(address)":{inputs:[{internalType:"contract ITreasury",name:"_newTreasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newTreasury:"address of new treasury_ contract"},notice:"Updates Treasury address"}}},"contracts/mocks/donationMiner/interfaces/DonationMinerStorageV1Old.sol:DonationMinerStorageV1Old":{source:"contracts/mocks/donationMiner/interfaces/DonationMinerStorageV1Old.sol",name:"DonationMinerStorageV1Old",title:"Storage for DonationMiner",notice:"For future upgrades, do not change DonationMinerStorageV1. Create a new contract which implements DonationMinerStorageV1 and following the naming convention DonationMinerStorageVX.",methods:{"PACT()":{inputs:[],name:"PACT",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"againstPeriods()":{inputs:[],name:"againstPeriods",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"calculateClaimableRewards(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"calculateClaimableRewards",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"calculateClaimableRewardsByPeriodNumber(address,uint256)":{inputs:[{internalType:"address",name:"_donor",type:"address"},{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"calculateClaimableRewardsByPeriodNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"claimDelay()":{inputs:[],name:"claimDelay",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimRewards()":{inputs:[],name:"claimRewards",outputs:[],stateMutability:"nonpayable",type:"function"},"claimRewardsPartial(uint256)":{inputs:[{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"claimRewardsPartial",outputs:[],stateMutability:"nonpayable",type:"function"},"decayDenominator()":{inputs:[],name:"decayDenominator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decayNumerator()":{inputs:[],name:"decayNumerator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donate(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"donate",outputs:[],stateMutability:"nonpayable",type:"function"},"donateToCommunity(address,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"donateToCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"donationCount()":{inputs:[],name:"donationCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donations(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"donations",outputs:[{internalType:"address",name:"donor",type:"address"},{internalType:"address",name:"target",type:"address"},{internalType:"uint256",name:"rewardPeriod",type:"uint256"},{internalType:"uint256",name:"blockNumber",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"contract IERC20Upgradeable",name:"token",type:"address"},{internalType:"uint256",name:"tokenPrice",type:"uint256"}],stateMutability:"view",type:"function"},"donorRewardPeriod(address,uint256)":{inputs:[{internalType:"address",name:"_donor",type:"address"},{internalType:"uint256",name:"_rewardPeriodIndex",type:"uint256"}],name:"donorRewardPeriod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donors(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"donors",outputs:[{internalType:"uint256",name:"lastClaim",type:"uint256"},{internalType:"uint256",name:"rewardPeriodsCount",type:"uint256"},{internalType:"uint256",name:"lastClaimPeriod",type:"uint256"}],stateMutability:"view",type:"function"},"estimateClaimableReward(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"estimateClaimableReward",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"rewardPeriodCount()":{inputs:[],name:"rewardPeriodCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodDonorAmount(uint256,address)":{inputs:[{internalType:"uint256",name:"_period",type:"uint256"},{internalType:"address",name:"_donor",type:"address"}],name:"rewardPeriodDonorAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodSize()":{inputs:[],name:"rewardPeriodSize",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriods(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"rewardPeriods",outputs:[{internalType:"uint256",name:"rewardPerBlock",type:"uint256"},{internalType:"uint256",name:"rewardAmount",type:"uint256"},{internalType:"uint256",name:"startBlock",type:"uint256"},{internalType:"uint256",name:"endBlock",type:"uint256"},{internalType:"uint256",name:"donationsAmount",type:"uint256"},{internalType:"uint256",name:"againstPeriods",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"contract ITreasury",name:"",type:"address"}],stateMutability:"view",type:"function"},"updateAgainstPeriods(uint256)":{inputs:[{internalType:"uint256",name:"_newAgainstPeriods",type:"uint256"}],name:"updateAgainstPeriods",outputs:[],stateMutability:"nonpayable",type:"function"},"updateClaimDelay(uint256)":{inputs:[{internalType:"uint256",name:"_newClaimDelay",type:"uint256"}],name:"updateClaimDelay",outputs:[],stateMutability:"nonpayable",type:"function"},"updateRewardPeriodParams(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_newRewardPeriodSize",type:"uint256"},{internalType:"uint256",name:"_newDecayNumerator",type:"uint256"},{internalType:"uint256",name:"_newDecayDenominator",type:"uint256"}],name:"updateRewardPeriodParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasury(address)":{inputs:[{internalType:"contract ITreasury",name:"_newTreasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/mocks/donationMiner/interfaces/DonationMinerStorageV2Old.sol:DonationMinerStorageV2Old":{source:"contracts/mocks/donationMiner/interfaces/DonationMinerStorageV2Old.sol",name:"DonationMinerStorageV2Old",title:"Storage for DonationMiner",notice:"For future upgrades, do not change DonationMinerStorageV2. Create a new contract which implements DonationMinerStorageV2 and following the naming convention DonationMinerStorageVX.",methods:{"PACT()":{inputs:[],name:"PACT",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"againstPeriods()":{inputs:[],name:"againstPeriods",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"calculateClaimableRewards(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"calculateClaimableRewards",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"calculateClaimableRewardsByPeriodNumber(address,uint256)":{inputs:[{internalType:"address",name:"_donor",type:"address"},{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"calculateClaimableRewardsByPeriodNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"claimDelay()":{inputs:[],name:"claimDelay",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimRewards()":{inputs:[],name:"claimRewards",outputs:[],stateMutability:"nonpayable",type:"function"},"claimRewardsPartial(uint256)":{inputs:[{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"claimRewardsPartial",outputs:[],stateMutability:"nonpayable",type:"function"},"decayDenominator()":{inputs:[],name:"decayDenominator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decayNumerator()":{inputs:[],name:"decayNumerator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donate(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"donate",outputs:[],stateMutability:"nonpayable",type:"function"},"donateToCommunity(address,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"donateToCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"donationCount()":{inputs:[],name:"donationCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donations(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"donations",outputs:[{internalType:"address",name:"donor",type:"address"},{internalType:"address",name:"target",type:"address"},{internalType:"uint256",name:"rewardPeriod",type:"uint256"},{internalType:"uint256",name:"blockNumber",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"contract IERC20Upgradeable",name:"token",type:"address"},{internalType:"uint256",name:"tokenPrice",type:"uint256"}],stateMutability:"view",type:"function"},"donorRewardPeriod(address,uint256)":{inputs:[{internalType:"address",name:"_donor",type:"address"},{internalType:"uint256",name:"_rewardPeriodIndex",type:"uint256"}],name:"donorRewardPeriod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donors(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"donors",outputs:[{internalType:"uint256",name:"lastClaim",type:"uint256"},{internalType:"uint256",name:"rewardPeriodsCount",type:"uint256"},{internalType:"uint256",name:"lastClaimPeriod",type:"uint256"}],stateMutability:"view",type:"function"},"estimateClaimableReward(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"estimateClaimableReward",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"rewardPeriodCount()":{inputs:[],name:"rewardPeriodCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodDonorAmount(uint256,address)":{inputs:[{internalType:"uint256",name:"_period",type:"uint256"},{internalType:"address",name:"_donor",type:"address"}],name:"rewardPeriodDonorAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodSize()":{inputs:[],name:"rewardPeriodSize",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriods(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"rewardPeriods",outputs:[{internalType:"uint256",name:"rewardPerBlock",type:"uint256"},{internalType:"uint256",name:"rewardAmount",type:"uint256"},{internalType:"uint256",name:"startBlock",type:"uint256"},{internalType:"uint256",name:"endBlock",type:"uint256"},{internalType:"uint256",name:"donationsAmount",type:"uint256"},{internalType:"uint256",name:"againstPeriods",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"contract ITreasury",name:"",type:"address"}],stateMutability:"view",type:"function"},"updateAgainstPeriods(uint256)":{inputs:[{internalType:"uint256",name:"_newAgainstPeriods",type:"uint256"}],name:"updateAgainstPeriods",outputs:[],stateMutability:"nonpayable",type:"function"},"updateClaimDelay(uint256)":{inputs:[{internalType:"uint256",name:"_newClaimDelay",type:"uint256"}],name:"updateClaimDelay",outputs:[],stateMutability:"nonpayable",type:"function"},"updateRewardPeriodParams(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_newRewardPeriodSize",type:"uint256"},{internalType:"uint256",name:"_newDecayNumerator",type:"uint256"},{internalType:"uint256",name:"_newDecayDenominator",type:"uint256"}],name:"updateRewardPeriodParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasury(address)":{inputs:[{internalType:"contract ITreasury",name:"_newTreasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/mocks/donationMiner/interfaces/DonationMinerStorageV3Old.sol:DonationMinerStorageV3Old":{source:"contracts/mocks/donationMiner/interfaces/DonationMinerStorageV3Old.sol",name:"DonationMinerStorageV3Old",title:"Storage for DonationMiner",notice:"For future upgrades, do not change DonationMinerStorageV2. Create a new contract which implements DonationMinerStorageV3 and following the naming convention DonationMinerStorageVX.",methods:{"PACT()":{inputs:[],name:"PACT",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"againstPeriods()":{inputs:[],name:"againstPeriods",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"calculateClaimableRewards(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"calculateClaimableRewards",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"calculateClaimableRewardsByPeriodNumber(address,uint256)":{inputs:[{internalType:"address",name:"_donor",type:"address"},{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"calculateClaimableRewardsByPeriodNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"claimDelay()":{inputs:[],name:"claimDelay",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimRewards()":{inputs:[],name:"claimRewards",outputs:[],stateMutability:"nonpayable",type:"function"},"claimRewardsPartial(uint256)":{inputs:[{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"claimRewardsPartial",outputs:[],stateMutability:"nonpayable",type:"function"},"decayDenominator()":{inputs:[],name:"decayDenominator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decayNumerator()":{inputs:[],name:"decayNumerator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donate(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"donate",outputs:[],stateMutability:"nonpayable",type:"function"},"donateToCommunity(address,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"donateToCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"donationCount()":{inputs:[],name:"donationCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donations(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"donations",outputs:[{internalType:"address",name:"donor",type:"address"},{internalType:"address",name:"target",type:"address"},{internalType:"uint256",name:"rewardPeriod",type:"uint256"},{internalType:"uint256",name:"blockNumber",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"contract IERC20Upgradeable",name:"token",type:"address"},{internalType:"uint256",name:"tokenPrice",type:"uint256"}],stateMutability:"view",type:"function"},"donorRewardPeriod(address,uint256)":{inputs:[{internalType:"address",name:"_donor",type:"address"},{internalType:"uint256",name:"_rewardPeriodIndex",type:"uint256"}],name:"donorRewardPeriod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donors(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"donors",outputs:[{internalType:"uint256",name:"lastClaim",type:"uint256"},{internalType:"uint256",name:"rewardPeriodsCount",type:"uint256"},{internalType:"uint256",name:"lastClaimPeriod",type:"uint256"}],stateMutability:"view",type:"function"},"estimateClaimableReward(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"estimateClaimableReward",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"rewardPeriodCount()":{inputs:[],name:"rewardPeriodCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodDonorAmount(uint256,address)":{inputs:[{internalType:"uint256",name:"_period",type:"uint256"},{internalType:"address",name:"_donor",type:"address"}],name:"rewardPeriodDonorAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodSize()":{inputs:[],name:"rewardPeriodSize",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriods(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"rewardPeriods",outputs:[{internalType:"uint256",name:"rewardPerBlock",type:"uint256"},{internalType:"uint256",name:"rewardAmount",type:"uint256"},{internalType:"uint256",name:"startBlock",type:"uint256"},{internalType:"uint256",name:"endBlock",type:"uint256"},{internalType:"uint256",name:"donationsAmount",type:"uint256"},{internalType:"uint256",name:"againstPeriods",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"contract ITreasury",name:"",type:"address"}],stateMutability:"view",type:"function"},"updateAgainstPeriods(uint256)":{inputs:[{internalType:"uint256",name:"_newAgainstPeriods",type:"uint256"}],name:"updateAgainstPeriods",outputs:[],stateMutability:"nonpayable",type:"function"},"updateClaimDelay(uint256)":{inputs:[{internalType:"uint256",name:"_newClaimDelay",type:"uint256"}],name:"updateClaimDelay",outputs:[],stateMutability:"nonpayable",type:"function"},"updateRewardPeriodParams(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_newRewardPeriodSize",type:"uint256"},{internalType:"uint256",name:"_newDecayNumerator",type:"uint256"},{internalType:"uint256",name:"_newDecayDenominator",type:"uint256"}],name:"updateRewardPeriodParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasury(address)":{inputs:[{internalType:"contract ITreasury",name:"_newTreasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/mocks/donationMiner/interfaces/IDonationMinerOld.sol:IDonationMinerOld":{source:"contracts/mocks/donationMiner/interfaces/IDonationMinerOld.sol",name:"IDonationMinerOld",methods:{"PACT()":{inputs:[],name:"PACT",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"againstPeriods()":{inputs:[],name:"againstPeriods",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"cUSD()":{inputs:[],name:"cUSD",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"calculateClaimableRewards(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"calculateClaimableRewards",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"calculateClaimableRewardsByPeriodNumber(address,uint256)":{inputs:[{internalType:"address",name:"_donor",type:"address"},{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"calculateClaimableRewardsByPeriodNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"claimDelay()":{inputs:[],name:"claimDelay",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimRewards()":{inputs:[],name:"claimRewards",outputs:[],stateMutability:"nonpayable",type:"function"},"claimRewardsPartial(uint256)":{inputs:[{internalType:"uint256",name:"_lastPeriodNumber",type:"uint256"}],name:"claimRewardsPartial",outputs:[],stateMutability:"nonpayable",type:"function"},"decayDenominator()":{inputs:[],name:"decayDenominator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decayNumerator()":{inputs:[],name:"decayNumerator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donate(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"donate",outputs:[],stateMutability:"nonpayable",type:"function"},"donateToCommunity(address,uint256)":{inputs:[{internalType:"contract ICommunity",name:"_community",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"donateToCommunity",outputs:[],stateMutability:"nonpayable",type:"function"},"donationCount()":{inputs:[],name:"donationCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donations(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"donations",outputs:[{internalType:"address",name:"donor",type:"address"},{internalType:"address",name:"target",type:"address"},{internalType:"uint256",name:"rewardPeriod",type:"uint256"},{internalType:"uint256",name:"blockNumber",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"contract IERC20Upgradeable",name:"token",type:"address"},{internalType:"uint256",name:"tokenPrice",type:"uint256"}],stateMutability:"view",type:"function"},"donorRewardPeriod(address,uint256)":{inputs:[{internalType:"address",name:"_donor",type:"address"},{internalType:"uint256",name:"_rewardPeriodIndex",type:"uint256"}],name:"donorRewardPeriod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donors(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"donors",outputs:[{internalType:"uint256",name:"rewardPeriodsCount",type:"uint256"},{internalType:"uint256",name:"lastClaim",type:"uint256"},{internalType:"uint256",name:"lastClaimPeriod",type:"uint256"}],stateMutability:"view",type:"function"},"estimateClaimableReward(address)":{inputs:[{internalType:"address",name:"_donor",type:"address"}],name:"estimateClaimableReward",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"rewardPeriodCount()":{inputs:[],name:"rewardPeriodCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodDonorAmount(uint256,address)":{inputs:[{internalType:"uint256",name:"_period",type:"uint256"},{internalType:"address",name:"_donor",type:"address"}],name:"rewardPeriodDonorAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriodSize()":{inputs:[],name:"rewardPeriodSize",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rewardPeriods(uint256)":{inputs:[{internalType:"uint256",name:"_period",type:"uint256"}],name:"rewardPeriods",outputs:[{internalType:"uint256",name:"rewardPerBlock",type:"uint256"},{internalType:"uint256",name:"rewardAmount",type:"uint256"},{internalType:"uint256",name:"startBlock",type:"uint256"},{internalType:"uint256",name:"endBlock",type:"uint256"},{internalType:"uint256",name:"donationsAmount",type:"uint256"},{internalType:"uint256",name:"againstPeriods",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"contract ITreasury",name:"",type:"address"}],stateMutability:"view",type:"function"},"updateAgainstPeriods(uint256)":{inputs:[{internalType:"uint256",name:"_newAgainstPeriods",type:"uint256"}],name:"updateAgainstPeriods",outputs:[],stateMutability:"nonpayable",type:"function"},"updateClaimDelay(uint256)":{inputs:[{internalType:"uint256",name:"_newClaimDelay",type:"uint256"}],name:"updateClaimDelay",outputs:[],stateMutability:"nonpayable",type:"function"},"updateRewardPeriodParams(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_newRewardPeriodSize",type:"uint256"},{internalType:"uint256",name:"_newDecayNumerator",type:"uint256"},{internalType:"uint256",name:"_newDecayDenominator",type:"uint256"}],name:"updateRewardPeriodParams",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasury(address)":{inputs:[{internalType:"contract ITreasury",name:"_newTreasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/mocks/governor/PACTDelegateOld.sol:PACTDelegateOld":{source:"contracts/mocks/governor/PACTDelegateOld.sol",name:"PACTDelegateOld",events:{"NewAdmin(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"NewAdmin",type:"event",notice:"Emitted when pendingAdmin is accepted, which means admin is updated"},"NewImplementation(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldImplementation",type:"address"},{indexed:!1,internalType:"address",name:"newImplementation",type:"address"}],name:"NewImplementation",type:"event",notice:"Emitted when implementation is changed"},"NewPendingAdmin(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldPendingAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newPendingAdmin",type:"address"}],name:"NewPendingAdmin",type:"event",notice:"Emitted when pendingAdmin is changed"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"ProposalCanceled(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"id",type:"uint256"}],name:"ProposalCanceled",type:"event",notice:"An event emitted when a proposal has been canceled"},"ProposalCreated(uint256,address,address[],uint256[],string[],bytes[],uint256,uint256,string)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"id",type:"uint256"},{indexed:!1,internalType:"address",name:"proposer",type:"address"},{indexed:!1,internalType:"address[]",name:"targets",type:"address[]"},{indexed:!1,internalType:"uint256[]",name:"values",type:"uint256[]"},{indexed:!1,internalType:"string[]",name:"signatures",type:"string[]"},{indexed:!1,internalType:"bytes[]",name:"calldatas",type:"bytes[]"},{indexed:!1,internalType:"uint256",name:"startBlock",type:"uint256"},{indexed:!1,internalType:"uint256",name:"endBlock",type:"uint256"},{indexed:!1,internalType:"string",name:"description",type:"string"}],name:"ProposalCreated",type:"event",notice:"An event emitted when a new proposal is created"},"ProposalExecuted(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"id",type:"uint256"}],name:"ProposalExecuted",type:"event",notice:"An event emitted when a proposal has been executed in the Timelock"},"ProposalQueued(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"id",type:"uint256"},{indexed:!1,internalType:"uint256",name:"eta",type:"uint256"}],name:"ProposalQueued",type:"event",notice:"An event emitted when a proposal has been queued in the Timelock"},"ProposalThresholdSet(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldProposalThreshold",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newProposalThreshold",type:"uint256"}],name:"ProposalThresholdSet",type:"event",notice:"Emitted when proposal threshold is set"},"QuorumVotesSet(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldQuorumVotes",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newQuorumVotes",type:"uint256"}],name:"QuorumVotesSet",type:"event",notice:"An event emitted when the quorum votes is set"},"ReleaseTokenSet(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oldReleaseToken",type:"address"},{indexed:!1,internalType:"address",name:"newReleaseToken",type:"address"}],name:"ReleaseTokenSet",type:"event",notice:"Emitted when release token is set"},"TransferERC20(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"TransferERC20",type:"event",notice:"Triggered when an amount of an ERC20 has been transferred from this contract to an address"},"VoteCast(address,uint256,uint8,uint256,string)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"voter",type:"address"},{indexed:!1,internalType:"uint256",name:"proposalId",type:"uint256"},{indexed:!1,internalType:"uint8",name:"support",type:"uint8"},{indexed:!1,internalType:"uint256",name:"votes",type:"uint256"},{indexed:!1,internalType:"string",name:"reason",type:"string"}],name:"VoteCast",type:"event",notice:"An event emitted when a vote has been cast on a proposal"},"VotingDelaySet(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldVotingDelay",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newVotingDelay",type:"uint256"}],name:"VotingDelaySet",type:"event",notice:"An event emitted when the voting delay is set"},"VotingPeriodSet(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldVotingPeriod",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newVotingPeriod",type:"uint256"}],name:"VotingPeriodSet",type:"event",notice:"An event emitted when the voting period is set"}},methods:{"BALLOT_TYPEHASH()":{inputs:[],name:"BALLOT_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"The EIP-712 typehash for the ballot struct used by the contract"},"DOMAIN_TYPEHASH()":{inputs:[],name:"DOMAIN_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"The EIP-712 typehash for the contract's domain"},"MAX_PROPOSAL_THRESHOLD()":{inputs:[],name:"MAX_PROPOSAL_THRESHOLD",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The maximum setable proposal threshold"},"MAX_VOTING_DELAY()":{inputs:[],name:"MAX_VOTING_DELAY",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The max setable voting delay"},"MAX_VOTING_PERIOD()":{inputs:[],name:"MAX_VOTING_PERIOD",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The max setable voting period"},"MIN_PROPOSAL_THRESHOLD()":{inputs:[],name:"MIN_PROPOSAL_THRESHOLD",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The minimum setable proposal threshold"},"MIN_VOTING_DELAY()":{inputs:[],name:"MIN_VOTING_DELAY",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The min setable voting delay"},"MIN_VOTING_PERIOD()":{inputs:[],name:"MIN_VOTING_PERIOD",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The minimum setable voting period"},"NAME()":{inputs:[],name:"NAME",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",notice:"The name of this contract"},"PROPOSAL_MAX_OPERATIONS()":{inputs:[],name:"PROPOSAL_MAX_OPERATIONS",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The maximum number of actions that can be included in a proposal"},"_setProposalThreshold(uint256)":{inputs:[{internalType:"uint256",name:"_newProposalThreshold",type:"uint256"}],name:"_setProposalThreshold",outputs:[],stateMutability:"nonpayable",type:"function",details:"_newProposalThreshold must be greater than the hardcoded min",params:{_newProposalThreshold:"new proposal threshold"},notice:"Owner function for setting the proposal threshold"},"_setQuorumVotes(uint256)":{inputs:[{internalType:"uint256",name:"_newQuorumVotes",type:"uint256"}],name:"_setQuorumVotes",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newQuorumVotes:"new quorum votes"},notice:"Owner function for setting the quorum votes"},"_setVotingDelay(uint256)":{inputs:[{internalType:"uint256",name:"_newVotingDelay",type:"uint256"}],name:"_setVotingDelay",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newVotingDelay:"new voting delay, in blocks"},notice:"Owner function for setting the voting delay"},"_setVotingPeriod(uint256)":{inputs:[{internalType:"uint256",name:"_newVotingPeriod",type:"uint256"}],name:"_setVotingPeriod",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newVotingPeriod:"new voting period, in blocks"},notice:"Owner function for setting the voting period"},"cancel(uint256)":{inputs:[{internalType:"uint256",name:"_proposalId",type:"uint256"}],name:"cancel",outputs:[],stateMutability:"nonpayable",type:"function",params:{_proposalId:"The id of the proposal to cancel"},notice:"Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold"},"castVote(uint256,uint8)":{inputs:[{internalType:"uint256",name:"_proposalId",type:"uint256"},{internalType:"uint8",name:"_support",type:"uint8"}],name:"castVote",outputs:[],stateMutability:"nonpayable",type:"function",params:{_proposalId:"The id of the proposal to vote on",_support:"The support value for the vote. 0=against, 1=for, 2=abstain"},notice:"Cast a vote for a proposal"},"castVoteBySig(uint256,uint8,uint8,bytes32,bytes32)":{inputs:[{internalType:"uint256",name:"_proposalId",type:"uint256"},{internalType:"uint8",name:"_support",type:"uint8"},{internalType:"uint8",name:"_v",type:"uint8"},{internalType:"bytes32",name:"_r",type:"bytes32"},{internalType:"bytes32",name:"_s",type:"bytes32"}],name:"castVoteBySig",outputs:[],stateMutability:"nonpayable",type:"function",details:"External function that accepts EIP-712 signatures for voting on proposals.",notice:"Cast a vote for a proposal by signature"},"castVoteWithReason(uint256,uint8,string)":{inputs:[{internalType:"uint256",name:"_proposalId",type:"uint256"},{internalType:"uint8",name:"_support",type:"uint8"},{internalType:"string",name:"_reason",type:"string"}],name:"castVoteWithReason",outputs:[],stateMutability:"nonpayable",type:"function",params:{_proposalId:"The id of the proposal to vote on",_reason:"The reason given for the vote by the voter",_support:"The support value for the vote. 0=against, 1=for, 2=abstain"},notice:"Cast a vote for a proposal with a reason"},"execute(uint256)":{inputs:[{internalType:"uint256",name:"_proposalId",type:"uint256"}],name:"execute",outputs:[],stateMutability:"payable",type:"function",params:{_proposalId:"The id of the proposal to execute"},notice:"Executes a queued proposal if eta has passed"},"getActions(uint256)":{inputs:[{internalType:"uint256",name:"_proposalId",type:"uint256"}],name:"getActions",outputs:[{internalType:"address[]",name:"targets",type:"address[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"},{internalType:"string[]",name:"signatures",type:"string[]"},{internalType:"bytes[]",name:"calldatas",type:"bytes[]"}],stateMutability:"view",type:"function",params:{_proposalId:"Proposal to query."},returns:{calldatas:"Calldatas for proposal calls.",signatures:"Function signatures for proposal calls.",targets:"Target addresses for proposal calls.",values:"Eth values for proposal calls."},notice:"Gets actions of a proposal."},"getReceipt(uint256,address)":{inputs:[{internalType:"uint256",name:"_proposalId",type:"uint256"},{internalType:"address",name:"_voter",type:"address"}],name:"getReceipt",outputs:[{components:[{internalType:"bool",name:"hasVoted",type:"bool"},{internalType:"uint8",name:"support",type:"uint8"},{internalType:"uint96",name:"votes",type:"uint96"}],internalType:"struct PACTDelegateStorageV1.Receipt",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{_proposalId:"the id of proposal",_voter:"The address of the voter"},returns:{_0:"The voting receipt"},notice:"Gets the receipt for a voter on a given proposal"},"initialize(address,address,address,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"_timelock",type:"address"},{internalType:"address",name:"_token",type:"address"},{internalType:"address",name:"_releaseToken",type:"address"},{internalType:"uint256",name:"_votingPeriod",type:"uint256"},{internalType:"uint256",name:"_votingDelay",type:"uint256"},{internalType:"uint256",name:"_proposalThreshold",type:"uint256"},{internalType:"uint256",name:"_quorumVotes",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_proposalThreshold:"The initial proposal threshold",_quorumVotes:"The initial quorum votes",_releaseToken:'The address of the "Release" voting token. If none, specify the zero address.',_timelock:"The address of the Timelock",_token:"The address of the voting token",_votingDelay:"The initial voting delay",_votingPeriod:"The initial voting period"},notice:"Used to initialize the contract during delegator contructor"},"latestProposalIds(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"latestProposalIds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The latest proposal for each proposer"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"proposalCalldatas(uint256,uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],name:"proposalCalldatas",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"view",type:"function",notice:"The official each proposal's calldatas: An ordered list of calldata to be passed to each call"},"proposalCount()":{inputs:[],name:"proposalCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The total number of proposals"},"proposalReceipts(uint256,address)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"address",name:"",type:"address"}],name:"proposalReceipts",outputs:[{internalType:"bool",name:"hasVoted",type:"bool"},{internalType:"uint8",name:"support",type:"uint8"},{internalType:"uint96",name:"votes",type:"uint96"}],stateMutability:"view",type:"function",notice:"The official each proposal's receipts: Receipts of ballots for the entire set of voters"},"proposalSignatures(uint256,uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],name:"proposalSignatures",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",notice:"The official each proposal's signatures: An ordered list of function signatures to be called"},"proposalTargets(uint256,uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],name:"proposalTargets",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The official each proposal's targets: An ordered list of target addresses for calls to be made"},"proposalThreshold()":{inputs:[],name:"proposalThreshold",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The number of votes required in order for a voter to become a proposer"},"proposalValues(uint256,uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],name:"proposalValues",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The official each proposal's values: An ordered list of values (i.e. msg.value) to be passed to the calls to be made"},"proposals(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"proposals",outputs:[{internalType:"uint256",name:"id",type:"uint256"},{internalType:"address",name:"proposer",type:"address"},{internalType:"uint256",name:"eta",type:"uint256"},{internalType:"uint256",name:"startBlock",type:"uint256"},{internalType:"uint256",name:"endBlock",type:"uint256"},{internalType:"uint256",name:"forVotes",type:"uint256"},{internalType:"uint256",name:"againstVotes",type:"uint256"},{internalType:"uint256",name:"abstainVotes",type:"uint256"},{internalType:"bool",name:"canceled",type:"bool"},{internalType:"bool",name:"executed",type:"bool"}],stateMutability:"view",type:"function",notice:"The official record of all proposals ever proposed"},"propose(address[],uint256[],string[],bytes[],string)":{inputs:[{internalType:"address[]",name:"_targets",type:"address[]"},{internalType:"uint256[]",name:"_values",type:"uint256[]"},{internalType:"string[]",name:"_signatures",type:"string[]"},{internalType:"bytes[]",name:"_calldatas",type:"bytes[]"},{internalType:"string",name:"_description",type:"string"}],name:"propose",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{_calldatas:"Calldatas for proposal calls.",_description:"String description of the proposal.",_signatures:"Function signatures for proposal calls.",_targets:"Target addresses for proposal calls.",_values:"Eth values for proposal calls."},returns:{_0:"Proposal id of new proposal."},notice:"Function used to propose a new proposal. Sender must have delegates above the proposal threshold."},"queue(uint256)":{inputs:[{internalType:"uint256",name:"_proposalId",type:"uint256"}],name:"queue",outputs:[],stateMutability:"nonpayable",type:"function",params:{_proposalId:"The id of the proposal to queue"},notice:"Queues a proposal of state succeeded"},"quorumVotes()":{inputs:[],name:"quorumVotes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed"},"releaseToken()":{inputs:[],name:"releaseToken",outputs:[{internalType:"contract IHasVotes",name:"",type:"address"}],stateMutability:"view",type:"function",notice:'The address of the "Release" governance token'},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"state(uint256)":{inputs:[{internalType:"uint256",name:"_proposalId",type:"uint256"}],name:"state",outputs:[{internalType:"enum PACTDelegateStorageV1.ProposalState",name:"",type:"uint8"}],stateMutability:"view",type:"function",params:{_proposalId:"The id of the proposal"},returns:{_0:"Proposal state"},notice:"Gets the state of a proposal"},"timelock()":{inputs:[],name:"timelock",outputs:[{internalType:"contract TimelockInterface",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the Governance Timelock"},"token()":{inputs:[],name:"token",outputs:[{internalType:"contract IHasVotes",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the governance token"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"amount of the transaction",_to:"address of the receiver",_token:"address of the ERC20 token"},notice:"Transfers an amount of an ERC20 from this contract to an address"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"votingDelay()":{inputs:[],name:"votingDelay",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The delay before voting on a proposal may take place, once proposed, in blocks"},"votingPeriod()":{inputs:[],name:"votingPeriod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"The duration of voting on a proposal, in blocks"}}},"contracts/mocks/token/TokenMock.sol:TokenMock":{source:"contracts/mocks/token/TokenMock.sol",name:"TokenMock",constructor:{inputs:[{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"symbol",type:"string"}],stateMutability:"nonpayable",type:"constructor"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"MINTER_ROLE()":{inputs:[],name:"MINTER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"PAUSER_ROLE()":{inputs:[],name:"PAUSER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"burn(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"burn",outputs:[],stateMutability:"nonpayable",type:"function",details:"Destroys `amount` tokens from the caller. See {ERC20-_burn}."},"burnFrom(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burnFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Destroys `amount` tokens from `account`, deducting from the caller's allowance. See {ERC20-_burn} and {ERC20-allowance}. Requirements: - the caller must have allowance for ``accounts``'s tokens of at least `amount`."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless this function is overridden; NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"mint(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function",details:"Creates `amount` new tokens for `to`. See {ERC20-_mint}. Requirements: - the caller must have the `MINTER_ROLE`."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Pauses all token transfers. See {ERC20Pausable} and {Pausable-_pause}. Requirements: - the caller must have the `PAUSER_ROLE`."},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if the contract is paused, and false otherwise."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Unpauses all token transfers. See {ERC20Pausable} and {Pausable-_unpause}. Requirements: - the caller must have the `PAUSER_ROLE`."}}},"contracts/mocks/treasury/TreasuryImplementationOld.sol:TreasuryImplementationOld":{source:"contracts/mocks/treasury/TreasuryImplementationOld.sol",name:"TreasuryImplementationOld",events:{"CommunityAdminUpdated(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldCommunityAdmin",type:"address"},{indexed:!0,internalType:"address",name:"newCommunityAdmin",type:"address"}],name:"CommunityAdminUpdated",type:"event",params:{newCommunityAdmin:"New communityAdmin address",oldCommunityAdmin:"Old communityAdmin address"},notice:"Triggered when CommunityAdmin has been updated"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"TransferERC20(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"TransferERC20",type:"event",params:{amount:"Amount of the transaction",to:"Address of the receiver",token:"ERC20 token address"},notice:"Triggered when an amount of an ERC20 has been transferred from this contract to an address"}},methods:{"communityAdmin()":{inputs:[],name:"communityAdmin",outputs:[{internalType:"contract ICommunityAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function",notice:"Returns the current implementation version"},"initialize(address)":{inputs:[{internalType:"contract ICommunityAdmin",name:"_communityAdmin",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_communityAdmin:"Address of the CommunityAdmin contract"},notice:"Used to initialize a new Treasury contract"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"amount of the transaction",_to:"address of the receiver",_token:"address of the ERC20 token"},notice:"Transfers an amount of an ERC20 from this contract to an address"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"updateCommunityAdmin(address)":{inputs:[{internalType:"contract ICommunityAdmin",name:"_newCommunityAdmin",type:"address"}],name:"updateCommunityAdmin",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newCommunityAdmin:"address of the new CommunityAdmin contract"},notice:"Updates the CommunityAdmin contract address"}}},"contracts/mocks/treasury/interfaces/ITreasury.sol:ITreasury":{source:"contracts/mocks/treasury/interfaces/ITreasury.sol",name:"ITreasury",methods:{"communityAdmin()":{inputs:[],name:"communityAdmin",outputs:[{internalType:"contract ICommunityAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityAdmin(address)":{inputs:[{internalType:"contract ICommunityAdmin",name:"_communityAdmin",type:"address"}],name:"updateCommunityAdmin",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/mocks/treasury/interfaces/TreasuryStorageV1.sol:TreasuryStorageV1":{source:"contracts/mocks/treasury/interfaces/TreasuryStorageV1.sol",name:"TreasuryStorageV1",title:"Storage for Treasury",notice:"For future upgrades, do not change TreasuryStorageV1. Create a new contract which implements TreasuryStorageV1 and following the naming convention TreasuryStorageVX.",methods:{"communityAdmin()":{inputs:[],name:"communityAdmin",outputs:[{internalType:"contract ICommunityAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCommunityAdmin(address)":{inputs:[{internalType:"contract ICommunityAdmin",name:"_communityAdmin",type:"address"}],name:"updateCommunityAdmin",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/mocks/uniswapV3/core/NoDelegateCall.sol:NoDelegateCall":{source:"contracts/mocks/uniswapV3/core/NoDelegateCall.sol",name:"NoDelegateCall",title:"Prevents delegatecall to a contract",notice:"Base contract that provides a modifier for preventing delegatecall to methods in a child contract"},"contracts/mocks/uniswapV3/core/UniswapV3Factory.sol:UniswapV3Factory":{source:"contracts/mocks/uniswapV3/core/UniswapV3Factory.sol",name:"UniswapV3Factory",title:"Canonical Uniswap V3 factory",notice:"Deploys Uniswap V3 pools and manages ownership and control over pool protocol fees",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"FeeAmountEnabled(uint24,int24)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint24",name:"fee",type:"uint24"},{indexed:!0,internalType:"int24",name:"tickSpacing",type:"int24"}],name:"FeeAmountEnabled",type:"event",notice:"Emitted when a new fee amount is enabled for pool creation via the factory"},"OwnerChanged(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnerChanged",type:"event",notice:"Emitted when the owner of the factory is changed"},"PoolCreated(address,address,uint24,int24,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token0",type:"address"},{indexed:!0,internalType:"address",name:"token1",type:"address"},{indexed:!0,internalType:"uint24",name:"fee",type:"uint24"},{indexed:!1,internalType:"int24",name:"tickSpacing",type:"int24"},{indexed:!1,internalType:"address",name:"pool",type:"address"}],name:"PoolCreated",type:"event",notice:"Emitted when a pool is created"}},stateVariables:{"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"stateVariable",details:"Can be changed by the current owner via setOwner",return:"The address of the factory owner",notice:"Returns the current owner of the factory"}},methods:{"createPool(address,address,uint24)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"}],name:"createPool",outputs:[{internalType:"address",name:"pool",type:"address"}],stateMutability:"nonpayable",type:"function",details:"tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments are invalid.",params:{fee:"The desired fee for the pool",tokenA:"One of the two tokens in the desired pool",tokenB:"The other of the two tokens in the desired pool"},returns:{pool:"The address of the newly created pool"},notice:"Creates a pool for the given two tokens and fee"},"enableFeeAmount(uint24,int24)":{inputs:[{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"int24",name:"tickSpacing",type:"int24"}],name:"enableFeeAmount",outputs:[],stateMutability:"nonpayable",type:"function",details:"Fee amounts may never be removed once enabled",params:{fee:"The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)",tickSpacing:"The spacing between ticks to be enforced for all pools created with the given fee amount"},notice:"Enables a fee amount with the given tickSpacing"},"feeAmountTickSpacing(uint24)":{inputs:[{internalType:"uint24",name:"",type:"uint24"}],name:"feeAmountTickSpacing",outputs:[{internalType:"int24",name:"",type:"int24"}],stateMutability:"view",type:"function",notice:"Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled"},"getPool(address,address,uint24)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint24",name:"",type:"uint24"}],name:"getPool",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist"},"parameters()":{inputs:[],name:"parameters",outputs:[{internalType:"address",name:"factory",type:"address"},{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"int24",name:"tickSpacing",type:"int24"}],stateMutability:"view",type:"function",notice:"Get the parameters to be used in constructing the pool, set transiently during pool creation."},"setOwner(address)":{inputs:[{internalType:"address",name:"_owner",type:"address"}],name:"setOwner",outputs:[],stateMutability:"nonpayable",type:"function",details:"Must be called by the current owner",params:{_owner:"The new owner of the factory"},notice:"Updates the owner of the factory"}}},"contracts/mocks/uniswapV3/core/UniswapV3Pool.sol:UniswapV3Pool":{source:"contracts/mocks/uniswapV3/core/UniswapV3Pool.sol",name:"UniswapV3Pool",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"Burn(address,int24,int24,uint128,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"int24",name:"tickLower",type:"int24"},{indexed:!0,internalType:"int24",name:"tickUpper",type:"int24"},{indexed:!1,internalType:"uint128",name:"amount",type:"uint128"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"Burn",type:"event",notice:"Emitted when a position's liquidity is removed"},"Collect(address,address,int24,int24,uint128,uint128)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"address",name:"recipient",type:"address"},{indexed:!0,internalType:"int24",name:"tickLower",type:"int24"},{indexed:!0,internalType:"int24",name:"tickUpper",type:"int24"},{indexed:!1,internalType:"uint128",name:"amount0",type:"uint128"},{indexed:!1,internalType:"uint128",name:"amount1",type:"uint128"}],name:"Collect",type:"event",notice:"Emitted when fees are collected by the owner of a position"},"CollectProtocol(address,address,uint128,uint128)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!0,internalType:"address",name:"recipient",type:"address"},{indexed:!1,internalType:"uint128",name:"amount0",type:"uint128"},{indexed:!1,internalType:"uint128",name:"amount1",type:"uint128"}],name:"CollectProtocol",type:"event",notice:"Emitted when the collected protocol fees are withdrawn by the factory owner"},"Flash(address,address,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!0,internalType:"address",name:"recipient",type:"address"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"},{indexed:!1,internalType:"uint256",name:"paid0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"paid1",type:"uint256"}],name:"Flash",type:"event",notice:"Emitted by the pool for any flashes of token0/token1"},"IncreaseObservationCardinalityNext(uint16,uint16)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint16",name:"observationCardinalityNextOld",type:"uint16"},{indexed:!1,internalType:"uint16",name:"observationCardinalityNextNew",type:"uint16"}],name:"IncreaseObservationCardinalityNext",type:"event",notice:"Emitted by the pool for increases to the number of observations that can be stored"},"Initialize(uint160,int24)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint160",name:"sqrtPriceX96",type:"uint160"},{indexed:!1,internalType:"int24",name:"tick",type:"int24"}],name:"Initialize",type:"event",notice:"Emitted exactly once by a pool when #initialize is first called on the pool"},"Mint(address,address,int24,int24,uint128,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"sender",type:"address"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"int24",name:"tickLower",type:"int24"},{indexed:!0,internalType:"int24",name:"tickUpper",type:"int24"},{indexed:!1,internalType:"uint128",name:"amount",type:"uint128"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"Mint",type:"event",notice:"Emitted when liquidity is minted for a given position"},"SetFeeProtocol(uint8,uint8,uint8,uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"feeProtocol0Old",type:"uint8"},{indexed:!1,internalType:"uint8",name:"feeProtocol1Old",type:"uint8"},{indexed:!1,internalType:"uint8",name:"feeProtocol0New",type:"uint8"},{indexed:!1,internalType:"uint8",name:"feeProtocol1New",type:"uint8"}],name:"SetFeeProtocol",type:"event",notice:"Emitted when the protocol fee is changed by the pool"},"Swap(address,address,int256,int256,uint160,uint128,int24)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!0,internalType:"address",name:"recipient",type:"address"},{indexed:!1,internalType:"int256",name:"amount0",type:"int256"},{indexed:!1,internalType:"int256",name:"amount1",type:"int256"},{indexed:!1,internalType:"uint160",name:"sqrtPriceX96",type:"uint160"},{indexed:!1,internalType:"uint128",name:"liquidity",type:"uint128"},{indexed:!1,internalType:"int24",name:"tick",type:"int24"}],name:"Swap",type:"event",notice:"Emitted by the pool for any swaps between token0 and token1"}},stateVariables:{"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"stateVariable",return:"The contract address",notice:"The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface"},"fee()":{inputs:[],name:"fee",outputs:[{internalType:"uint24",name:"",type:"uint24"}],stateMutability:"view",type:"stateVariable",return:"The fee",notice:"The pool's fee in hundredths of a bip, i.e. 1e-6"},"feeGrowthGlobal0X128()":{inputs:[],name:"feeGrowthGlobal0X128",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"stateVariable",details:"This value can overflow the uint256",notice:"The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool"},"feeGrowthGlobal1X128()":{inputs:[],name:"feeGrowthGlobal1X128",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"stateVariable",details:"This value can overflow the uint256",notice:"The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool"},"liquidity()":{inputs:[],name:"liquidity",outputs:[{internalType:"uint128",name:"",type:"uint128"}],stateMutability:"view",type:"stateVariable",details:"This value has no relationship to the total liquidity across all ticks",notice:"The currently in range liquidity available to the pool"},"maxLiquidityPerTick()":{inputs:[],name:"maxLiquidityPerTick",outputs:[{internalType:"uint128",name:"",type:"uint128"}],stateMutability:"view",type:"stateVariable",details:"This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool",return:"The max amount of liquidity per tick",notice:"The maximum amount of position liquidity that can use any tick in the range"},"protocolFees()":{inputs:[],name:"protocolFees",outputs:[{internalType:"uint128",name:"token0",type:"uint128"},{internalType:"uint128",name:"token1",type:"uint128"}],stateMutability:"view",type:"stateVariable",details:"Protocol fees will never exceed uint128 max in either token",notice:"The amounts of token0 and token1 that are owed to the protocol"},"slot0()":{inputs:[],name:"slot0",outputs:[{internalType:"uint160",name:"sqrtPriceX96",type:"uint160"},{internalType:"int24",name:"tick",type:"int24"},{internalType:"uint16",name:"observationIndex",type:"uint16"},{internalType:"uint16",name:"observationCardinality",type:"uint16"},{internalType:"uint16",name:"observationCardinalityNext",type:"uint16"},{internalType:"uint8",name:"feeProtocol",type:"uint8"},{internalType:"bool",name:"unlocked",type:"bool"}],stateMutability:"view",type:"stateVariable",return:"sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value tick The current tick of the pool, i.e. according to the last tick transition that was run. This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick boundary. observationIndex The index of the last oracle observation that was written, observationCardinality The current maximum number of observations stored in the pool, observationCardinalityNext The next maximum number of observations, to be updated when the observation. feeProtocol The protocol fee for both tokens of the pool. Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0 is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee. unlocked Whether the pool is currently locked to reentrancy",notice:"The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas when accessed externally."},"tickSpacing()":{inputs:[],name:"tickSpacing",outputs:[{internalType:"int24",name:"",type:"int24"}],stateMutability:"view",type:"stateVariable",details:"Ticks can only be used at multiples of this value, minimum of 1 and always positive e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ... This value is an int24 to avoid casting even though it is always positive.",return:"The tick spacing",notice:"The pool tick spacing"},"token0()":{inputs:[],name:"token0",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"stateVariable",return:"The token contract address",notice:"The first of the two tokens of the pool, sorted by address"},"token1()":{inputs:[],name:"token1",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"stateVariable",return:"The token contract address",notice:"The second of the two tokens of the pool, sorted by address"}},methods:{"burn(int24,int24,uint128)":{inputs:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint128",name:"amount",type:"uint128"}],name:"burn",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"noDelegateCall is applied indirectly via _modifyPosition",params:{amount:"How much liquidity to burn",tickLower:"The lower tick of the position for which to burn liquidity",tickUpper:"The upper tick of the position for which to burn liquidity"},returns:{amount0:"The amount of token0 sent to the recipient",amount1:"The amount of token1 sent to the recipient"},notice:"Burn liquidity from the sender and account tokens owed for the liquidity to the position"},"collect(address,int24,int24,uint128,uint128)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint128",name:"amount0Requested",type:"uint128"},{internalType:"uint128",name:"amount1Requested",type:"uint128"}],name:"collect",outputs:[{internalType:"uint128",name:"amount0",type:"uint128"},{internalType:"uint128",name:"amount1",type:"uint128"}],stateMutability:"nonpayable",type:"function",details:"Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity. Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.",params:{amount0Requested:"How much token0 should be withdrawn from the fees owed",amount1Requested:"How much token1 should be withdrawn from the fees owed",recipient:"The address which should receive the fees collected",tickLower:"The lower tick of the position for which to collect fees",tickUpper:"The upper tick of the position for which to collect fees"},returns:{amount0:"The amount of fees collected in token0",amount1:"The amount of fees collected in token1"},notice:"Collects tokens owed to a position"},"collectProtocol(address,uint128,uint128)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint128",name:"amount0Requested",type:"uint128"},{internalType:"uint128",name:"amount1Requested",type:"uint128"}],name:"collectProtocol",outputs:[{internalType:"uint128",name:"amount0",type:"uint128"},{internalType:"uint128",name:"amount1",type:"uint128"}],stateMutability:"nonpayable",type:"function",params:{amount0Requested:"The maximum amount of token0 to send, can be 0 to collect fees in only token1",amount1Requested:"The maximum amount of token1 to send, can be 0 to collect fees in only token0",recipient:"The address to which collected protocol fees should be sent"},returns:{amount0:"The protocol fee collected in token0",amount1:"The protocol fee collected in token1"},notice:"Collect the protocol fee accrued to the pool"},"flash(address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"flash",outputs:[],stateMutability:"nonpayable",type:"function",details:"The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallbackCan be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling with 0 amount{0,1} and sending the donation amount(s) from the callback",params:{amount0:"The amount of token0 to send",amount1:"The amount of token1 to send",data:"Any data to be passed through to the callback",recipient:"The address which will receive the token0 and token1 amounts"},notice:"Receive token0 and/or token1 and pay it back, plus a fee, in the callback"},"increaseObservationCardinalityNext(uint16)":{inputs:[{internalType:"uint16",name:"observationCardinalityNext",type:"uint16"}],name:"increaseObservationCardinalityNext",outputs:[],stateMutability:"nonpayable",type:"function",details:"This method is no-op if the pool already has an observationCardinalityNext greater than or equal to the input observationCardinalityNext.",params:{observationCardinalityNext:"The desired minimum number of observations for the pool to store"},notice:"Increase the maximum number of price and liquidity observations that this pool will store"},"initialize(uint160)":{inputs:[{internalType:"uint160",name:"sqrtPriceX96",type:"uint160"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"not locked because it initializes unlocked",params:{sqrtPriceX96:"the initial sqrt price of the pool as a Q64.96"},notice:"Sets the initial price for the pool"},"mint(address,int24,int24,uint128,bytes)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint128",name:"amount",type:"uint128"},{internalType:"bytes",name:"data",type:"bytes"}],name:"mint",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"noDelegateCall is applied indirectly via _modifyPosition",params:{amount:"The amount of liquidity to mint",data:"Any data that should be passed through to the callback",recipient:"The address for which the liquidity will be created",tickLower:"The lower tick of the position in which to add liquidity",tickUpper:"The upper tick of the position in which to add liquidity"},returns:{amount0:"The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback",amount1:"The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback"},notice:"Adds liquidity for the given recipient/tickLower/tickUpper position"},"observations(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"observations",outputs:[{internalType:"uint32",name:"blockTimestamp",type:"uint32"},{internalType:"int56",name:"tickCumulative",type:"int56"},{internalType:"uint160",name:"secondsPerLiquidityCumulativeX128",type:"uint160"},{internalType:"bool",name:"initialized",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns data about a specific observation index"},"observe(uint32[])":{inputs:[{internalType:"uint32[]",name:"secondsAgos",type:"uint32[]"}],name:"observe",outputs:[{internalType:"int56[]",name:"tickCumulatives",type:"int56[]"},{internalType:"uint160[]",name:"secondsPerLiquidityCumulativeX128s",type:"uint160[]"}],stateMutability:"view",type:"function",details:"To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick, you must call it with secondsAgos = [3600, 0].The time weighted average tick represents the geometric time weighted average price of the pool, in log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.",params:{secondsAgos:"From how long ago each cumulative tick and liquidity value should be returned"},returns:{secondsPerLiquidityCumulativeX128s:"Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block timestamp",tickCumulatives:"Cumulative tick values as of each `secondsAgos` from the current block timestamp"},notice:"Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp"},"positions(bytes32)":{inputs:[{internalType:"bytes32",name:"",type:"bytes32"}],name:"positions",outputs:[{internalType:"uint128",name:"liquidity",type:"uint128"},{internalType:"uint256",name:"feeGrowthInside0LastX128",type:"uint256"},{internalType:"uint256",name:"feeGrowthInside1LastX128",type:"uint256"},{internalType:"uint128",name:"tokensOwed0",type:"uint128"},{internalType:"uint128",name:"tokensOwed1",type:"uint128"}],stateMutability:"view",type:"function",notice:"Returns the information about a position by the position's key"},"setFeeProtocol(uint8,uint8)":{inputs:[{internalType:"uint8",name:"feeProtocol0",type:"uint8"},{internalType:"uint8",name:"feeProtocol1",type:"uint8"}],name:"setFeeProtocol",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeProtocol0:"new protocol fee for token0 of the pool",feeProtocol1:"new protocol fee for token1 of the pool"},notice:"Set the denominator of the protocol's % share of the fees"},"snapshotCumulativesInside(int24,int24)":{inputs:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],name:"snapshotCumulativesInside",outputs:[{internalType:"int56",name:"tickCumulativeInside",type:"int56"},{internalType:"uint160",name:"secondsPerLiquidityInsideX128",type:"uint160"},{internalType:"uint32",name:"secondsInside",type:"uint32"}],stateMutability:"view",type:"function",details:"Snapshots must only be compared to other snapshots, taken over a period for which a position existed. I.e., snapshots cannot be compared if a position is not held for the entire period between when the first snapshot is taken and the second snapshot is taken.",params:{tickLower:"The lower tick of the range",tickUpper:"The upper tick of the range"},returns:{secondsInside:"The snapshot of seconds per liquidity for the range",secondsPerLiquidityInsideX128:"The snapshot of seconds per liquidity for the range",tickCumulativeInside:"The snapshot of the tick accumulator for the range"},notice:"Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range"},"swap(address,bool,int256,uint160,bytes)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"bool",name:"zeroForOne",type:"bool"},{internalType:"int256",name:"amountSpecified",type:"int256"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"},{internalType:"bytes",name:"data",type:"bytes"}],name:"swap",outputs:[{internalType:"int256",name:"amount0",type:"int256"},{internalType:"int256",name:"amount1",type:"int256"}],stateMutability:"nonpayable",type:"function",details:"The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback",params:{amountSpecified:"The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)",data:"Any data to be passed through to the callback",recipient:"The address to receive the output of the swap",sqrtPriceLimitX96:"The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap",zeroForOne:"The direction of the swap, true for token0 to token1, false for token1 to token0"},returns:{amount0:"The delta of the balance of token0 of the pool, exact when negative, minimum when positive",amount1:"The delta of the balance of token1 of the pool, exact when negative, minimum when positive"},notice:"Swap token0 for token1, or token1 for token0"},"tickBitmap(int16)":{inputs:[{internalType:"int16",name:"",type:"int16"}],name:"tickBitmap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"Returns 256 packed tick initialized boolean values. See TickBitmap for more information"},"ticks(int24)":{inputs:[{internalType:"int24",name:"",type:"int24"}],name:"ticks",outputs:[{internalType:"uint128",name:"liquidityGross",type:"uint128"},{internalType:"int128",name:"liquidityNet",type:"int128"},{internalType:"uint256",name:"feeGrowthOutside0X128",type:"uint256"},{internalType:"uint256",name:"feeGrowthOutside1X128",type:"uint256"},{internalType:"int56",name:"tickCumulativeOutside",type:"int56"},{internalType:"uint160",name:"secondsPerLiquidityOutsideX128",type:"uint160"},{internalType:"uint32",name:"secondsOutside",type:"uint32"},{internalType:"bool",name:"initialized",type:"bool"}],stateMutability:"view",type:"function",notice:"Look up information about a specific tick in the pool"}}},"contracts/mocks/uniswapV3/core/UniswapV3PoolDeployer.sol:UniswapV3PoolDeployer":{source:"contracts/mocks/uniswapV3/core/UniswapV3PoolDeployer.sol",name:"UniswapV3PoolDeployer",stateVariables:{"parameters()":{inputs:[],name:"parameters",outputs:[{internalType:"address",name:"factory",type:"address"},{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"int24",name:"tickSpacing",type:"int24"}],stateMutability:"view",type:"stateVariable",details:"Called by the pool constructor to fetch the parameters of the pool Returns factory The factory address Returns token0 The first token of the pool by address sort order Returns token1 The second token of the pool by address sort order Returns fee The fee collected upon every swap in the pool, denominated in hundredths of a bip Returns tickSpacing The minimum number of ticks between initialized ticks",notice:"Get the parameters to be used in constructing the pool, set transiently during pool creation."}}},"contracts/mocks/uniswapV3/core/interfaces/IERC20Minimal.sol:IERC20Minimal":{source:"contracts/mocks/uniswapV3/core/interfaces/IERC20Minimal.sol",name:"IERC20Minimal",title:"Minimal ERC20 interface for Uniswap",notice:"Contains a subset of the full ERC20 interface that is used in Uniswap V3",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event",params:{owner:"The account that approved spending of its tokens",spender:"The account for which the spending allowance was modified",value:"The new allowance from the owner to the spender"},notice:"Event emitted when the approval amount for the spender of a given owner's tokens changes."},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event",params:{from:"The account from which the tokens were sent, i.e. the balance decreased",to:"The account to which the tokens were sent, i.e. the balance increased",value:"The amount of tokens that were transferred"},notice:"Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`."}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{owner:"The account of the token owner",spender:"The account of the token spender"},returns:{_0:"The current allowance granted by `owner` to `spender`"},notice:"Returns the current allowance given to a spender by an owner"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",params:{amount:"The amount of tokens allowed to be used by `spender`",spender:"The account which will be allowed to spend a given amount of the owners tokens"},returns:{_0:"Returns true for a successful approval, false for unsuccessful"},notice:"Sets the allowance of a spender from the `msg.sender` to the value `amount`"},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{account:"The account for which to look up the number of tokens it has, i.e. its balance"},returns:{_0:"The number of tokens held by the account"},notice:"Returns the balance of a token"},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",params:{amount:"The number of tokens to send from the sender to the recipient",recipient:"The account that will receive the amount transferred"},returns:{_0:"Returns true for a successful transfer, false for an unsuccessful transfer"},notice:"Transfers the amount of token from the `msg.sender` to the recipient"},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",params:{amount:"The amount of the transfer",recipient:"The recipient of the transfer",sender:"The account from which the transfer will be initiated"},returns:{_0:"Returns true for a successful transfer, false for unsuccessful"},notice:"Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`"}}},"contracts/mocks/uniswapV3/core/interfaces/IUniswapV3Factory.sol:IUniswapV3Factory":{source:"contracts/mocks/uniswapV3/core/interfaces/IUniswapV3Factory.sol",name:"IUniswapV3Factory",title:"The interface for the Uniswap V3 Factory",notice:"The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees",events:{"FeeAmountEnabled(uint24,int24)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint24",name:"fee",type:"uint24"},{indexed:!0,internalType:"int24",name:"tickSpacing",type:"int24"}],name:"FeeAmountEnabled",type:"event",params:{fee:"The enabled fee, denominated in hundredths of a bip",tickSpacing:"The minimum number of ticks between initialized ticks for pools created with the given fee"},notice:"Emitted when a new fee amount is enabled for pool creation via the factory"},"OwnerChanged(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnerChanged",type:"event",params:{newOwner:"The owner after the owner was changed",oldOwner:"The owner before the owner was changed"},notice:"Emitted when the owner of the factory is changed"},"PoolCreated(address,address,uint24,int24,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token0",type:"address"},{indexed:!0,internalType:"address",name:"token1",type:"address"},{indexed:!0,internalType:"uint24",name:"fee",type:"uint24"},{indexed:!1,internalType:"int24",name:"tickSpacing",type:"int24"},{indexed:!1,internalType:"address",name:"pool",type:"address"}],name:"PoolCreated",type:"event",params:{fee:"The fee collected upon every swap in the pool, denominated in hundredths of a bip",pool:"The address of the created pool",tickSpacing:"The minimum number of ticks between initialized ticks",token0:"The first token of the pool by address sort order",token1:"The second token of the pool by address sort order"},notice:"Emitted when a pool is created"}},methods:{"createPool(address,address,uint24)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"}],name:"createPool",outputs:[{internalType:"address",name:"pool",type:"address"}],stateMutability:"nonpayable",type:"function",details:"tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments are invalid.",params:{fee:"The desired fee for the pool",tokenA:"One of the two tokens in the desired pool",tokenB:"The other of the two tokens in the desired pool"},returns:{pool:"The address of the newly created pool"},notice:"Creates a pool for the given two tokens and fee"},"enableFeeAmount(uint24,int24)":{inputs:[{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"int24",name:"tickSpacing",type:"int24"}],name:"enableFeeAmount",outputs:[],stateMutability:"nonpayable",type:"function",details:"Fee amounts may never be removed once enabled",params:{fee:"The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)",tickSpacing:"The spacing between ticks to be enforced for all pools created with the given fee amount"},notice:"Enables a fee amount with the given tickSpacing"},"feeAmountTickSpacing(uint24)":{inputs:[{internalType:"uint24",name:"fee",type:"uint24"}],name:"feeAmountTickSpacing",outputs:[{internalType:"int24",name:"",type:"int24"}],stateMutability:"view",type:"function",details:"A fee amount can never be removed, so this value should be hard coded or cached in the calling context",params:{fee:"The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee"},returns:{_0:"The tick spacing"},notice:"Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled"},"getPool(address,address,uint24)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"}],name:"getPool",outputs:[{internalType:"address",name:"pool",type:"address"}],stateMutability:"view",type:"function",details:"tokenA and tokenB may be passed in either token0/token1 or token1/token0 order",params:{fee:"The fee collected upon every swap in the pool, denominated in hundredths of a bip",tokenA:"The contract address of either token0 or token1",tokenB:"The contract address of the other token"},returns:{pool:"The pool address"},notice:"Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Can be changed by the current owner via setOwner",returns:{_0:"The address of the factory owner"},notice:"Returns the current owner of the factory"},"setOwner(address)":{inputs:[{internalType:"address",name:"_owner",type:"address"}],name:"setOwner",outputs:[],stateMutability:"nonpayable",type:"function",details:"Must be called by the current owner",params:{_owner:"The new owner of the factory"},notice:"Updates the owner of the factory"}}},"contracts/mocks/uniswapV3/core/interfaces/IUniswapV3Pool.sol:IUniswapV3Pool":{source:"contracts/mocks/uniswapV3/core/interfaces/IUniswapV3Pool.sol",name:"IUniswapV3Pool",title:"The interface for a Uniswap V3 Pool",details:"The pool interface is broken up into many smaller pieces",notice:"A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform to the ERC20 specification",events:{"Burn(address,int24,int24,uint128,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"int24",name:"tickLower",type:"int24"},{indexed:!0,internalType:"int24",name:"tickUpper",type:"int24"},{indexed:!1,internalType:"uint128",name:"amount",type:"uint128"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"Burn",type:"event",notice:"Emitted when a position's liquidity is removed"},"Collect(address,address,int24,int24,uint128,uint128)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"address",name:"recipient",type:"address"},{indexed:!0,internalType:"int24",name:"tickLower",type:"int24"},{indexed:!0,internalType:"int24",name:"tickUpper",type:"int24"},{indexed:!1,internalType:"uint128",name:"amount0",type:"uint128"},{indexed:!1,internalType:"uint128",name:"amount1",type:"uint128"}],name:"Collect",type:"event",notice:"Emitted when fees are collected by the owner of a position"},"CollectProtocol(address,address,uint128,uint128)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!0,internalType:"address",name:"recipient",type:"address"},{indexed:!1,internalType:"uint128",name:"amount0",type:"uint128"},{indexed:!1,internalType:"uint128",name:"amount1",type:"uint128"}],name:"CollectProtocol",type:"event",notice:"Emitted when the collected protocol fees are withdrawn by the factory owner"},"Flash(address,address,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!0,internalType:"address",name:"recipient",type:"address"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"},{indexed:!1,internalType:"uint256",name:"paid0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"paid1",type:"uint256"}],name:"Flash",type:"event",notice:"Emitted by the pool for any flashes of token0/token1"},"IncreaseObservationCardinalityNext(uint16,uint16)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint16",name:"observationCardinalityNextOld",type:"uint16"},{indexed:!1,internalType:"uint16",name:"observationCardinalityNextNew",type:"uint16"}],name:"IncreaseObservationCardinalityNext",type:"event",notice:"Emitted by the pool for increases to the number of observations that can be stored"},"Initialize(uint160,int24)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint160",name:"sqrtPriceX96",type:"uint160"},{indexed:!1,internalType:"int24",name:"tick",type:"int24"}],name:"Initialize",type:"event",notice:"Emitted exactly once by a pool when #initialize is first called on the pool"},"Mint(address,address,int24,int24,uint128,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"sender",type:"address"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"int24",name:"tickLower",type:"int24"},{indexed:!0,internalType:"int24",name:"tickUpper",type:"int24"},{indexed:!1,internalType:"uint128",name:"amount",type:"uint128"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"Mint",type:"event",notice:"Emitted when liquidity is minted for a given position"},"SetFeeProtocol(uint8,uint8,uint8,uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"feeProtocol0Old",type:"uint8"},{indexed:!1,internalType:"uint8",name:"feeProtocol1Old",type:"uint8"},{indexed:!1,internalType:"uint8",name:"feeProtocol0New",type:"uint8"},{indexed:!1,internalType:"uint8",name:"feeProtocol1New",type:"uint8"}],name:"SetFeeProtocol",type:"event",notice:"Emitted when the protocol fee is changed by the pool"},"Swap(address,address,int256,int256,uint160,uint128,int24)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!0,internalType:"address",name:"recipient",type:"address"},{indexed:!1,internalType:"int256",name:"amount0",type:"int256"},{indexed:!1,internalType:"int256",name:"amount1",type:"int256"},{indexed:!1,internalType:"uint160",name:"sqrtPriceX96",type:"uint160"},{indexed:!1,internalType:"uint128",name:"liquidity",type:"uint128"},{indexed:!1,internalType:"int24",name:"tick",type:"int24"}],name:"Swap",type:"event",notice:"Emitted by the pool for any swaps between token0 and token1"}},methods:{"burn(int24,int24,uint128)":{inputs:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint128",name:"amount",type:"uint128"}],name:"burn",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0Fees must be collected separately via a call to #collect",params:{amount:"How much liquidity to burn",tickLower:"The lower tick of the position for which to burn liquidity",tickUpper:"The upper tick of the position for which to burn liquidity"},returns:{amount0:"The amount of token0 sent to the recipient",amount1:"The amount of token1 sent to the recipient"},notice:"Burn liquidity from the sender and account tokens owed for the liquidity to the position"},"collect(address,int24,int24,uint128,uint128)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint128",name:"amount0Requested",type:"uint128"},{internalType:"uint128",name:"amount1Requested",type:"uint128"}],name:"collect",outputs:[{internalType:"uint128",name:"amount0",type:"uint128"},{internalType:"uint128",name:"amount1",type:"uint128"}],stateMutability:"nonpayable",type:"function",details:"Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity. Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.",params:{amount0Requested:"How much token0 should be withdrawn from the fees owed",amount1Requested:"How much token1 should be withdrawn from the fees owed",recipient:"The address which should receive the fees collected",tickLower:"The lower tick of the position for which to collect fees",tickUpper:"The upper tick of the position for which to collect fees"},returns:{amount0:"The amount of fees collected in token0",amount1:"The amount of fees collected in token1"},notice:"Collects tokens owed to a position"},"collectProtocol(address,uint128,uint128)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint128",name:"amount0Requested",type:"uint128"},{internalType:"uint128",name:"amount1Requested",type:"uint128"}],name:"collectProtocol",outputs:[{internalType:"uint128",name:"amount0",type:"uint128"},{internalType:"uint128",name:"amount1",type:"uint128"}],stateMutability:"nonpayable",type:"function",params:{amount0Requested:"The maximum amount of token0 to send, can be 0 to collect fees in only token1",amount1Requested:"The maximum amount of token1 to send, can be 0 to collect fees in only token0",recipient:"The address to which collected protocol fees should be sent"},returns:{amount0:"The protocol fee collected in token0",amount1:"The protocol fee collected in token1"},notice:"Collect the protocol fee accrued to the pool"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",returns:{_0:"The contract address"},notice:"The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface"},"fee()":{inputs:[],name:"fee",outputs:[{internalType:"uint24",name:"",type:"uint24"}],stateMutability:"view",type:"function",returns:{_0:"The fee"},notice:"The pool's fee in hundredths of a bip, i.e. 1e-6"},"feeGrowthGlobal0X128()":{inputs:[],name:"feeGrowthGlobal0X128",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"This value can overflow the uint256",notice:"The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool"},"feeGrowthGlobal1X128()":{inputs:[],name:"feeGrowthGlobal1X128",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"This value can overflow the uint256",notice:"The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool"},"flash(address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"flash",outputs:[],stateMutability:"nonpayable",type:"function",details:"The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallbackCan be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling with 0 amount{0,1} and sending the donation amount(s) from the callback",params:{amount0:"The amount of token0 to send",amount1:"The amount of token1 to send",data:"Any data to be passed through to the callback",recipient:"The address which will receive the token0 and token1 amounts"},notice:"Receive token0 and/or token1 and pay it back, plus a fee, in the callback"},"increaseObservationCardinalityNext(uint16)":{inputs:[{internalType:"uint16",name:"observationCardinalityNext",type:"uint16"}],name:"increaseObservationCardinalityNext",outputs:[],stateMutability:"nonpayable",type:"function",details:"This method is no-op if the pool already has an observationCardinalityNext greater than or equal to the input observationCardinalityNext.",params:{observationCardinalityNext:"The desired minimum number of observations for the pool to store"},notice:"Increase the maximum number of price and liquidity observations that this pool will store"},"initialize(uint160)":{inputs:[{internalType:"uint160",name:"sqrtPriceX96",type:"uint160"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value",params:{sqrtPriceX96:"the initial sqrt price of the pool as a Q64.96"},notice:"Sets the initial price for the pool"},"liquidity()":{inputs:[],name:"liquidity",outputs:[{internalType:"uint128",name:"",type:"uint128"}],stateMutability:"view",type:"function",details:"This value has no relationship to the total liquidity across all ticks",notice:"The currently in range liquidity available to the pool"},"maxLiquidityPerTick()":{inputs:[],name:"maxLiquidityPerTick",outputs:[{internalType:"uint128",name:"",type:"uint128"}],stateMutability:"view",type:"function",details:"This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool",returns:{_0:"The max amount of liquidity per tick"},notice:"The maximum amount of position liquidity that can use any tick in the range"},"mint(address,int24,int24,uint128,bytes)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint128",name:"amount",type:"uint128"},{internalType:"bytes",name:"data",type:"bytes"}],name:"mint",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends on tickLower, tickUpper, the amount of liquidity, and the current price.",params:{amount:"The amount of liquidity to mint",data:"Any data that should be passed through to the callback",recipient:"The address for which the liquidity will be created",tickLower:"The lower tick of the position in which to add liquidity",tickUpper:"The upper tick of the position in which to add liquidity"},returns:{amount0:"The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback",amount1:"The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback"},notice:"Adds liquidity for the given recipient/tickLower/tickUpper position"},"observations(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"observations",outputs:[{internalType:"uint32",name:"blockTimestamp",type:"uint32"},{internalType:"int56",name:"tickCumulative",type:"int56"},{internalType:"uint160",name:"secondsPerLiquidityCumulativeX128",type:"uint160"},{internalType:"bool",name:"initialized",type:"bool"}],stateMutability:"view",type:"function",details:"You most likely want to use #observe() instead of this method to get an observation as of some amount of time ago, rather than at a specific index in the array.",params:{index:"The element of the observations array to fetch"},returns:{blockTimestamp:"The timestamp of the observation, Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp, Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp, Returns initialized whether the observation has been initialized and the values are safe to use"},notice:"Returns data about a specific observation index"},"observe(uint32[])":{inputs:[{internalType:"uint32[]",name:"secondsAgos",type:"uint32[]"}],name:"observe",outputs:[{internalType:"int56[]",name:"tickCumulatives",type:"int56[]"},{internalType:"uint160[]",name:"secondsPerLiquidityCumulativeX128s",type:"uint160[]"}],stateMutability:"view",type:"function",details:"To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick, you must call it with secondsAgos = [3600, 0].The time weighted average tick represents the geometric time weighted average price of the pool, in log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.",params:{secondsAgos:"From how long ago each cumulative tick and liquidity value should be returned"},returns:{secondsPerLiquidityCumulativeX128s:"Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block timestamp",tickCumulatives:"Cumulative tick values as of each `secondsAgos` from the current block timestamp"},notice:"Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp"},"positions(bytes32)":{inputs:[{internalType:"bytes32",name:"key",type:"bytes32"}],name:"positions",outputs:[{internalType:"uint128",name:"_liquidity",type:"uint128"},{internalType:"uint256",name:"feeGrowthInside0LastX128",type:"uint256"},{internalType:"uint256",name:"feeGrowthInside1LastX128",type:"uint256"},{internalType:"uint128",name:"tokensOwed0",type:"uint128"},{internalType:"uint128",name:"tokensOwed1",type:"uint128"}],stateMutability:"view",type:"function",params:{key:"The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper"},returns:{_liquidity:"The amount of liquidity in the position, Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke, Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke, Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke, Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke"},notice:"Returns the information about a position by the position's key"},"protocolFees()":{inputs:[],name:"protocolFees",outputs:[{internalType:"uint128",name:"token0",type:"uint128"},{internalType:"uint128",name:"token1",type:"uint128"}],stateMutability:"view",type:"function",details:"Protocol fees will never exceed uint128 max in either token",notice:"The amounts of token0 and token1 that are owed to the protocol"},"setFeeProtocol(uint8,uint8)":{inputs:[{internalType:"uint8",name:"feeProtocol0",type:"uint8"},{internalType:"uint8",name:"feeProtocol1",type:"uint8"}],name:"setFeeProtocol",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeProtocol0:"new protocol fee for token0 of the pool",feeProtocol1:"new protocol fee for token1 of the pool"},notice:"Set the denominator of the protocol's % share of the fees"},"slot0()":{inputs:[],name:"slot0",outputs:[{internalType:"uint160",name:"sqrtPriceX96",type:"uint160"},{internalType:"int24",name:"tick",type:"int24"},{internalType:"uint16",name:"observationIndex",type:"uint16"},{internalType:"uint16",name:"observationCardinality",type:"uint16"},{internalType:"uint16",name:"observationCardinalityNext",type:"uint16"},{internalType:"uint8",name:"feeProtocol",type:"uint8"},{internalType:"bool",name:"unlocked",type:"bool"}],stateMutability:"view",type:"function",returns:{sqrtPriceX96:"The current price of the pool as a sqrt(token1/token0) Q64.96 value tick The current tick of the pool, i.e. according to the last tick transition that was run. This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick boundary. observationIndex The index of the last oracle observation that was written, observationCardinality The current maximum number of observations stored in the pool, observationCardinalityNext The next maximum number of observations, to be updated when the observation. feeProtocol The protocol fee for both tokens of the pool. Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0 is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee. unlocked Whether the pool is currently locked to reentrancy"},notice:"The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas when accessed externally."},"snapshotCumulativesInside(int24,int24)":{inputs:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],name:"snapshotCumulativesInside",outputs:[{internalType:"int56",name:"tickCumulativeInside",type:"int56"},{internalType:"uint160",name:"secondsPerLiquidityInsideX128",type:"uint160"},{internalType:"uint32",name:"secondsInside",type:"uint32"}],stateMutability:"view",type:"function",details:"Snapshots must only be compared to other snapshots, taken over a period for which a position existed. I.e., snapshots cannot be compared if a position is not held for the entire period between when the first snapshot is taken and the second snapshot is taken.",params:{tickLower:"The lower tick of the range",tickUpper:"The upper tick of the range"},returns:{secondsInside:"The snapshot of seconds per liquidity for the range",secondsPerLiquidityInsideX128:"The snapshot of seconds per liquidity for the range",tickCumulativeInside:"The snapshot of the tick accumulator for the range"},notice:"Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range"},"swap(address,bool,int256,uint160,bytes)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"bool",name:"zeroForOne",type:"bool"},{internalType:"int256",name:"amountSpecified",type:"int256"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"},{internalType:"bytes",name:"data",type:"bytes"}],name:"swap",outputs:[{internalType:"int256",name:"amount0",type:"int256"},{internalType:"int256",name:"amount1",type:"int256"}],stateMutability:"nonpayable",type:"function",details:"The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback",params:{amountSpecified:"The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)",data:"Any data to be passed through to the callback",recipient:"The address to receive the output of the swap",sqrtPriceLimitX96:"The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap",zeroForOne:"The direction of the swap, true for token0 to token1, false for token1 to token0"},returns:{amount0:"The delta of the balance of token0 of the pool, exact when negative, minimum when positive",amount1:"The delta of the balance of token1 of the pool, exact when negative, minimum when positive"},notice:"Swap token0 for token1, or token1 for token0"},"tickBitmap(int16)":{inputs:[{internalType:"int16",name:"wordPosition",type:"int16"}],name:"tickBitmap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"Returns 256 packed tick initialized boolean values. See TickBitmap for more information"},"tickSpacing()":{inputs:[],name:"tickSpacing",outputs:[{internalType:"int24",name:"",type:"int24"}],stateMutability:"view",type:"function",details:"Ticks can only be used at multiples of this value, minimum of 1 and always positive e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ... This value is an int24 to avoid casting even though it is always positive.",returns:{_0:"The tick spacing"},notice:"The pool tick spacing"},"ticks(int24)":{inputs:[{internalType:"int24",name:"tick",type:"int24"}],name:"ticks",outputs:[{internalType:"uint128",name:"liquidityGross",type:"uint128"},{internalType:"int128",name:"liquidityNet",type:"int128"},{internalType:"uint256",name:"feeGrowthOutside0X128",type:"uint256"},{internalType:"uint256",name:"feeGrowthOutside1X128",type:"uint256"},{internalType:"int56",name:"tickCumulativeOutside",type:"int56"},{internalType:"uint160",name:"secondsPerLiquidityOutsideX128",type:"uint160"},{internalType:"uint32",name:"secondsOutside",type:"uint32"},{internalType:"bool",name:"initialized",type:"bool"}],stateMutability:"view",type:"function",params:{tick:"The tick to look up"},returns:{liquidityGross:"the total amount of position liquidity that uses the pool either as tick lower or tick upper, liquidityNet how much liquidity changes when the pool price crosses the tick, feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0, feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1, tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick, secondsOutside the seconds spent on the other side of the tick from the current tick, initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false. Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0. In addition, these values are only relative and must be used only in comparison to previous snapshots for a specific position."},notice:"Look up information about a specific tick in the pool"},"token0()":{inputs:[],name:"token0",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",returns:{_0:"The token contract address"},notice:"The first of the two tokens of the pool, sorted by address"},"token1()":{inputs:[],name:"token1",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",returns:{_0:"The token contract address"},notice:"The second of the two tokens of the pool, sorted by address"}}},"contracts/mocks/uniswapV3/core/interfaces/IUniswapV3PoolDeployer.sol:IUniswapV3PoolDeployer":{source:"contracts/mocks/uniswapV3/core/interfaces/IUniswapV3PoolDeployer.sol",name:"IUniswapV3PoolDeployer",title:"An interface for a contract that is capable of deploying Uniswap V3 Pools",details:"This is used to avoid having constructor arguments in the pool contract, which results in the init code hash of the pool being constant allowing the CREATE2 address of the pool to be cheaply computed on-chain",notice:"A contract that constructs a pool must implement this to pass arguments to the pool",methods:{"parameters()":{inputs:[],name:"parameters",outputs:[{internalType:"address",name:"factory",type:"address"},{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"int24",name:"tickSpacing",type:"int24"}],stateMutability:"view",type:"function",details:"Called by the pool constructor to fetch the parameters of the pool Returns factory The factory address Returns token0 The first token of the pool by address sort order Returns token1 The second token of the pool by address sort order Returns fee The fee collected upon every swap in the pool, denominated in hundredths of a bip Returns tickSpacing The minimum number of ticks between initialized ticks",notice:"Get the parameters to be used in constructing the pool, set transiently during pool creation."}}},"contracts/mocks/uniswapV3/core/interfaces/callback/IUniswapV3FlashCallback.sol:IUniswapV3FlashCallback":{source:"contracts/mocks/uniswapV3/core/interfaces/callback/IUniswapV3FlashCallback.sol",name:"IUniswapV3FlashCallback",title:"Callback for IUniswapV3PoolActions#flash",notice:"Any contract that calls IUniswapV3PoolActions#flash must implement this interface",methods:{"uniswapV3FlashCallback(uint256,uint256,bytes)":{inputs:[{internalType:"uint256",name:"fee0",type:"uint256"},{internalType:"uint256",name:"fee1",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"uniswapV3FlashCallback",outputs:[],stateMutability:"nonpayable",type:"function",details:"In the implementation you must repay the pool the tokens sent by flash plus the computed fee amounts. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.",params:{data:"Any data passed through by the caller via the IUniswapV3PoolActions#flash call",fee0:"The fee amount in token0 due to the pool by the end of the flash",fee1:"The fee amount in token1 due to the pool by the end of the flash"},notice:"Called to `msg.sender` after transferring to the recipient from IUniswapV3Pool#flash."}}},"contracts/mocks/uniswapV3/core/interfaces/callback/IUniswapV3MintCallback.sol:IUniswapV3MintCallback":{source:"contracts/mocks/uniswapV3/core/interfaces/callback/IUniswapV3MintCallback.sol",name:"IUniswapV3MintCallback",title:"Callback for IUniswapV3PoolActions#mint",notice:"Any contract that calls IUniswapV3PoolActions#mint must implement this interface",methods:{"uniswapV3MintCallback(uint256,uint256,bytes)":{inputs:[{internalType:"uint256",name:"amount0Owed",type:"uint256"},{internalType:"uint256",name:"amount1Owed",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"uniswapV3MintCallback",outputs:[],stateMutability:"nonpayable",type:"function",details:"In the implementation you must pay the pool tokens owed for the minted liquidity. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.",params:{amount0Owed:"The amount of token0 due to the pool for the minted liquidity",amount1Owed:"The amount of token1 due to the pool for the minted liquidity",data:"Any data passed through by the caller via the IUniswapV3PoolActions#mint call"},notice:"Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint."}}},"contracts/mocks/uniswapV3/core/interfaces/callback/IUniswapV3SwapCallback.sol:IUniswapV3SwapCallback":{source:"contracts/mocks/uniswapV3/core/interfaces/callback/IUniswapV3SwapCallback.sol",name:"IUniswapV3SwapCallback",title:"Callback for IUniswapV3PoolActions#swap",notice:"Any contract that calls IUniswapV3PoolActions#swap must implement this interface",methods:{"uniswapV3SwapCallback(int256,int256,bytes)":{inputs:[{internalType:"int256",name:"amount0Delta",type:"int256"},{internalType:"int256",name:"amount1Delta",type:"int256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"uniswapV3SwapCallback",outputs:[],stateMutability:"nonpayable",type:"function",details:"In the implementation you must pay the pool tokens owed for the swap. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. amount0Delta and amount1Delta can both be 0 if no tokens were swapped.",params:{amount0Delta:"The amount of token0 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token0 to the pool.",amount1Delta:"The amount of token1 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token1 to the pool.",data:"Any data passed through by the caller via the IUniswapV3PoolActions#swap call"},notice:"Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap."}}},"contracts/mocks/uniswapV3/core/interfaces/pool/IUniswapV3PoolActions.sol:IUniswapV3PoolActions":{source:"contracts/mocks/uniswapV3/core/interfaces/pool/IUniswapV3PoolActions.sol",name:"IUniswapV3PoolActions",title:"Permissionless pool actions",notice:"Contains pool methods that can be called by anyone",methods:{"burn(int24,int24,uint128)":{inputs:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint128",name:"amount",type:"uint128"}],name:"burn",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0Fees must be collected separately via a call to #collect",params:{amount:"How much liquidity to burn",tickLower:"The lower tick of the position for which to burn liquidity",tickUpper:"The upper tick of the position for which to burn liquidity"},returns:{amount0:"The amount of token0 sent to the recipient",amount1:"The amount of token1 sent to the recipient"},notice:"Burn liquidity from the sender and account tokens owed for the liquidity to the position"},"collect(address,int24,int24,uint128,uint128)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint128",name:"amount0Requested",type:"uint128"},{internalType:"uint128",name:"amount1Requested",type:"uint128"}],name:"collect",outputs:[{internalType:"uint128",name:"amount0",type:"uint128"},{internalType:"uint128",name:"amount1",type:"uint128"}],stateMutability:"nonpayable",type:"function",details:"Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity. Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.",params:{amount0Requested:"How much token0 should be withdrawn from the fees owed",amount1Requested:"How much token1 should be withdrawn from the fees owed",recipient:"The address which should receive the fees collected",tickLower:"The lower tick of the position for which to collect fees",tickUpper:"The upper tick of the position for which to collect fees"},returns:{amount0:"The amount of fees collected in token0",amount1:"The amount of fees collected in token1"},notice:"Collects tokens owed to a position"},"flash(address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"flash",outputs:[],stateMutability:"nonpayable",type:"function",details:"The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallbackCan be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling with 0 amount{0,1} and sending the donation amount(s) from the callback",params:{amount0:"The amount of token0 to send",amount1:"The amount of token1 to send",data:"Any data to be passed through to the callback",recipient:"The address which will receive the token0 and token1 amounts"},notice:"Receive token0 and/or token1 and pay it back, plus a fee, in the callback"},"increaseObservationCardinalityNext(uint16)":{inputs:[{internalType:"uint16",name:"observationCardinalityNext",type:"uint16"}],name:"increaseObservationCardinalityNext",outputs:[],stateMutability:"nonpayable",type:"function",details:"This method is no-op if the pool already has an observationCardinalityNext greater than or equal to the input observationCardinalityNext.",params:{observationCardinalityNext:"The desired minimum number of observations for the pool to store"},notice:"Increase the maximum number of price and liquidity observations that this pool will store"},"initialize(uint160)":{inputs:[{internalType:"uint160",name:"sqrtPriceX96",type:"uint160"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value",params:{sqrtPriceX96:"the initial sqrt price of the pool as a Q64.96"},notice:"Sets the initial price for the pool"},"mint(address,int24,int24,uint128,bytes)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint128",name:"amount",type:"uint128"},{internalType:"bytes",name:"data",type:"bytes"}],name:"mint",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends on tickLower, tickUpper, the amount of liquidity, and the current price.",params:{amount:"The amount of liquidity to mint",data:"Any data that should be passed through to the callback",recipient:"The address for which the liquidity will be created",tickLower:"The lower tick of the position in which to add liquidity",tickUpper:"The upper tick of the position in which to add liquidity"},returns:{amount0:"The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback",amount1:"The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback"},notice:"Adds liquidity for the given recipient/tickLower/tickUpper position"},"swap(address,bool,int256,uint160,bytes)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"bool",name:"zeroForOne",type:"bool"},{internalType:"int256",name:"amountSpecified",type:"int256"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"},{internalType:"bytes",name:"data",type:"bytes"}],name:"swap",outputs:[{internalType:"int256",name:"amount0",type:"int256"},{internalType:"int256",name:"amount1",type:"int256"}],stateMutability:"nonpayable",type:"function",details:"The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback",params:{amountSpecified:"The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)",data:"Any data to be passed through to the callback",recipient:"The address to receive the output of the swap",sqrtPriceLimitX96:"The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap",zeroForOne:"The direction of the swap, true for token0 to token1, false for token1 to token0"},returns:{amount0:"The delta of the balance of token0 of the pool, exact when negative, minimum when positive",amount1:"The delta of the balance of token1 of the pool, exact when negative, minimum when positive"},notice:"Swap token0 for token1, or token1 for token0"}}},"contracts/mocks/uniswapV3/core/interfaces/pool/IUniswapV3PoolDerivedState.sol:IUniswapV3PoolDerivedState":{source:"contracts/mocks/uniswapV3/core/interfaces/pool/IUniswapV3PoolDerivedState.sol",name:"IUniswapV3PoolDerivedState",title:"Pool state that is not stored",notice:"Contains view functions to provide information about the pool that is computed rather than stored on the blockchain. The functions here may have variable gas costs.",methods:{"observe(uint32[])":{inputs:[{internalType:"uint32[]",name:"secondsAgos",type:"uint32[]"}],name:"observe",outputs:[{internalType:"int56[]",name:"tickCumulatives",type:"int56[]"},{internalType:"uint160[]",name:"secondsPerLiquidityCumulativeX128s",type:"uint160[]"}],stateMutability:"view",type:"function",details:"To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick, you must call it with secondsAgos = [3600, 0].The time weighted average tick represents the geometric time weighted average price of the pool, in log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.",params:{secondsAgos:"From how long ago each cumulative tick and liquidity value should be returned"},returns:{secondsPerLiquidityCumulativeX128s:"Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block timestamp",tickCumulatives:"Cumulative tick values as of each `secondsAgos` from the current block timestamp"},notice:"Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp"},"snapshotCumulativesInside(int24,int24)":{inputs:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],name:"snapshotCumulativesInside",outputs:[{internalType:"int56",name:"tickCumulativeInside",type:"int56"},{internalType:"uint160",name:"secondsPerLiquidityInsideX128",type:"uint160"},{internalType:"uint32",name:"secondsInside",type:"uint32"}],stateMutability:"view",type:"function",details:"Snapshots must only be compared to other snapshots, taken over a period for which a position existed. I.e., snapshots cannot be compared if a position is not held for the entire period between when the first snapshot is taken and the second snapshot is taken.",params:{tickLower:"The lower tick of the range",tickUpper:"The upper tick of the range"},returns:{secondsInside:"The snapshot of seconds per liquidity for the range",secondsPerLiquidityInsideX128:"The snapshot of seconds per liquidity for the range",tickCumulativeInside:"The snapshot of the tick accumulator for the range"},notice:"Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range"}}},"contracts/mocks/uniswapV3/core/interfaces/pool/IUniswapV3PoolEvents.sol:IUniswapV3PoolEvents":{source:"contracts/mocks/uniswapV3/core/interfaces/pool/IUniswapV3PoolEvents.sol",name:"IUniswapV3PoolEvents",title:"Events emitted by a pool",notice:"Contains all events emitted by the pool",events:{"Burn(address,int24,int24,uint128,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"int24",name:"tickLower",type:"int24"},{indexed:!0,internalType:"int24",name:"tickUpper",type:"int24"},{indexed:!1,internalType:"uint128",name:"amount",type:"uint128"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"Burn",type:"event",details:"Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect",params:{amount:"The amount of liquidity to remove",amount0:"The amount of token0 withdrawn",amount1:"The amount of token1 withdrawn",owner:"The owner of the position for which liquidity is removed",tickLower:"The lower tick of the position",tickUpper:"The upper tick of the position"},notice:"Emitted when a position's liquidity is removed"},"Collect(address,address,int24,int24,uint128,uint128)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"address",name:"recipient",type:"address"},{indexed:!0,internalType:"int24",name:"tickLower",type:"int24"},{indexed:!0,internalType:"int24",name:"tickUpper",type:"int24"},{indexed:!1,internalType:"uint128",name:"amount0",type:"uint128"},{indexed:!1,internalType:"uint128",name:"amount1",type:"uint128"}],name:"Collect",type:"event",details:"Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees",params:{amount0:"The amount of token0 fees collected",amount1:"The amount of token1 fees collected",owner:"The owner of the position for which fees are collected",tickLower:"The lower tick of the position",tickUpper:"The upper tick of the position"},notice:"Emitted when fees are collected by the owner of a position"},"CollectProtocol(address,address,uint128,uint128)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!0,internalType:"address",name:"recipient",type:"address"},{indexed:!1,internalType:"uint128",name:"amount0",type:"uint128"},{indexed:!1,internalType:"uint128",name:"amount1",type:"uint128"}],name:"CollectProtocol",type:"event",params:{amount0:"The amount of token1 protocol fees that is withdrawn",recipient:"The address that receives the collected protocol fees",sender:"The address that collects the protocol fees"},notice:"Emitted when the collected protocol fees are withdrawn by the factory owner"},"Flash(address,address,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!0,internalType:"address",name:"recipient",type:"address"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"},{indexed:!1,internalType:"uint256",name:"paid0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"paid1",type:"uint256"}],name:"Flash",type:"event",params:{amount0:"The amount of token0 that was flashed",amount1:"The amount of token1 that was flashed",paid0:"The amount of token0 paid for the flash, which can exceed the amount0 plus the fee",paid1:"The amount of token1 paid for the flash, which can exceed the amount1 plus the fee",recipient:"The address that received the tokens from flash",sender:"The address that initiated the swap call, and that received the callback"},notice:"Emitted by the pool for any flashes of token0/token1"},"IncreaseObservationCardinalityNext(uint16,uint16)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint16",name:"observationCardinalityNextOld",type:"uint16"},{indexed:!1,internalType:"uint16",name:"observationCardinalityNextNew",type:"uint16"}],name:"IncreaseObservationCardinalityNext",type:"event",details:"observationCardinalityNext is not the observation cardinality until an observation is written at the index just before a mint/swap/burn.",params:{observationCardinalityNextNew:"The updated value of the next observation cardinality",observationCardinalityNextOld:"The previous value of the next observation cardinality"},notice:"Emitted by the pool for increases to the number of observations that can be stored"},"Initialize(uint160,int24)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint160",name:"sqrtPriceX96",type:"uint160"},{indexed:!1,internalType:"int24",name:"tick",type:"int24"}],name:"Initialize",type:"event",details:"Mint/Burn/Swap cannot be emitted by the pool before Initialize",params:{sqrtPriceX96:"The initial sqrt price of the pool, as a Q64.96",tick:"The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool"},notice:"Emitted exactly once by a pool when #initialize is first called on the pool"},"Mint(address,address,int24,int24,uint128,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"sender",type:"address"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"int24",name:"tickLower",type:"int24"},{indexed:!0,internalType:"int24",name:"tickUpper",type:"int24"},{indexed:!1,internalType:"uint128",name:"amount",type:"uint128"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"Mint",type:"event",params:{amount:"The amount of liquidity minted to the position range",amount0:"How much token0 was required for the minted liquidity",amount1:"How much token1 was required for the minted liquidity",owner:"The owner of the position and recipient of any minted liquidity",sender:"The address that minted the liquidity",tickLower:"The lower tick of the position",tickUpper:"The upper tick of the position"},notice:"Emitted when liquidity is minted for a given position"},"SetFeeProtocol(uint8,uint8,uint8,uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"feeProtocol0Old",type:"uint8"},{indexed:!1,internalType:"uint8",name:"feeProtocol1Old",type:"uint8"},{indexed:!1,internalType:"uint8",name:"feeProtocol0New",type:"uint8"},{indexed:!1,internalType:"uint8",name:"feeProtocol1New",type:"uint8"}],name:"SetFeeProtocol",type:"event",params:{feeProtocol0New:"The updated value of the token0 protocol fee",feeProtocol0Old:"The previous value of the token0 protocol fee",feeProtocol1New:"The updated value of the token1 protocol fee",feeProtocol1Old:"The previous value of the token1 protocol fee"},notice:"Emitted when the protocol fee is changed by the pool"},"Swap(address,address,int256,int256,uint160,uint128,int24)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!0,internalType:"address",name:"recipient",type:"address"},{indexed:!1,internalType:"int256",name:"amount0",type:"int256"},{indexed:!1,internalType:"int256",name:"amount1",type:"int256"},{indexed:!1,internalType:"uint160",name:"sqrtPriceX96",type:"uint160"},{indexed:!1,internalType:"uint128",name:"liquidity",type:"uint128"},{indexed:!1,internalType:"int24",name:"tick",type:"int24"}],name:"Swap",type:"event",params:{amount0:"The delta of the token0 balance of the pool",amount1:"The delta of the token1 balance of the pool",liquidity:"The liquidity of the pool after the swap",recipient:"The address that received the output of the swap",sender:"The address that initiated the swap call, and that received the callback",sqrtPriceX96:"The sqrt(price) of the pool after the swap, as a Q64.96",tick:"The log base 1.0001 of price of the pool after the swap"},notice:"Emitted by the pool for any swaps between token0 and token1"}}},"contracts/mocks/uniswapV3/core/interfaces/pool/IUniswapV3PoolImmutables.sol:IUniswapV3PoolImmutables":{source:"contracts/mocks/uniswapV3/core/interfaces/pool/IUniswapV3PoolImmutables.sol",name:"IUniswapV3PoolImmutables",title:"Pool state that never changes",notice:"These parameters are fixed for a pool forever, i.e., the methods will always return the same values",methods:{"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",returns:{_0:"The contract address"},notice:"The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface"},"fee()":{inputs:[],name:"fee",outputs:[{internalType:"uint24",name:"",type:"uint24"}],stateMutability:"view",type:"function",returns:{_0:"The fee"},notice:"The pool's fee in hundredths of a bip, i.e. 1e-6"},"maxLiquidityPerTick()":{inputs:[],name:"maxLiquidityPerTick",outputs:[{internalType:"uint128",name:"",type:"uint128"}],stateMutability:"view",type:"function",details:"This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool",returns:{_0:"The max amount of liquidity per tick"},notice:"The maximum amount of position liquidity that can use any tick in the range"},"tickSpacing()":{inputs:[],name:"tickSpacing",outputs:[{internalType:"int24",name:"",type:"int24"}],stateMutability:"view",type:"function",details:"Ticks can only be used at multiples of this value, minimum of 1 and always positive e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ... This value is an int24 to avoid casting even though it is always positive.",returns:{_0:"The tick spacing"},notice:"The pool tick spacing"},"token0()":{inputs:[],name:"token0",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",returns:{_0:"The token contract address"},notice:"The first of the two tokens of the pool, sorted by address"},"token1()":{inputs:[],name:"token1",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",returns:{_0:"The token contract address"},notice:"The second of the two tokens of the pool, sorted by address"}}},"contracts/mocks/uniswapV3/core/interfaces/pool/IUniswapV3PoolOwnerActions.sol:IUniswapV3PoolOwnerActions":{source:"contracts/mocks/uniswapV3/core/interfaces/pool/IUniswapV3PoolOwnerActions.sol",name:"IUniswapV3PoolOwnerActions",title:"Permissioned pool actions",notice:"Contains pool methods that may only be called by the factory owner",methods:{"collectProtocol(address,uint128,uint128)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint128",name:"amount0Requested",type:"uint128"},{internalType:"uint128",name:"amount1Requested",type:"uint128"}],name:"collectProtocol",outputs:[{internalType:"uint128",name:"amount0",type:"uint128"},{internalType:"uint128",name:"amount1",type:"uint128"}],stateMutability:"nonpayable",type:"function",params:{amount0Requested:"The maximum amount of token0 to send, can be 0 to collect fees in only token1",amount1Requested:"The maximum amount of token1 to send, can be 0 to collect fees in only token0",recipient:"The address to which collected protocol fees should be sent"},returns:{amount0:"The protocol fee collected in token0",amount1:"The protocol fee collected in token1"},notice:"Collect the protocol fee accrued to the pool"},"setFeeProtocol(uint8,uint8)":{inputs:[{internalType:"uint8",name:"feeProtocol0",type:"uint8"},{internalType:"uint8",name:"feeProtocol1",type:"uint8"}],name:"setFeeProtocol",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeProtocol0:"new protocol fee for token0 of the pool",feeProtocol1:"new protocol fee for token1 of the pool"},notice:"Set the denominator of the protocol's % share of the fees"}}},"contracts/mocks/uniswapV3/core/interfaces/pool/IUniswapV3PoolState.sol:IUniswapV3PoolState":{source:"contracts/mocks/uniswapV3/core/interfaces/pool/IUniswapV3PoolState.sol",name:"IUniswapV3PoolState",title:"Pool state that can change",notice:"These methods compose the pool's state, and can change with any frequency including multiple times per transaction",methods:{"feeGrowthGlobal0X128()":{inputs:[],name:"feeGrowthGlobal0X128",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"This value can overflow the uint256",notice:"The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool"},"feeGrowthGlobal1X128()":{inputs:[],name:"feeGrowthGlobal1X128",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"This value can overflow the uint256",notice:"The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool"},"liquidity()":{inputs:[],name:"liquidity",outputs:[{internalType:"uint128",name:"",type:"uint128"}],stateMutability:"view",type:"function",details:"This value has no relationship to the total liquidity across all ticks",notice:"The currently in range liquidity available to the pool"},"observations(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"observations",outputs:[{internalType:"uint32",name:"blockTimestamp",type:"uint32"},{internalType:"int56",name:"tickCumulative",type:"int56"},{internalType:"uint160",name:"secondsPerLiquidityCumulativeX128",type:"uint160"},{internalType:"bool",name:"initialized",type:"bool"}],stateMutability:"view",type:"function",details:"You most likely want to use #observe() instead of this method to get an observation as of some amount of time ago, rather than at a specific index in the array.",params:{index:"The element of the observations array to fetch"},returns:{blockTimestamp:"The timestamp of the observation, Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp, Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp, Returns initialized whether the observation has been initialized and the values are safe to use"},notice:"Returns data about a specific observation index"},"positions(bytes32)":{inputs:[{internalType:"bytes32",name:"key",type:"bytes32"}],name:"positions",outputs:[{internalType:"uint128",name:"_liquidity",type:"uint128"},{internalType:"uint256",name:"feeGrowthInside0LastX128",type:"uint256"},{internalType:"uint256",name:"feeGrowthInside1LastX128",type:"uint256"},{internalType:"uint128",name:"tokensOwed0",type:"uint128"},{internalType:"uint128",name:"tokensOwed1",type:"uint128"}],stateMutability:"view",type:"function",params:{key:"The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper"},returns:{_liquidity:"The amount of liquidity in the position, Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke, Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke, Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke, Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke"},notice:"Returns the information about a position by the position's key"},"protocolFees()":{inputs:[],name:"protocolFees",outputs:[{internalType:"uint128",name:"token0",type:"uint128"},{internalType:"uint128",name:"token1",type:"uint128"}],stateMutability:"view",type:"function",details:"Protocol fees will never exceed uint128 max in either token",notice:"The amounts of token0 and token1 that are owed to the protocol"},"slot0()":{inputs:[],name:"slot0",outputs:[{internalType:"uint160",name:"sqrtPriceX96",type:"uint160"},{internalType:"int24",name:"tick",type:"int24"},{internalType:"uint16",name:"observationIndex",type:"uint16"},{internalType:"uint16",name:"observationCardinality",type:"uint16"},{internalType:"uint16",name:"observationCardinalityNext",type:"uint16"},{internalType:"uint8",name:"feeProtocol",type:"uint8"},{internalType:"bool",name:"unlocked",type:"bool"}],stateMutability:"view",type:"function",returns:{sqrtPriceX96:"The current price of the pool as a sqrt(token1/token0) Q64.96 value tick The current tick of the pool, i.e. according to the last tick transition that was run. This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick boundary. observationIndex The index of the last oracle observation that was written, observationCardinality The current maximum number of observations stored in the pool, observationCardinalityNext The next maximum number of observations, to be updated when the observation. feeProtocol The protocol fee for both tokens of the pool. Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0 is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee. unlocked Whether the pool is currently locked to reentrancy"},notice:"The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas when accessed externally."},"tickBitmap(int16)":{inputs:[{internalType:"int16",name:"wordPosition",type:"int16"}],name:"tickBitmap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"Returns 256 packed tick initialized boolean values. See TickBitmap for more information"},"ticks(int24)":{inputs:[{internalType:"int24",name:"tick",type:"int24"}],name:"ticks",outputs:[{internalType:"uint128",name:"liquidityGross",type:"uint128"},{internalType:"int128",name:"liquidityNet",type:"int128"},{internalType:"uint256",name:"feeGrowthOutside0X128",type:"uint256"},{internalType:"uint256",name:"feeGrowthOutside1X128",type:"uint256"},{internalType:"int56",name:"tickCumulativeOutside",type:"int56"},{internalType:"uint160",name:"secondsPerLiquidityOutsideX128",type:"uint160"},{internalType:"uint32",name:"secondsOutside",type:"uint32"},{internalType:"bool",name:"initialized",type:"bool"}],stateMutability:"view",type:"function",params:{tick:"The tick to look up"},returns:{liquidityGross:"the total amount of position liquidity that uses the pool either as tick lower or tick upper, liquidityNet how much liquidity changes when the pool price crosses the tick, feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0, feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1, tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick, secondsOutside the seconds spent on the other side of the tick from the current tick, initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false. Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0. In addition, these values are only relative and must be used only in comparison to previous snapshots for a specific position."},notice:"Look up information about a specific tick in the pool"}}},"contracts/mocks/uniswapV3/core/libraries/BitMath.sol:BitMath":{source:"contracts/mocks/uniswapV3/core/libraries/BitMath.sol",name:"BitMath",title:"BitMath",details:"This library provides functionality for computing bit properties of an unsigned integer"},"contracts/mocks/uniswapV3/core/libraries/FixedPoint128.sol:FixedPoint128":{source:"contracts/mocks/uniswapV3/core/libraries/FixedPoint128.sol",name:"FixedPoint128",title:"FixedPoint128",notice:"A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)"},"contracts/mocks/uniswapV3/core/libraries/FixedPoint96.sol:FixedPoint96":{source:"contracts/mocks/uniswapV3/core/libraries/FixedPoint96.sol",name:"FixedPoint96",title:"FixedPoint96",details:"Used in SqrtPriceMath.sol",notice:"A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)"},"contracts/mocks/uniswapV3/core/libraries/FullMath.sol:FullMath":{source:"contracts/mocks/uniswapV3/core/libraries/FullMath.sol",name:"FullMath",title:"Contains 512-bit math functions",details:'Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits',notice:"Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision"},"contracts/mocks/uniswapV3/core/libraries/LiquidityMath.sol:LiquidityMath":{source:"contracts/mocks/uniswapV3/core/libraries/LiquidityMath.sol",name:"LiquidityMath",title:"Math library for liquidity"},"contracts/mocks/uniswapV3/core/libraries/LowGasSafeMath.sol:LowGasSafeMath":{source:"contracts/mocks/uniswapV3/core/libraries/LowGasSafeMath.sol",name:"LowGasSafeMath",title:"Optimized overflow and underflow safe math operations",notice:"Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost"},"contracts/mocks/uniswapV3/core/libraries/Oracle.sol:Oracle":{source:"contracts/mocks/uniswapV3/core/libraries/Oracle.sol",name:"Oracle",title:"Oracle",details:'Instances of stored oracle data, "observations", are collected in the oracle array Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the maximum length of the oracle array. New slots will be added when the array is fully populated. Observations are overwritten when the full length of the oracle array is populated. The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()',notice:"Provides price and liquidity data useful for a wide variety of system designs"},"contracts/mocks/uniswapV3/core/libraries/Position.sol:Position":{source:"contracts/mocks/uniswapV3/core/libraries/Position.sol",name:"Position",title:"Position",details:"Positions store additional state for tracking fees owed to the position",notice:"Positions represent an owner address' liquidity between a lower and upper tick boundary"},"contracts/mocks/uniswapV3/core/libraries/SafeCast.sol:SafeCast":{source:"contracts/mocks/uniswapV3/core/libraries/SafeCast.sol",name:"SafeCast",title:"Safe casting methods",notice:"Contains methods for safely casting between types"},"contracts/mocks/uniswapV3/core/libraries/SqrtPriceMath.sol:SqrtPriceMath":{source:"contracts/mocks/uniswapV3/core/libraries/SqrtPriceMath.sol",name:"SqrtPriceMath",title:"Functions based on Q64.96 sqrt price and liquidity",notice:"Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas"},"contracts/mocks/uniswapV3/core/libraries/SwapMath.sol:SwapMath":{source:"contracts/mocks/uniswapV3/core/libraries/SwapMath.sol",name:"SwapMath",title:"Computes the result of a swap within ticks",notice:"Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick."},"contracts/mocks/uniswapV3/core/libraries/Tick.sol:Tick":{source:"contracts/mocks/uniswapV3/core/libraries/Tick.sol",name:"Tick",title:"Tick",notice:"Contains functions for managing tick processes and relevant calculations"},"contracts/mocks/uniswapV3/core/libraries/TickBitmap.sol:TickBitmap":{source:"contracts/mocks/uniswapV3/core/libraries/TickBitmap.sol",name:"TickBitmap",title:"Packed tick initialized state library",details:"The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.",notice:"Stores a packed mapping of tick index to its initialized state"},"contracts/mocks/uniswapV3/core/libraries/TickMath.sol:TickMath":{source:"contracts/mocks/uniswapV3/core/libraries/TickMath.sol",name:"TickMath",title:"Math library for computing sqrt prices from ticks and vice versa",notice:"Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports prices between 2**-128 and 2**128"},"contracts/mocks/uniswapV3/core/libraries/TransferHelper.sol:TransferHelper":{source:"contracts/mocks/uniswapV3/core/libraries/TransferHelper.sol",name:"TransferHelper",title:"TransferHelper",notice:"Contains helper methods for interacting with ERC20 tokens that do not consistently return true/false"},"contracts/mocks/uniswapV3/core/libraries/UnsafeMath.sol:UnsafeMath":{source:"contracts/mocks/uniswapV3/core/libraries/UnsafeMath.sol",name:"UnsafeMath",title:"Math functions that do not check inputs or outputs",notice:"Contains methods that perform common math functions but do not do any overflow or underflow checks"},"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/cryptography/ECDSA.sol:ECDSA":{source:"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/cryptography/ECDSA.sol",name:"ECDSA",details:"Elliptic Curve Digital Signature Algorithm (ECDSA) operations. These functions can be used to verify that a message was signed by the holder of the private keys of a given address."},"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/drafts/EIP712.sol:EIP712":{source:"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/drafts/EIP712.sol",name:"EIP712",details:'https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data. The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible, thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in their contracts using a combination of `abi.encode` and `keccak256`. This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA ({_hashTypedDataV4}). The implementation of the domain separator was designed to be as efficient as possible while still properly updating the chain id to protect against replay attacks on an eventual fork of the chain. NOTE: This contract implements the version of the encoding known as "v4", as implemented by the JSON RPC method https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask]. _Available since v3.4._'},"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/drafts/ERC20Permit.sol:ERC20Permit":{source:"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/drafts/ERC20Permit.sol",name:"ERC20Permit",details:"Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in https://eips.ethereum.org/EIPS/eip-2612[EIP-2612]. Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't need to send a transaction, and thus is not required to hold Ether at all. _Available since v3.4._",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"DOMAIN_SEPARATOR()":{inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"See {IERC20Permit-DOMAIN_SEPARATOR}."},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is called. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"nonces(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"nonces",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20Permit-nonces}."},"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC20Permit-permit}."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."}}},"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/drafts/IERC20Permit.sol:IERC20Permit":{source:"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/drafts/IERC20Permit.sol",name:"IERC20Permit",details:"Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in https://eips.ethereum.org/EIPS/eip-2612[EIP-2612]. Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't need to send a transaction, and thus is not required to hold Ether at all.",methods:{"DOMAIN_SEPARATOR()":{inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}."},"nonces(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"nonces",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the current nonce for `owner`. This value must be included whenever a signature is generated for {permit}. Every successful call to {permit} increases ``owner``'s nonce by one. This prevents a signature from being used multiple times."},"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"nonpayable",type:"function",details:"Sets `value` as the allowance of `spender` over `owner`'s tokens, given `owner`'s signed approval. IMPORTANT: The same issues {IERC20-approve} has related to transaction ordering also apply here. Emits an {Approval} event. Requirements: - `spender` cannot be the zero address. - `deadline` must be a timestamp in the future. - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner` over the EIP712-formatted function arguments. - the signature must use ``owner``'s current nonce (see {nonces}). For more information on the signature format, see the https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP section]."}}},"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/introspection/ERC165.sol:ERC165":{source:"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/introspection/ERC165.sol",name:"ERC165",details:"Implementation of the {IERC165} interface. Contracts may inherit from this and call {_registerInterface} to declare their support of an interface.",methods:{"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}. Time complexity O(1), guaranteed to always use less than 30 000 gas."}}},"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/introspection/IERC165.sol:IERC165":{source:"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/introspection/IERC165.sol",name:"IERC165",details:"Interface of the ERC165 standard, as defined in the https://eips.ethereum.org/EIPS/eip-165[EIP]. Implementers can declare support of contract interfaces, which can then be queried by others ({ERC165Checker}). For an implementation, see {ERC165}.",methods:{"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."}}},"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/math/Math.sol:Math":{source:"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/math/Math.sol",name:"Math",details:"Standard math utilities missing in the Solidity language."},"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/math/SafeMath.sol:SafeMath":{source:"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/math/SafeMath.sol",name:"SafeMath",details:"Wrappers over Solidity's arithmetic operations with added overflow checks. Arithmetic operations in Solidity wrap on overflow. This can easily result in bugs, because programmers usually assume that an overflow raises an error, which is the standard behavior in high level programming languages. `SafeMath` restores this intuition by reverting the transaction when an operation overflows. Using this library instead of the unchecked operations eliminates an entire class of bugs, so it's recommended to use it always."},"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/math/SignedSafeMath.sol:SignedSafeMath":{source:"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/math/SignedSafeMath.sol",name:"SignedSafeMath",title:"SignedSafeMath",details:"Signed math operations with safety checks that revert on error."},"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20":{source:"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/token/ERC20/ERC20.sol",name:"ERC20",details:"Implementation of the {IERC20} interface. This implementation is agnostic to the way tokens are created. This means that a supply mechanism has to be added in a derived contract using {_mint}. For a generic mechanism see {ERC20PresetMinterPauser}. TIP: For a detailed writeup see our guide https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How to implement supply mechanisms]. We have followed general OpenZeppelin guidelines: functions revert instead of returning `false` on failure. This behavior is nonetheless conventional and does not conflict with the expectations of ERC20 applications. Additionally, an {Approval} event is emitted on calls to {transferFrom}. This allows applications to reconstruct the allowance for all accounts just by listening to said events. Other implementations of the EIP may not emit these events, as it isn't required by the specification. Finally, the non-standard {decreaseAllowance} and {increaseAllowance} functions have been added to mitigate the well-known issues around setting allowances. See {IERC20-approve}.",constructor:{inputs:[{internalType:"string",name:"name_",type:"string"},{internalType:"string",name:"symbol_",type:"string"}],stateMutability:"nonpayable",type:"constructor"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is called. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."}}},"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/token/ERC20/IERC20.sol:IERC20":{source:"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/token/ERC20/IERC20.sol",name:"IERC20",details:"Interface of the ERC20 standard as defined in the EIP.",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}}},"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/token/ERC721/ERC721.sol:ERC721":{source:"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/token/ERC721/ERC721.sol",name:"ERC721",title:"ERC721 Non-Fungible Token Standard basic implementation",details:"see https://eips.ethereum.org/EIPS/eip-721",constructor:{inputs:[{internalType:"string",name:"name_",type:"string"},{internalType:"string",name:"symbol_",type:"string"}],stateMutability:"nonpayable",type:"constructor"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Approval",type:"event"},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"approve(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-approve}."},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC721-balanceOf}."},"baseURI()":{inputs:[],name:"baseURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the base URI set via {_setBaseURI}. This will be automatically added as a prefix in {tokenURI} to each token's URI, or to the token ID if no specific URI is set for that token ID."},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"See {IERC721-getApproved}."},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC721-isApprovedForAll}."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"See {IERC721Metadata-name}."},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"See {IERC721-ownerOf}."},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-safeTransferFrom}."},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-safeTransferFrom}."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-setApprovalForAll}."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}. Time complexity O(1), guaranteed to always use less than 30 000 gas."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"See {IERC721Metadata-symbol}."},"tokenByIndex(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"tokenByIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC721Enumerable-tokenByIndex}."},"tokenOfOwnerByIndex(address,uint256)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"uint256",name:"index",type:"uint256"}],name:"tokenOfOwnerByIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC721Enumerable-tokenOfOwnerByIndex}."},"tokenURI(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"See {IERC721Metadata-tokenURI}."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC721Enumerable-totalSupply}."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-transferFrom}."}}},"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/token/ERC721/IERC721.sol:IERC721":{source:"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/token/ERC721/IERC721.sol",name:"IERC721",details:"Required interface of an ERC721 compliant contract.",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when `owner` enables `approved` to manage the `tokenId` token."},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event",details:"Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets."},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `tokenId` token is transferred from `from` to `to`."}},methods:{"approve(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"Gives permission to `to` to transfer `tokenId` token to another account. The approval is cleared when the token is transferred. Only a single account can be approved at a time, so approving the zero address clears previous approvals. Requirements: - The caller must own the token or be an approved operator. - `tokenId` must exist. Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"balance",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of tokens in ``owner``'s account."},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"operator",type:"address"}],stateMutability:"view",type:"function",details:"Returns the account approved for `tokenId` token. Requirements: - `tokenId` must exist."},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns if the `operator` is allowed to manage all of the assets of `owner`. See {setApprovalForAll}"},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"owner",type:"address"}],stateMutability:"view",type:"function",details:"Returns the owner of the `tokenId` token. Requirements: - `tokenId` must exist."},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"_approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"Approve or remove `operator` as an operator for the caller. Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller. Requirements: - The `operator` cannot be the caller. Emits an {ApprovalForAll} event."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers `tokenId` token from `from` to `to`. WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. Emits a {Transfer} event."}}},"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol:IERC721Enumerable":{source:"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol",name:"IERC721Enumerable",title:"ERC-721 Non-Fungible Token Standard, optional enumeration extension",details:"See https://eips.ethereum.org/EIPS/eip-721",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Approval",type:"event"},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"approve(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"Gives permission to `to` to transfer `tokenId` token to another account. The approval is cleared when the token is transferred. Only a single account can be approved at a time, so approving the zero address clears previous approvals. Requirements: - The caller must own the token or be an approved operator. - `tokenId` must exist. Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"balance",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of tokens in ``owner``'s account."},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"operator",type:"address"}],stateMutability:"view",type:"function",details:"Returns the account approved for `tokenId` token. Requirements: - `tokenId` must exist."},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns if the `operator` is allowed to manage all of the assets of `owner`. See {setApprovalForAll}"},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"owner",type:"address"}],stateMutability:"view",type:"function",details:"Returns the owner of the `tokenId` token. Requirements: - `tokenId` must exist."},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"_approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"Approve or remove `operator` as an operator for the caller. Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller. Requirements: - The `operator` cannot be the caller. Emits an {ApprovalForAll} event."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."},"tokenByIndex(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"tokenByIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns a token ID at a given `index` of all the tokens stored by the contract. Use along with {totalSupply} to enumerate all tokens."},"tokenOfOwnerByIndex(address,uint256)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"uint256",name:"index",type:"uint256"}],name:"tokenOfOwnerByIndex",outputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns a token ID owned by `owner` at a given `index` of its token list. Use along with {balanceOf} to enumerate all of ``owner``'s tokens."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the total amount of tokens stored by the contract."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers `tokenId` token from `from` to `to`. WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. Emits a {Transfer} event."}}},"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/token/ERC721/IERC721Metadata.sol:IERC721Metadata":{source:"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/token/ERC721/IERC721Metadata.sol",name:"IERC721Metadata",title:"ERC-721 Non-Fungible Token Standard, optional metadata extension",details:"See https://eips.ethereum.org/EIPS/eip-721",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Approval",type:"event"},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"approve(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"Gives permission to `to` to transfer `tokenId` token to another account. The approval is cleared when the token is transferred. Only a single account can be approved at a time, so approving the zero address clears previous approvals. Requirements: - The caller must own the token or be an approved operator. - `tokenId` must exist. Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"balance",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of tokens in ``owner``'s account."},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"operator",type:"address"}],stateMutability:"view",type:"function",details:"Returns the account approved for `tokenId` token. Requirements: - `tokenId` must exist."},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns if the `operator` is allowed to manage all of the assets of `owner`. See {setApprovalForAll}"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the token collection name."},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"owner",type:"address"}],stateMutability:"view",type:"function",details:"Returns the owner of the `tokenId` token. Requirements: - `tokenId` must exist."},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"_approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"Approve or remove `operator` as an operator for the caller. Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller. Requirements: - The `operator` cannot be the caller. Emits an {ApprovalForAll} event."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the token collection symbol."},"tokenURI(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the Uniform Resource Identifier (URI) for `tokenId` token."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers `tokenId` token from `from` to `to`. WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. Emits a {Transfer} event."}}},"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/token/ERC721/IERC721Receiver.sol:IERC721Receiver":{source:"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/token/ERC721/IERC721Receiver.sol",name:"IERC721Receiver",title:"ERC721 token receiver interface",details:"Interface for any contract that wants to support safeTransfers from ERC721 asset contracts.",methods:{"onERC721Received(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"from",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"onERC721Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom} by `operator` from `from`, this function is called. It must return its Solidity selector to confirm the token transfer. If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted. The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`."}}},"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/utils/Address.sol:Address":{source:"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/utils/Address.sol",name:"Address",details:"Collection of functions related to the address type"},"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/utils/Context.sol:Context":{source:"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/utils/Context.sol",name:"Context"},"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/utils/Counters.sol:Counters":{source:"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/utils/Counters.sol",name:"Counters",title:"Counters",author:"Matt Condon (@shrugs)",details:"Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number of elements in a mapping, issuing ERC721 ids, or counting request ids. Include with `using Counters for Counters.Counter;` Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath} overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never directly accessed."},"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/utils/EnumerableMap.sol:EnumerableMap":{source:"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/utils/EnumerableMap.sol",name:"EnumerableMap",details:"Library for managing an enumerable variant of Solidity's https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`] type. Maps have the following properties: - Entries are added, removed, and checked for existence in constant time (O(1)). - Entries are enumerated in O(n). No guarantees are made on the ordering. ``` contract Example {     // Add the library methods     using EnumerableMap for EnumerableMap.UintToAddressMap;     // Declare a set state variable     EnumerableMap.UintToAddressMap private myMap; } ``` As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are supported."},"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/utils/EnumerableSet.sol:EnumerableSet":{source:"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/utils/EnumerableSet.sol",name:"EnumerableSet",details:"Library for managing https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive types. Sets have the following properties: - Elements are added, removed, and checked for existence in constant time (O(1)). - Elements are enumerated in O(n). No guarantees are made on the ordering. ``` contract Example {     // Add the library methods     using EnumerableSet for EnumerableSet.AddressSet;     // Declare a set state variable     EnumerableSet.AddressSet private mySet; } ``` As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`) and `uint256` (`UintSet`) are supported."},"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/utils/Strings.sol:Strings":{source:"contracts/mocks/uniswapV3/dependencies/openzeppelin/contracts/utils/Strings.sol",name:"Strings",details:"String operations."},"contracts/mocks/uniswapV3/dependencies/uniswap/lib/contracts/libraries/AddressStringUtil.sol:AddressStringUtil":{source:"contracts/mocks/uniswapV3/dependencies/uniswap/lib/contracts/libraries/AddressStringUtil.sol",name:"AddressStringUtil"},"contracts/mocks/uniswapV3/dependencies/uniswap/lib/contracts/libraries/Babylonian.sol:Babylonian":{source:"contracts/mocks/uniswapV3/dependencies/uniswap/lib/contracts/libraries/Babylonian.sol",name:"Babylonian"},"contracts/mocks/uniswapV3/dependencies/uniswap/lib/contracts/libraries/BitMath.sol:BitMath":{source:"contracts/mocks/uniswapV3/dependencies/uniswap/lib/contracts/libraries/BitMath.sol",name:"BitMath"},"contracts/mocks/uniswapV3/dependencies/uniswap/lib/contracts/libraries/FixedPoint.sol:FixedPoint":{source:"contracts/mocks/uniswapV3/dependencies/uniswap/lib/contracts/libraries/FixedPoint.sol",name:"FixedPoint",methods:{"Q112()":{inputs:[],name:"Q112",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"RESOLUTION()":{inputs:[],name:"RESOLUTION",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"}}},"contracts/mocks/uniswapV3/dependencies/uniswap/lib/contracts/libraries/FullMath.sol:FullMath":{source:"contracts/mocks/uniswapV3/dependencies/uniswap/lib/contracts/libraries/FullMath.sol",name:"FullMath"},"contracts/mocks/uniswapV3/dependencies/uniswap/lib/contracts/libraries/SafeERC20Namer.sol:SafeERC20Namer":{source:"contracts/mocks/uniswapV3/dependencies/uniswap/lib/contracts/libraries/SafeERC20Namer.sol",name:"SafeERC20Namer"},"contracts/mocks/uniswapV3/dependencies/uniswap/lib/contracts/libraries/TransferHelper.sol:TransferHelper":{source:"contracts/mocks/uniswapV3/dependencies/uniswap/lib/contracts/libraries/TransferHelper.sol",name:"TransferHelper"},"contracts/mocks/uniswapV3/periphery/NonfungiblePositionManager.sol:NonfungiblePositionManager":{source:"contracts/mocks/uniswapV3/periphery/NonfungiblePositionManager.sol",name:"NonfungiblePositionManager",title:"NFT positions",notice:"Wraps Uniswap V3 positions in the ERC721 non-fungible token interface",constructor:{inputs:[{internalType:"address",name:"_factory",type:"address"},{internalType:"address",name:"_WETH9",type:"address"},{internalType:"address",name:"_tokenDescriptor_",type:"address"}],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Approval",type:"event"},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event"},"Collect(uint256,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"},{indexed:!1,internalType:"address",name:"recipient",type:"address"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"Collect",type:"event",notice:"Emitted when tokens are collected for a position NFT"},"DecreaseLiquidity(uint256,uint128,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"},{indexed:!1,internalType:"uint128",name:"liquidity",type:"uint128"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"DecreaseLiquidity",type:"event",notice:"Emitted when liquidity is decreased for a position NFT"},"IncreaseLiquidity(uint256,uint128,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"},{indexed:!1,internalType:"uint128",name:"liquidity",type:"uint128"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"IncreaseLiquidity",type:"event",notice:"Emitted when liquidity is increased for a position NFT"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"DOMAIN_SEPARATOR()":{inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",returns:{_0:"The domain seperator used in encoding of permit signature"},notice:"The domain separator used in the permit signature"},"PERMIT_TYPEHASH()":{inputs:[],name:"PERMIT_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"The permit typehash used in the permit signature"},"WETH9()":{inputs:[],name:"WETH9",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-approve}."},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC721-balanceOf}."},"baseURI()":{inputs:[],name:"baseURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function",details:"Returns the base URI set via {_setBaseURI}. This will be automatically added as a prefix in {tokenURI} to each token's URI, or to the token ID if no specific URI is set for that token ID."},"burn(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"burn",outputs:[],stateMutability:"payable",type:"function",params:{tokenId:"The ID of the token that is being burned"},notice:"Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens must be collected first."},"collect((uint256,address,uint128,uint128))":{inputs:[{components:[{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint128",name:"amount0Max",type:"uint128"},{internalType:"uint128",name:"amount1Max",type:"uint128"}],internalType:"struct INonfungiblePositionManager.CollectParams",name:"params",type:"tuple"}],name:"collect",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"tokenId The ID of the NFT for which tokens are being collected, recipient The account that should receive the tokens, amount0Max The maximum amount of token0 to collect, amount1Max The maximum amount of token1 to collect"},returns:{amount0:"The amount of fees collected in token0",amount1:"The amount of fees collected in token1"},notice:"Collects up to a maximum amount of fees owed to a specific position to the recipient"},"createAndInitializePoolIfNecessary(address,address,uint24,uint160)":{inputs:[{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"uint160",name:"sqrtPriceX96",type:"uint160"}],name:"createAndInitializePoolIfNecessary",outputs:[{internalType:"address",name:"pool",type:"address"}],stateMutability:"payable",type:"function",details:"This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool",params:{fee:"The fee amount of the v3 pool for the specified token pair",sqrtPriceX96:"The initial square root price of the pool as a Q64.96 value",token0:"The contract address of token0 of the pool",token1:"The contract address of token1 of the pool"},returns:{pool:"Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary"},notice:"Creates a new pool if it does not exist, then initializes if not initialized"},"decreaseLiquidity((uint256,uint128,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"uint128",name:"liquidity",type:"uint128"},{internalType:"uint256",name:"amount0Min",type:"uint256"},{internalType:"uint256",name:"amount1Min",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],internalType:"struct INonfungiblePositionManager.DecreaseLiquidityParams",name:"params",type:"tuple"}],name:"decreaseLiquidity",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"tokenId The ID of the token for which liquidity is being decreased, amount The amount by which liquidity will be decreased, amount0Min The minimum amount of token0 that should be accounted for the burned liquidity, amount1Min The minimum amount of token1 that should be accounted for the burned liquidity, deadline The time by which the transaction must be included to effect the change"},returns:{amount0:"The amount of token0 accounted to the position's tokens owed",amount1:"The amount of token1 accounted to the position's tokens owed"},notice:"Decreases the amount of liquidity in a position and accounts it to the position"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the account approved for `tokenId` token. Requirements: - `tokenId` must exist."},"increaseLiquidity((uint256,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"uint256",name:"amount0Desired",type:"uint256"},{internalType:"uint256",name:"amount1Desired",type:"uint256"},{internalType:"uint256",name:"amount0Min",type:"uint256"},{internalType:"uint256",name:"amount1Min",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],internalType:"struct INonfungiblePositionManager.IncreaseLiquidityParams",name:"params",type:"tuple"}],name:"increaseLiquidity",outputs:[{internalType:"uint128",name:"liquidity",type:"uint128"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"tokenId The ID of the token for which liquidity is being increased, amount0Desired The desired amount of token0 to be spent, amount1Desired The desired amount of token1 to be spent, amount0Min The minimum amount of token0 to spend, which serves as a slippage check, amount1Min The minimum amount of token1 to spend, which serves as a slippage check, deadline The time by which the transaction must be included to effect the change"},returns:{amount0:"The amount of token0 to acheive resulting liquidity",amount1:"The amount of token1 to acheive resulting liquidity",liquidity:"The new liquidity amount as a result of the increase"},notice:"Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`"},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC721-isApprovedForAll}."},"mint((address,address,uint24,int24,int24,uint256,uint256,uint256,uint256,address,uint256))":{inputs:[{components:[{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint256",name:"amount0Desired",type:"uint256"},{internalType:"uint256",name:"amount1Desired",type:"uint256"},{internalType:"uint256",name:"amount0Min",type:"uint256"},{internalType:"uint256",name:"amount1Min",type:"uint256"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],internalType:"struct INonfungiblePositionManager.MintParams",name:"params",type:"tuple"}],name:"mint",outputs:[{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"uint128",name:"liquidity",type:"uint128"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"payable",type:"function",details:"Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized a method does not exist, i.e. the pool is assumed to be initialized.",params:{params:"The params necessary to mint a position, encoded as `MintParams` in calldata"},returns:{amount0:"The amount of token0",amount1:"The amount of token1",liquidity:"The amount of liquidity for this position",tokenId:"The ID of the token that represents the minted position"},notice:"Creates a new position wrapped in a NFT"},"multicall(bytes[])":{inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"multicall",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"payable",type:"function",details:"The `msg.value` should not be trusted for any method callable from multicall.",params:{data:"The encoded function data for each of the calls to make to this contract"},returns:{results:"The results from each of the calls passed in via data"},notice:"Call multiple functions in the current contract and return the data from all of them if they all succeed"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"See {IERC721Metadata-name}."},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"See {IERC721-ownerOf}."},"permit(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"payable",type:"function",params:{deadline:"The deadline timestamp by which the call must be mined for the approve to work",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",spender:"The account that is being approved",tokenId:"The ID of the token that is being approved for spending",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Approve of a specific token ID for spending by spender via signature"},"positions(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"positions",outputs:[{internalType:"uint96",name:"nonce",type:"uint96"},{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint128",name:"liquidity",type:"uint128"},{internalType:"uint256",name:"feeGrowthInside0LastX128",type:"uint256"},{internalType:"uint256",name:"feeGrowthInside1LastX128",type:"uint256"},{internalType:"uint128",name:"tokensOwed0",type:"uint128"},{internalType:"uint128",name:"tokensOwed1",type:"uint128"}],stateMutability:"view",type:"function",details:"Throws if the token ID is not valid.",params:{tokenId:"The ID of the token that represents the position"},returns:{fee:"The fee associated with the pool",feeGrowthInside0LastX128:"The fee growth of token0 as of the last action on the individual position",feeGrowthInside1LastX128:"The fee growth of token1 as of the last action on the individual position",liquidity:"The liquidity of the position",nonce:"The nonce for permits",operator:"The address that is approved for spending",tickLower:"The lower end of the tick range for the position",tickUpper:"The higher end of the tick range for the position",token0:"The address of the token0 for a specific pool",token1:"The address of the token1 for a specific pool",tokensOwed0:"The uncollected amount of token0 owed to the position as of the last computation",tokensOwed1:"The uncollected amount of token1 owed to the position as of the last computation"},notice:"Returns the position information associated with a given token ID."},"refundETH()":{inputs:[],name:"refundETH",outputs:[],stateMutability:"payable",type:"function",details:"Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps that use ether for the input amount",notice:"Refunds any ETH balance held by this contract to the `msg.sender`"},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-safeTransferFrom}."},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-safeTransferFrom}."},"selfPermit(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermit",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this).",params:{deadline:"A timestamp, the current blocktime must be less than or equal to this timestamp",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`",value:"The amount that can be spent of token"},notice:"Permits this contract to spend a given token from `msg.sender`"},"selfPermitAllowed(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitAllowed",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this)",params:{expiry:"The timestamp at which the permit is no longer valid",nonce:"The current nonce of the owner",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter"},"selfPermitAllowedIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitAllowedIfNecessary",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this) Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.",params:{expiry:"The timestamp at which the permit is no longer valid",nonce:"The current nonce of the owner",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter"},"selfPermitIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitIfNecessary",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this). Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit",params:{deadline:"A timestamp, the current blocktime must be less than or equal to this timestamp",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`",value:"The amount that can be spent of token"},notice:"Permits this contract to spend a given token from `msg.sender`"},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-setApprovalForAll}."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}. Time complexity O(1), guaranteed to always use less than 30 000 gas."},"sweepToken(address,uint256,address)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"sweepToken",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing the token from users",params:{amountMinimum:"The minimum amount of token required for a transfer",recipient:"The destination address of the token",token:"The contract address of the token which will be transferred to `recipient`"},notice:"Transfers the full amount of a token held by this contract to recipient"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"See {IERC721Metadata-symbol}."},"tokenByIndex(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"tokenByIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC721Enumerable-tokenByIndex}."},"tokenOfOwnerByIndex(address,uint256)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"uint256",name:"index",type:"uint256"}],name:"tokenOfOwnerByIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC721Enumerable-tokenOfOwnerByIndex}."},"tokenURI(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC721Enumerable-totalSupply}."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-transferFrom}."},"uniswapV3MintCallback(uint256,uint256,bytes)":{inputs:[{internalType:"uint256",name:"amount0Owed",type:"uint256"},{internalType:"uint256",name:"amount1Owed",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"uniswapV3MintCallback",outputs:[],stateMutability:"nonpayable",type:"function",details:"In the implementation you must pay the pool tokens owed for the minted liquidity. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.",params:{amount0Owed:"The amount of token0 due to the pool for the minted liquidity",amount1Owed:"The amount of token1 due to the pool for the minted liquidity",data:"Any data passed through by the caller via the IUniswapV3PoolActions#mint call"},notice:"Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint."},"unwrapWETH9(uint256,address)":{inputs:[{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"unwrapWETH9",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",params:{amountMinimum:"The minimum amount of WETH9 to unwrap",recipient:"The address receiving ETH"},notice:"Unwraps the contract's WETH9 balance and sends it to recipient as ETH."}}},"contracts/mocks/uniswapV3/periphery/NonfungibleTokenPositionDescriptor.sol:NonfungibleTokenPositionDescriptor":{source:"contracts/mocks/uniswapV3/periphery/NonfungibleTokenPositionDescriptor.sol",name:"NonfungibleTokenPositionDescriptor",title:"Describes NFT token positions",notice:"Produces a string containing the data URI for a JSON metadata string",constructor:{inputs:[{internalType:"address",name:"_WETH9",type:"address"},{internalType:"bytes32",name:"_nativeCurrencyLabelBytes",type:"bytes32"}],stateMutability:"nonpayable",type:"constructor"},stateVariables:{"nativeCurrencyLabelBytes()":{inputs:[],name:"nativeCurrencyLabelBytes",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"stateVariable",details:"A null-terminated string"}},methods:{"WETH9()":{inputs:[],name:"WETH9",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"flipRatio(address,address,uint256)":{inputs:[{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"}],name:"flipRatio",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"nativeCurrencyLabel()":{inputs:[],name:"nativeCurrencyLabel",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",notice:"Returns the native currency label as a string"},"tokenRatioPriority(address,uint256)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"}],name:"tokenRatioPriority",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"tokenURI(address,uint256)":{inputs:[{internalType:"contract INonfungiblePositionManager",name:"positionManager",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Note this URI may be a data: URI with the JSON contents directly inlined",params:{positionManager:"The position manager for which to describe the token",tokenId:"The ID of the token for which to produce a description, which may not be valid"},returns:{_0:"The URI of the ERC721-compliant metadata"},notice:"Produces the URI describing a particular token ID for a position manager"}}},"contracts/mocks/uniswapV3/periphery/SwapRouter.sol:SwapRouter":{source:"contracts/mocks/uniswapV3/periphery/SwapRouter.sol",name:"SwapRouter",title:"Uniswap V3 Swap Router",notice:"Router for stateless execution of swaps against Uniswap V3",constructor:{inputs:[{internalType:"address",name:"_factory",type:"address"},{internalType:"address",name:"_WETH9",type:"address"}],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},methods:{"WETH9()":{inputs:[],name:"WETH9",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"exactInput((bytes,address,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"bytes",name:"path",type:"bytes"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint256",name:"amountOutMinimum",type:"uint256"}],internalType:"struct ISwapRouter.ExactInputParams",name:"params",type:"tuple"}],name:"exactInput",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata"},returns:{amountOut:"The amount of the received token"},notice:"Swaps `amountIn` of one token for as much as possible of another along the specified path"},"exactInputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))":{inputs:[{components:[{internalType:"address",name:"tokenIn",type:"address"},{internalType:"address",name:"tokenOut",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint256",name:"amountOutMinimum",type:"uint256"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"}],internalType:"struct ISwapRouter.ExactInputSingleParams",name:"params",type:"tuple"}],name:"exactInputSingle",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata"},returns:{amountOut:"The amount of the received token"},notice:"Swaps `amountIn` of one token for as much as possible of another token"},"exactOutput((bytes,address,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"bytes",name:"path",type:"bytes"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint256",name:"amountInMaximum",type:"uint256"}],internalType:"struct ISwapRouter.ExactOutputParams",name:"params",type:"tuple"}],name:"exactOutput",outputs:[{internalType:"uint256",name:"amountIn",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata"},returns:{amountIn:"The amount of the input token"},notice:"Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)"},"exactOutputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))":{inputs:[{components:[{internalType:"address",name:"tokenIn",type:"address"},{internalType:"address",name:"tokenOut",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint256",name:"amountInMaximum",type:"uint256"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"}],internalType:"struct ISwapRouter.ExactOutputSingleParams",name:"params",type:"tuple"}],name:"exactOutputSingle",outputs:[{internalType:"uint256",name:"amountIn",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata"},returns:{amountIn:"The amount of the input token"},notice:"Swaps as little as possible of one token for `amountOut` of another token"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"multicall(bytes[])":{inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"multicall",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"payable",type:"function",details:"The `msg.value` should not be trusted for any method callable from multicall.",params:{data:"The encoded function data for each of the calls to make to this contract"},returns:{results:"The results from each of the calls passed in via data"},notice:"Call multiple functions in the current contract and return the data from all of them if they all succeed"},"refundETH()":{inputs:[],name:"refundETH",outputs:[],stateMutability:"payable",type:"function",details:"Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps that use ether for the input amount",notice:"Refunds any ETH balance held by this contract to the `msg.sender`"},"selfPermit(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermit",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this).",params:{deadline:"A timestamp, the current blocktime must be less than or equal to this timestamp",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`",value:"The amount that can be spent of token"},notice:"Permits this contract to spend a given token from `msg.sender`"},"selfPermitAllowed(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitAllowed",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this)",params:{expiry:"The timestamp at which the permit is no longer valid",nonce:"The current nonce of the owner",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter"},"selfPermitAllowedIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitAllowedIfNecessary",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this) Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.",params:{expiry:"The timestamp at which the permit is no longer valid",nonce:"The current nonce of the owner",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter"},"selfPermitIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitIfNecessary",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this). Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit",params:{deadline:"A timestamp, the current blocktime must be less than or equal to this timestamp",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`",value:"The amount that can be spent of token"},notice:"Permits this contract to spend a given token from `msg.sender`"},"sweepToken(address,uint256,address)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"sweepToken",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing the token from users",params:{amountMinimum:"The minimum amount of token required for a transfer",recipient:"The destination address of the token",token:"The contract address of the token which will be transferred to `recipient`"},notice:"Transfers the full amount of a token held by this contract to recipient"},"sweepTokenWithFee(address,uint256,address,uint256,address)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"feeBips",type:"uint256"},{internalType:"address",name:"feeRecipient",type:"address"}],name:"sweepTokenWithFee",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing the token from users",notice:"Transfers the full amount of a token held by this contract to recipient, with a percentage between 0 (exclusive) and 1 (inclusive) going to feeRecipient"},"uniswapV3SwapCallback(int256,int256,bytes)":{inputs:[{internalType:"int256",name:"amount0Delta",type:"int256"},{internalType:"int256",name:"amount1Delta",type:"int256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"uniswapV3SwapCallback",outputs:[],stateMutability:"nonpayable",type:"function",details:"In the implementation you must pay the pool tokens owed for the swap. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. amount0Delta and amount1Delta can both be 0 if no tokens were swapped.",params:{amount0Delta:"The amount of token0 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token0 to the pool.",amount1Delta:"The amount of token1 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token1 to the pool.",data:"Any data passed through by the caller via the IUniswapV3PoolActions#swap call"},notice:"Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap."},"unwrapWETH9(uint256,address)":{inputs:[{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"unwrapWETH9",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",params:{amountMinimum:"The minimum amount of WETH9 to unwrap",recipient:"The address receiving ETH"},notice:"Unwraps the contract's WETH9 balance and sends it to recipient as ETH."},"unwrapWETH9WithFee(uint256,address,uint256,address)":{inputs:[{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"feeBips",type:"uint256"},{internalType:"address",name:"feeRecipient",type:"address"}],name:"unwrapWETH9WithFee",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",notice:"Unwraps the contract's WETH9 balance and sends it to recipient as ETH, with a percentage between 0 (exclusive), and 1 (inclusive) going to feeRecipient"}}},"contracts/mocks/uniswapV3/periphery/base/BlockTimestamp.sol:BlockTimestamp":{source:"contracts/mocks/uniswapV3/periphery/base/BlockTimestamp.sol",name:"BlockTimestamp",title:"Function for getting block timestamp",details:"Base contract that is overridden for tests"},"contracts/mocks/uniswapV3/periphery/base/ERC721Permit.sol:ERC721Permit":{source:"contracts/mocks/uniswapV3/periphery/base/ERC721Permit.sol",name:"ERC721Permit",title:"ERC721 with permit",notice:"Nonfungible tokens that support an approve via signature, i.e. permit",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Approval",type:"event"},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Transfer",type:"event"}},stateVariables:{"PERMIT_TYPEHASH()":{inputs:[],name:"PERMIT_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"stateVariable",details:'Value is equal to keccak256("Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)");',return:"The typehash for the permit",notice:"The permit typehash used in the permit signature"}},methods:{"DOMAIN_SEPARATOR()":{inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",returns:{_0:"The domain seperator used in encoding of permit signature"},notice:"The domain separator used in the permit signature"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-approve}."},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC721-balanceOf}."},"baseURI()":{inputs:[],name:"baseURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the base URI set via {_setBaseURI}. This will be automatically added as a prefix in {tokenURI} to each token's URI, or to the token ID if no specific URI is set for that token ID."},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"See {IERC721-getApproved}."},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC721-isApprovedForAll}."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"See {IERC721Metadata-name}."},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"See {IERC721-ownerOf}."},"permit(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"payable",type:"function",params:{deadline:"The deadline timestamp by which the call must be mined for the approve to work",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",spender:"The account that is being approved",tokenId:"The ID of the token that is being approved for spending",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Approve of a specific token ID for spending by spender via signature"},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-safeTransferFrom}."},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-safeTransferFrom}."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-setApprovalForAll}."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}. Time complexity O(1), guaranteed to always use less than 30 000 gas."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"See {IERC721Metadata-symbol}."},"tokenByIndex(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"tokenByIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC721Enumerable-tokenByIndex}."},"tokenOfOwnerByIndex(address,uint256)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"uint256",name:"index",type:"uint256"}],name:"tokenOfOwnerByIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC721Enumerable-tokenOfOwnerByIndex}."},"tokenURI(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"See {IERC721Metadata-tokenURI}."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC721Enumerable-totalSupply}."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-transferFrom}."}}},"contracts/mocks/uniswapV3/periphery/base/LiquidityManagement.sol:LiquidityManagement":{source:"contracts/mocks/uniswapV3/periphery/base/LiquidityManagement.sol",name:"LiquidityManagement",title:"Liquidity management functions",notice:"Internal functions for safely managing liquidity in Uniswap V3",receive:{stateMutability:"payable",type:"receive"},methods:{"WETH9()":{inputs:[],name:"WETH9",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"refundETH()":{inputs:[],name:"refundETH",outputs:[],stateMutability:"payable",type:"function",details:"Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps that use ether for the input amount",notice:"Refunds any ETH balance held by this contract to the `msg.sender`"},"sweepToken(address,uint256,address)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"sweepToken",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing the token from users",params:{amountMinimum:"The minimum amount of token required for a transfer",recipient:"The destination address of the token",token:"The contract address of the token which will be transferred to `recipient`"},notice:"Transfers the full amount of a token held by this contract to recipient"},"uniswapV3MintCallback(uint256,uint256,bytes)":{inputs:[{internalType:"uint256",name:"amount0Owed",type:"uint256"},{internalType:"uint256",name:"amount1Owed",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"uniswapV3MintCallback",outputs:[],stateMutability:"nonpayable",type:"function",details:"In the implementation you must pay the pool tokens owed for the minted liquidity. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.",params:{amount0Owed:"The amount of token0 due to the pool for the minted liquidity",amount1Owed:"The amount of token1 due to the pool for the minted liquidity",data:"Any data passed through by the caller via the IUniswapV3PoolActions#mint call"},notice:"Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint."},"unwrapWETH9(uint256,address)":{inputs:[{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"unwrapWETH9",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",params:{amountMinimum:"The minimum amount of WETH9 to unwrap",recipient:"The address receiving ETH"},notice:"Unwraps the contract's WETH9 balance and sends it to recipient as ETH."}}},"contracts/mocks/uniswapV3/periphery/base/Multicall.sol:Multicall":{source:"contracts/mocks/uniswapV3/periphery/base/Multicall.sol",name:"Multicall",title:"Multicall",notice:"Enables calling multiple methods in a single call to the contract",methods:{"multicall(bytes[])":{inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"multicall",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"payable",type:"function",details:"The `msg.value` should not be trusted for any method callable from multicall.",params:{data:"The encoded function data for each of the calls to make to this contract"},returns:{results:"The results from each of the calls passed in via data"},notice:"Call multiple functions in the current contract and return the data from all of them if they all succeed"}}},"contracts/mocks/uniswapV3/periphery/base/PeripheryImmutableState.sol:PeripheryImmutableState":{source:"contracts/mocks/uniswapV3/periphery/base/PeripheryImmutableState.sol",name:"PeripheryImmutableState",title:"Immutable state",notice:"Immutable state used by periphery contracts",stateVariables:{"WETH9()":{inputs:[],name:"WETH9",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"stateVariable",return:"Returns the address of WETH9"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"stateVariable",return:"Returns the address of the Uniswap V3 factory"}}},"contracts/mocks/uniswapV3/periphery/base/PeripheryPayments.sol:PeripheryPayments":{source:"contracts/mocks/uniswapV3/periphery/base/PeripheryPayments.sol",name:"PeripheryPayments",receive:{stateMutability:"payable",type:"receive"},methods:{"WETH9()":{inputs:[],name:"WETH9",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"refundETH()":{inputs:[],name:"refundETH",outputs:[],stateMutability:"payable",type:"function",details:"Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps that use ether for the input amount",notice:"Refunds any ETH balance held by this contract to the `msg.sender`"},"sweepToken(address,uint256,address)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"sweepToken",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing the token from users",params:{amountMinimum:"The minimum amount of token required for a transfer",recipient:"The destination address of the token",token:"The contract address of the token which will be transferred to `recipient`"},notice:"Transfers the full amount of a token held by this contract to recipient"},"unwrapWETH9(uint256,address)":{inputs:[{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"unwrapWETH9",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",params:{amountMinimum:"The minimum amount of WETH9 to unwrap",recipient:"The address receiving ETH"},notice:"Unwraps the contract's WETH9 balance and sends it to recipient as ETH."}}},"contracts/mocks/uniswapV3/periphery/base/PeripheryPaymentsWithFee.sol:PeripheryPaymentsWithFee":{source:"contracts/mocks/uniswapV3/periphery/base/PeripheryPaymentsWithFee.sol",name:"PeripheryPaymentsWithFee",receive:{stateMutability:"payable",type:"receive"},methods:{"WETH9()":{inputs:[],name:"WETH9",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"refundETH()":{inputs:[],name:"refundETH",outputs:[],stateMutability:"payable",type:"function",details:"Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps that use ether for the input amount",notice:"Refunds any ETH balance held by this contract to the `msg.sender`"},"sweepToken(address,uint256,address)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"sweepToken",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing the token from users",params:{amountMinimum:"The minimum amount of token required for a transfer",recipient:"The destination address of the token",token:"The contract address of the token which will be transferred to `recipient`"},notice:"Transfers the full amount of a token held by this contract to recipient"},"sweepTokenWithFee(address,uint256,address,uint256,address)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"feeBips",type:"uint256"},{internalType:"address",name:"feeRecipient",type:"address"}],name:"sweepTokenWithFee",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing the token from users",notice:"Transfers the full amount of a token held by this contract to recipient, with a percentage between 0 (exclusive) and 1 (inclusive) going to feeRecipient"},"unwrapWETH9(uint256,address)":{inputs:[{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"unwrapWETH9",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",params:{amountMinimum:"The minimum amount of WETH9 to unwrap",recipient:"The address receiving ETH"},notice:"Unwraps the contract's WETH9 balance and sends it to recipient as ETH."},"unwrapWETH9WithFee(uint256,address,uint256,address)":{inputs:[{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"feeBips",type:"uint256"},{internalType:"address",name:"feeRecipient",type:"address"}],name:"unwrapWETH9WithFee",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",notice:"Unwraps the contract's WETH9 balance and sends it to recipient as ETH, with a percentage between 0 (exclusive), and 1 (inclusive) going to feeRecipient"}}},"contracts/mocks/uniswapV3/periphery/base/PeripheryValidation.sol:PeripheryValidation":{source:"contracts/mocks/uniswapV3/periphery/base/PeripheryValidation.sol",name:"PeripheryValidation"},"contracts/mocks/uniswapV3/periphery/base/PoolInitializer.sol:PoolInitializer":{source:"contracts/mocks/uniswapV3/periphery/base/PoolInitializer.sol",name:"PoolInitializer",title:"Creates and initializes V3 Pools",methods:{"WETH9()":{inputs:[],name:"WETH9",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"createAndInitializePoolIfNecessary(address,address,uint24,uint160)":{inputs:[{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"uint160",name:"sqrtPriceX96",type:"uint160"}],name:"createAndInitializePoolIfNecessary",outputs:[{internalType:"address",name:"pool",type:"address"}],stateMutability:"payable",type:"function",details:"This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool",params:{fee:"The fee amount of the v3 pool for the specified token pair",sqrtPriceX96:"The initial square root price of the pool as a Q64.96 value",token0:"The contract address of token0 of the pool",token1:"The contract address of token1 of the pool"},returns:{pool:"Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary"},notice:"Creates a new pool if it does not exist, then initializes if not initialized"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/mocks/uniswapV3/periphery/base/SelfPermit.sol:SelfPermit":{source:"contracts/mocks/uniswapV3/periphery/base/SelfPermit.sol",name:"SelfPermit",title:"Self Permit",details:"These functions are expected to be embedded in multicalls to allow EOAs to approve a contract and call a function that requires an approval in a single transaction.",notice:"Functionality to call permit on any EIP-2612-compliant token for use in the route",methods:{"selfPermit(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermit",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this).",params:{deadline:"A timestamp, the current blocktime must be less than or equal to this timestamp",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`",value:"The amount that can be spent of token"},notice:"Permits this contract to spend a given token from `msg.sender`"},"selfPermitAllowed(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitAllowed",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this)",params:{expiry:"The timestamp at which the permit is no longer valid",nonce:"The current nonce of the owner",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter"},"selfPermitAllowedIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitAllowedIfNecessary",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this) Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.",params:{expiry:"The timestamp at which the permit is no longer valid",nonce:"The current nonce of the owner",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter"},"selfPermitIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitIfNecessary",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this). Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit",params:{deadline:"A timestamp, the current blocktime must be less than or equal to this timestamp",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`",value:"The amount that can be spent of token"},notice:"Permits this contract to spend a given token from `msg.sender`"}}},"contracts/mocks/uniswapV3/periphery/examples/PairFlash.sol:PairFlash":{source:"contracts/mocks/uniswapV3/periphery/examples/PairFlash.sol",name:"PairFlash",title:"Flash contract implementation",notice:"An example contract using the Uniswap V3 flash function",constructor:{inputs:[{internalType:"contract ISwapRouter",name:"_swapRouter",type:"address"},{internalType:"address",name:"_factory",type:"address"},{internalType:"address",name:"_WETH9",type:"address"}],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},methods:{"WETH9()":{inputs:[],name:"WETH9",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"initFlash((address,address,uint24,uint256,uint256,uint24,uint24))":{inputs:[{components:[{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee1",type:"uint24"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"uint24",name:"fee2",type:"uint24"},{internalType:"uint24",name:"fee3",type:"uint24"}],internalType:"struct PairFlash.FlashParams",name:"params",type:"tuple"}],name:"initFlash",outputs:[],stateMutability:"nonpayable",type:"function",params:{params:"The parameters necessary for flash and the callback, passed in as FlashParams"},notice:"Calls the pools flash function with data needed in `uniswapV3FlashCallback`"},"refundETH()":{inputs:[],name:"refundETH",outputs:[],stateMutability:"payable",type:"function",details:"Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps that use ether for the input amount",notice:"Refunds any ETH balance held by this contract to the `msg.sender`"},"swapRouter()":{inputs:[],name:"swapRouter",outputs:[{internalType:"contract ISwapRouter",name:"",type:"address"}],stateMutability:"view",type:"function"},"sweepToken(address,uint256,address)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"sweepToken",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing the token from users",params:{amountMinimum:"The minimum amount of token required for a transfer",recipient:"The destination address of the token",token:"The contract address of the token which will be transferred to `recipient`"},notice:"Transfers the full amount of a token held by this contract to recipient"},"uniswapV3FlashCallback(uint256,uint256,bytes)":{inputs:[{internalType:"uint256",name:"fee0",type:"uint256"},{internalType:"uint256",name:"fee1",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"uniswapV3FlashCallback",outputs:[],stateMutability:"nonpayable",type:"function",details:"fails if the flash is not profitable, meaning the amountOut from the flash is less than the amount borrowed",params:{data:"The data needed in the callback passed as FlashCallbackData from `initFlash`",fee0:"The fee from calling flash for token0",fee1:"The fee from calling flash for token1"},notice:"implements the callback called from flash"},"unwrapWETH9(uint256,address)":{inputs:[{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"unwrapWETH9",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",params:{amountMinimum:"The minimum amount of WETH9 to unwrap",recipient:"The address receiving ETH"},notice:"Unwraps the contract's WETH9 balance and sends it to recipient as ETH."}}},"contracts/mocks/uniswapV3/periphery/interfaces/IERC20Metadata.sol:IERC20Metadata":{source:"contracts/mocks/uniswapV3/periphery/interfaces/IERC20Metadata.sol",name:"IERC20Metadata",title:"IERC20MetadataInterface for ERC20 Metadata",notice:"Extension to IERC20 that includes token metadata",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",returns:{_0:"The number of decimal places the token has"}},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",returns:{_0:"The name of the token"}},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",returns:{_0:"The symbol of the token"}},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}}},"contracts/mocks/uniswapV3/periphery/interfaces/IERC721Permit.sol:IERC721Permit":{source:"contracts/mocks/uniswapV3/periphery/interfaces/IERC721Permit.sol",name:"IERC721Permit",title:"ERC721 with permit",notice:"Extension to ERC721 that includes a permit function for signature based approvals",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Approval",type:"event"},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"DOMAIN_SEPARATOR()":{inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",returns:{_0:"The domain seperator used in encoding of permit signature"},notice:"The domain separator used in the permit signature"},"PERMIT_TYPEHASH()":{inputs:[],name:"PERMIT_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"pure",type:"function",returns:{_0:"The typehash for the permit"},notice:"The permit typehash used in the permit signature"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"Gives permission to `to` to transfer `tokenId` token to another account. The approval is cleared when the token is transferred. Only a single account can be approved at a time, so approving the zero address clears previous approvals. Requirements: - The caller must own the token or be an approved operator. - `tokenId` must exist. Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"balance",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of tokens in ``owner``'s account."},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"operator",type:"address"}],stateMutability:"view",type:"function",details:"Returns the account approved for `tokenId` token. Requirements: - `tokenId` must exist."},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns if the `operator` is allowed to manage all of the assets of `owner`. See {setApprovalForAll}"},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"owner",type:"address"}],stateMutability:"view",type:"function",details:"Returns the owner of the `tokenId` token. Requirements: - `tokenId` must exist."},"permit(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"payable",type:"function",params:{deadline:"The deadline timestamp by which the call must be mined for the approve to work",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",spender:"The account that is being approved",tokenId:"The ID of the token that is being approved for spending",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Approve of a specific token ID for spending by spender via signature"},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"_approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"Approve or remove `operator` as an operator for the caller. Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller. Requirements: - The `operator` cannot be the caller. Emits an {ApprovalForAll} event."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers `tokenId` token from `from` to `to`. WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. Emits a {Transfer} event."}}},"contracts/mocks/uniswapV3/periphery/interfaces/IMulticall.sol:IMulticall":{source:"contracts/mocks/uniswapV3/periphery/interfaces/IMulticall.sol",name:"IMulticall",title:"Multicall interface",notice:"Enables calling multiple methods in a single call to the contract",methods:{"multicall(bytes[])":{inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"multicall",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"payable",type:"function",details:"The `msg.value` should not be trusted for any method callable from multicall.",params:{data:"The encoded function data for each of the calls to make to this contract"},returns:{results:"The results from each of the calls passed in via data"},notice:"Call multiple functions in the current contract and return the data from all of them if they all succeed"}}},"contracts/mocks/uniswapV3/periphery/interfaces/INonfungiblePositionManager.sol:INonfungiblePositionManager":{source:"contracts/mocks/uniswapV3/periphery/interfaces/INonfungiblePositionManager.sol",name:"INonfungiblePositionManager",title:"Non-fungible token for positions",notice:"Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred and authorized.",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Approval",type:"event"},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event"},"Collect(uint256,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"},{indexed:!1,internalType:"address",name:"recipient",type:"address"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"Collect",type:"event",details:"The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior",params:{amount0:"The amount of token0 owed to the position that was collected",amount1:"The amount of token1 owed to the position that was collected",recipient:"The address of the account that received the collected tokens",tokenId:"The ID of the token for which underlying tokens were collected"},notice:"Emitted when tokens are collected for a position NFT"},"DecreaseLiquidity(uint256,uint128,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"},{indexed:!1,internalType:"uint128",name:"liquidity",type:"uint128"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"DecreaseLiquidity",type:"event",params:{amount0:"The amount of token0 that was accounted for the decrease in liquidity",amount1:"The amount of token1 that was accounted for the decrease in liquidity",liquidity:"The amount by which liquidity for the NFT position was decreased",tokenId:"The ID of the token for which liquidity was decreased"},notice:"Emitted when liquidity is decreased for a position NFT"},"IncreaseLiquidity(uint256,uint128,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"},{indexed:!1,internalType:"uint128",name:"liquidity",type:"uint128"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"IncreaseLiquidity",type:"event",details:"Also emitted when a token is minted",params:{amount0:"The amount of token0 that was paid for the increase in liquidity",amount1:"The amount of token1 that was paid for the increase in liquidity",liquidity:"The amount by which liquidity for the NFT position was increased",tokenId:"The ID of the token for which liquidity was increased"},notice:"Emitted when liquidity is increased for a position NFT"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"DOMAIN_SEPARATOR()":{inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",returns:{_0:"The domain seperator used in encoding of permit signature"},notice:"The domain separator used in the permit signature"},"PERMIT_TYPEHASH()":{inputs:[],name:"PERMIT_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"pure",type:"function",returns:{_0:"The typehash for the permit"},notice:"The permit typehash used in the permit signature"},"WETH9()":{inputs:[],name:"WETH9",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",returns:{_0:"Returns the address of WETH9"}},"approve(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"Gives permission to `to` to transfer `tokenId` token to another account. The approval is cleared when the token is transferred. Only a single account can be approved at a time, so approving the zero address clears previous approvals. Requirements: - The caller must own the token or be an approved operator. - `tokenId` must exist. Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"balance",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of tokens in ``owner``'s account."},"burn(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"burn",outputs:[],stateMutability:"payable",type:"function",params:{tokenId:"The ID of the token that is being burned"},notice:"Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens must be collected first."},"collect((uint256,address,uint128,uint128))":{inputs:[{components:[{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint128",name:"amount0Max",type:"uint128"},{internalType:"uint128",name:"amount1Max",type:"uint128"}],internalType:"struct INonfungiblePositionManager.CollectParams",name:"params",type:"tuple"}],name:"collect",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"tokenId The ID of the NFT for which tokens are being collected, recipient The account that should receive the tokens, amount0Max The maximum amount of token0 to collect, amount1Max The maximum amount of token1 to collect"},returns:{amount0:"The amount of fees collected in token0",amount1:"The amount of fees collected in token1"},notice:"Collects up to a maximum amount of fees owed to a specific position to the recipient"},"createAndInitializePoolIfNecessary(address,address,uint24,uint160)":{inputs:[{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"uint160",name:"sqrtPriceX96",type:"uint160"}],name:"createAndInitializePoolIfNecessary",outputs:[{internalType:"address",name:"pool",type:"address"}],stateMutability:"payable",type:"function",details:"This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool",params:{fee:"The fee amount of the v3 pool for the specified token pair",sqrtPriceX96:"The initial square root price of the pool as a Q64.96 value",token0:"The contract address of token0 of the pool",token1:"The contract address of token1 of the pool"},returns:{pool:"Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary"},notice:"Creates a new pool if it does not exist, then initializes if not initialized"},"decreaseLiquidity((uint256,uint128,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"uint128",name:"liquidity",type:"uint128"},{internalType:"uint256",name:"amount0Min",type:"uint256"},{internalType:"uint256",name:"amount1Min",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],internalType:"struct INonfungiblePositionManager.DecreaseLiquidityParams",name:"params",type:"tuple"}],name:"decreaseLiquidity",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"tokenId The ID of the token for which liquidity is being decreased, amount The amount by which liquidity will be decreased, amount0Min The minimum amount of token0 that should be accounted for the burned liquidity, amount1Min The minimum amount of token1 that should be accounted for the burned liquidity, deadline The time by which the transaction must be included to effect the change"},returns:{amount0:"The amount of token0 accounted to the position's tokens owed",amount1:"The amount of token1 accounted to the position's tokens owed"},notice:"Decreases the amount of liquidity in a position and accounts it to the position"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",returns:{_0:"Returns the address of the Uniswap V3 factory"}},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"operator",type:"address"}],stateMutability:"view",type:"function",details:"Returns the account approved for `tokenId` token. Requirements: - `tokenId` must exist."},"increaseLiquidity((uint256,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"uint256",name:"amount0Desired",type:"uint256"},{internalType:"uint256",name:"amount1Desired",type:"uint256"},{internalType:"uint256",name:"amount0Min",type:"uint256"},{internalType:"uint256",name:"amount1Min",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],internalType:"struct INonfungiblePositionManager.IncreaseLiquidityParams",name:"params",type:"tuple"}],name:"increaseLiquidity",outputs:[{internalType:"uint128",name:"liquidity",type:"uint128"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"tokenId The ID of the token for which liquidity is being increased, amount0Desired The desired amount of token0 to be spent, amount1Desired The desired amount of token1 to be spent, amount0Min The minimum amount of token0 to spend, which serves as a slippage check, amount1Min The minimum amount of token1 to spend, which serves as a slippage check, deadline The time by which the transaction must be included to effect the change"},returns:{amount0:"The amount of token0 to acheive resulting liquidity",amount1:"The amount of token1 to acheive resulting liquidity",liquidity:"The new liquidity amount as a result of the increase"},notice:"Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`"},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns if the `operator` is allowed to manage all of the assets of `owner`. See {setApprovalForAll}"},"mint((address,address,uint24,int24,int24,uint256,uint256,uint256,uint256,address,uint256))":{inputs:[{components:[{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint256",name:"amount0Desired",type:"uint256"},{internalType:"uint256",name:"amount1Desired",type:"uint256"},{internalType:"uint256",name:"amount0Min",type:"uint256"},{internalType:"uint256",name:"amount1Min",type:"uint256"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],internalType:"struct INonfungiblePositionManager.MintParams",name:"params",type:"tuple"}],name:"mint",outputs:[{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"uint128",name:"liquidity",type:"uint128"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"payable",type:"function",details:"Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized a method does not exist, i.e. the pool is assumed to be initialized.",params:{params:"The params necessary to mint a position, encoded as `MintParams` in calldata"},returns:{amount0:"The amount of token0",amount1:"The amount of token1",liquidity:"The amount of liquidity for this position",tokenId:"The ID of the token that represents the minted position"},notice:"Creates a new position wrapped in a NFT"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the token collection name."},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"owner",type:"address"}],stateMutability:"view",type:"function",details:"Returns the owner of the `tokenId` token. Requirements: - `tokenId` must exist."},"permit(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"payable",type:"function",params:{deadline:"The deadline timestamp by which the call must be mined for the approve to work",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",spender:"The account that is being approved",tokenId:"The ID of the token that is being approved for spending",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Approve of a specific token ID for spending by spender via signature"},"positions(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"positions",outputs:[{internalType:"uint96",name:"nonce",type:"uint96"},{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint128",name:"liquidity",type:"uint128"},{internalType:"uint256",name:"feeGrowthInside0LastX128",type:"uint256"},{internalType:"uint256",name:"feeGrowthInside1LastX128",type:"uint256"},{internalType:"uint128",name:"tokensOwed0",type:"uint128"},{internalType:"uint128",name:"tokensOwed1",type:"uint128"}],stateMutability:"view",type:"function",details:"Throws if the token ID is not valid.",params:{tokenId:"The ID of the token that represents the position"},returns:{fee:"The fee associated with the pool",feeGrowthInside0LastX128:"The fee growth of token0 as of the last action on the individual position",feeGrowthInside1LastX128:"The fee growth of token1 as of the last action on the individual position",liquidity:"The liquidity of the position",nonce:"The nonce for permits",operator:"The address that is approved for spending",tickLower:"The lower end of the tick range for the position",tickUpper:"The higher end of the tick range for the position",token0:"The address of the token0 for a specific pool",token1:"The address of the token1 for a specific pool",tokensOwed0:"The uncollected amount of token0 owed to the position as of the last computation",tokensOwed1:"The uncollected amount of token1 owed to the position as of the last computation"},notice:"Returns the position information associated with a given token ID."},"refundETH()":{inputs:[],name:"refundETH",outputs:[],stateMutability:"payable",type:"function",details:"Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps that use ether for the input amount",notice:"Refunds any ETH balance held by this contract to the `msg.sender`"},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"_approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"Approve or remove `operator` as an operator for the caller. Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller. Requirements: - The `operator` cannot be the caller. Emits an {ApprovalForAll} event."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."},"sweepToken(address,uint256,address)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"sweepToken",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing the token from users",params:{amountMinimum:"The minimum amount of token required for a transfer",recipient:"The destination address of the token",token:"The contract address of the token which will be transferred to `recipient`"},notice:"Transfers the full amount of a token held by this contract to recipient"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the token collection symbol."},"tokenByIndex(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"tokenByIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns a token ID at a given `index` of all the tokens stored by the contract. Use along with {totalSupply} to enumerate all tokens."},"tokenOfOwnerByIndex(address,uint256)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"uint256",name:"index",type:"uint256"}],name:"tokenOfOwnerByIndex",outputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns a token ID owned by `owner` at a given `index` of its token list. Use along with {balanceOf} to enumerate all of ``owner``'s tokens."},"tokenURI(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the Uniform Resource Identifier (URI) for `tokenId` token."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the total amount of tokens stored by the contract."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers `tokenId` token from `from` to `to`. WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. Emits a {Transfer} event."},"unwrapWETH9(uint256,address)":{inputs:[{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"unwrapWETH9",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",params:{amountMinimum:"The minimum amount of WETH9 to unwrap",recipient:"The address receiving ETH"},notice:"Unwraps the contract's WETH9 balance and sends it to recipient as ETH."}}},"contracts/mocks/uniswapV3/periphery/interfaces/INonfungibleTokenPositionDescriptor.sol:INonfungibleTokenPositionDescriptor":{source:"contracts/mocks/uniswapV3/periphery/interfaces/INonfungibleTokenPositionDescriptor.sol",name:"INonfungibleTokenPositionDescriptor",title:"Describes position NFT tokens via URI",methods:{"tokenURI(address,uint256)":{inputs:[{internalType:"contract INonfungiblePositionManager",name:"positionManager",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Note this URI may be a data: URI with the JSON contents directly inlined",params:{positionManager:"The position manager for which to describe the token",tokenId:"The ID of the token for which to produce a description, which may not be valid"},returns:{_0:"The URI of the ERC721-compliant metadata"},notice:"Produces the URI describing a particular token ID for a position manager"}}},"contracts/mocks/uniswapV3/periphery/interfaces/IPeripheryImmutableState.sol:IPeripheryImmutableState":{source:"contracts/mocks/uniswapV3/periphery/interfaces/IPeripheryImmutableState.sol",name:"IPeripheryImmutableState",title:"Immutable state",notice:"Functions that return immutable state of the router",methods:{"WETH9()":{inputs:[],name:"WETH9",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",returns:{_0:"Returns the address of WETH9"}},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",returns:{_0:"Returns the address of the Uniswap V3 factory"}}}},"contracts/mocks/uniswapV3/periphery/interfaces/IPeripheryPayments.sol:IPeripheryPayments":{source:"contracts/mocks/uniswapV3/periphery/interfaces/IPeripheryPayments.sol",name:"IPeripheryPayments",title:"Periphery Payments",notice:"Functions to ease deposits and withdrawals of ETH",methods:{"refundETH()":{inputs:[],name:"refundETH",outputs:[],stateMutability:"payable",type:"function",details:"Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps that use ether for the input amount",notice:"Refunds any ETH balance held by this contract to the `msg.sender`"},"sweepToken(address,uint256,address)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"sweepToken",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing the token from users",params:{amountMinimum:"The minimum amount of token required for a transfer",recipient:"The destination address of the token",token:"The contract address of the token which will be transferred to `recipient`"},notice:"Transfers the full amount of a token held by this contract to recipient"},"unwrapWETH9(uint256,address)":{inputs:[{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"unwrapWETH9",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",params:{amountMinimum:"The minimum amount of WETH9 to unwrap",recipient:"The address receiving ETH"},notice:"Unwraps the contract's WETH9 balance and sends it to recipient as ETH."}}},"contracts/mocks/uniswapV3/periphery/interfaces/IPeripheryPaymentsWithFee.sol:IPeripheryPaymentsWithFee":{source:"contracts/mocks/uniswapV3/periphery/interfaces/IPeripheryPaymentsWithFee.sol",name:"IPeripheryPaymentsWithFee",title:"Periphery Payments",notice:"Functions to ease deposits and withdrawals of ETH",methods:{"refundETH()":{inputs:[],name:"refundETH",outputs:[],stateMutability:"payable",type:"function",details:"Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps that use ether for the input amount",notice:"Refunds any ETH balance held by this contract to the `msg.sender`"},"sweepToken(address,uint256,address)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"sweepToken",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing the token from users",params:{amountMinimum:"The minimum amount of token required for a transfer",recipient:"The destination address of the token",token:"The contract address of the token which will be transferred to `recipient`"},notice:"Transfers the full amount of a token held by this contract to recipient"},"sweepTokenWithFee(address,uint256,address,uint256,address)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"feeBips",type:"uint256"},{internalType:"address",name:"feeRecipient",type:"address"}],name:"sweepTokenWithFee",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing the token from users",notice:"Transfers the full amount of a token held by this contract to recipient, with a percentage between 0 (exclusive) and 1 (inclusive) going to feeRecipient"},"unwrapWETH9(uint256,address)":{inputs:[{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"unwrapWETH9",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",params:{amountMinimum:"The minimum amount of WETH9 to unwrap",recipient:"The address receiving ETH"},notice:"Unwraps the contract's WETH9 balance and sends it to recipient as ETH."},"unwrapWETH9WithFee(uint256,address,uint256,address)":{inputs:[{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"feeBips",type:"uint256"},{internalType:"address",name:"feeRecipient",type:"address"}],name:"unwrapWETH9WithFee",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",notice:"Unwraps the contract's WETH9 balance and sends it to recipient as ETH, with a percentage between 0 (exclusive), and 1 (inclusive) going to feeRecipient"}}},"contracts/mocks/uniswapV3/periphery/interfaces/IPoolInitializer.sol:IPoolInitializer":{source:"contracts/mocks/uniswapV3/periphery/interfaces/IPoolInitializer.sol",name:"IPoolInitializer",title:"Creates and initializes V3 Pools",notice:"Provides a method for creating and initializing a pool, if necessary, for bundling with other methods that require the pool to exist.",methods:{"createAndInitializePoolIfNecessary(address,address,uint24,uint160)":{inputs:[{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"uint160",name:"sqrtPriceX96",type:"uint160"}],name:"createAndInitializePoolIfNecessary",outputs:[{internalType:"address",name:"pool",type:"address"}],stateMutability:"payable",type:"function",details:"This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool",params:{fee:"The fee amount of the v3 pool for the specified token pair",sqrtPriceX96:"The initial square root price of the pool as a Q64.96 value",token0:"The contract address of token0 of the pool",token1:"The contract address of token1 of the pool"},returns:{pool:"Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary"},notice:"Creates a new pool if it does not exist, then initializes if not initialized"}}},"contracts/mocks/uniswapV3/periphery/interfaces/IQuoter.sol:IQuoter":{source:"contracts/mocks/uniswapV3/periphery/interfaces/IQuoter.sol",name:"IQuoter",title:"Quoter Interface",details:"These functions are not marked view because they rely on calling non-view functions and reverting to compute the result. They are also not gas efficient and should not be called on-chain.",notice:"Supports quoting the calculated amounts from exact input or exact output swaps",methods:{"quoteExactInput(bytes,uint256)":{inputs:[{internalType:"bytes",name:"path",type:"bytes"},{internalType:"uint256",name:"amountIn",type:"uint256"}],name:"quoteExactInput",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amountIn:"The amount of the first token to swap",path:"The path of the swap, i.e. each token pair and the pool fee"},returns:{amountOut:"The amount of the last token that would be received"},notice:"Returns the amount out received for a given exact input swap without executing the swap"},"quoteExactInputSingle(address,address,uint24,uint256,uint160)":{inputs:[{internalType:"address",name:"tokenIn",type:"address"},{internalType:"address",name:"tokenOut",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"}],name:"quoteExactInputSingle",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amountIn:"The desired input amount",fee:"The fee of the token pool to consider for the pair",sqrtPriceLimitX96:"The price limit of the pool that cannot be exceeded by the swap",tokenIn:"The token being swapped in",tokenOut:"The token being swapped out"},returns:{amountOut:"The amount of `tokenOut` that would be received"},notice:"Returns the amount out received for a given exact input but for a swap of a single pool"},"quoteExactOutput(bytes,uint256)":{inputs:[{internalType:"bytes",name:"path",type:"bytes"},{internalType:"uint256",name:"amountOut",type:"uint256"}],name:"quoteExactOutput",outputs:[{internalType:"uint256",name:"amountIn",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amountOut:"The amount of the last token to receive",path:"The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order"},returns:{amountIn:"The amount of first token required to be paid"},notice:"Returns the amount in required for a given exact output swap without executing the swap"},"quoteExactOutputSingle(address,address,uint24,uint256,uint160)":{inputs:[{internalType:"address",name:"tokenIn",type:"address"},{internalType:"address",name:"tokenOut",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"}],name:"quoteExactOutputSingle",outputs:[{internalType:"uint256",name:"amountIn",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amountOut:"The desired output amount",fee:"The fee of the token pool to consider for the pair",sqrtPriceLimitX96:"The price limit of the pool that cannot be exceeded by the swap",tokenIn:"The token being swapped in",tokenOut:"The token being swapped out"},returns:{amountIn:"The amount required as the input for the swap in order to receive `amountOut`"},notice:"Returns the amount in required to receive the given exact output amount but for a swap of a single pool"}}},"contracts/mocks/uniswapV3/periphery/interfaces/IQuoterV2.sol:IQuoterV2":{source:"contracts/mocks/uniswapV3/periphery/interfaces/IQuoterV2.sol",name:"IQuoterV2",title:"QuoterV2 Interface",details:"These functions are not marked view because they rely on calling non-view functions and reverting to compute the result. They are also not gas efficient and should not be called on-chain.",notice:"Supports quoting the calculated amounts from exact input or exact output swaps.For each pool also tells you the number of initialized ticks crossed and the sqrt price of the pool after the swap.",methods:{"quoteExactInput(bytes,uint256)":{inputs:[{internalType:"bytes",name:"path",type:"bytes"},{internalType:"uint256",name:"amountIn",type:"uint256"}],name:"quoteExactInput",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint160[]",name:"sqrtPriceX96AfterList",type:"uint160[]"},{internalType:"uint32[]",name:"initializedTicksCrossedList",type:"uint32[]"},{internalType:"uint256",name:"gasEstimate",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amountIn:"The amount of the first token to swap",path:"The path of the swap, i.e. each token pair and the pool fee"},returns:{amountOut:"The amount of the last token that would be received",gasEstimate:"The estimate of the gas that the swap consumes",initializedTicksCrossedList:"List of the initialized ticks that the swap crossed for each pool in the path",sqrtPriceX96AfterList:"List of the sqrt price after the swap for each pool in the path"},notice:"Returns the amount out received for a given exact input swap without executing the swap"},"quoteExactInputSingle((address,address,uint256,uint24,uint160))":{inputs:[{components:[{internalType:"address",name:"tokenIn",type:"address"},{internalType:"address",name:"tokenOut",type:"address"},{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"}],internalType:"struct IQuoterV2.QuoteExactInputSingleParams",name:"params",type:"tuple"}],name:"quoteExactInputSingle",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint160",name:"sqrtPriceX96After",type:"uint160"},{internalType:"uint32",name:"initializedTicksCrossed",type:"uint32"},{internalType:"uint256",name:"gasEstimate",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{params:"The params for the quote, encoded as `QuoteExactInputSingleParams` tokenIn The token being swapped in tokenOut The token being swapped out fee The fee of the token pool to consider for the pair amountIn The desired input amount sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap"},returns:{amountOut:"The amount of `tokenOut` that would be received",gasEstimate:"The estimate of the gas that the swap consumes",initializedTicksCrossed:"The number of initialized ticks that the swap crossed",sqrtPriceX96After:"The sqrt price of the pool after the swap"},notice:"Returns the amount out received for a given exact input but for a swap of a single pool"},"quoteExactOutput(bytes,uint256)":{inputs:[{internalType:"bytes",name:"path",type:"bytes"},{internalType:"uint256",name:"amountOut",type:"uint256"}],name:"quoteExactOutput",outputs:[{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint160[]",name:"sqrtPriceX96AfterList",type:"uint160[]"},{internalType:"uint32[]",name:"initializedTicksCrossedList",type:"uint32[]"},{internalType:"uint256",name:"gasEstimate",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amountOut:"The amount of the last token to receive",path:"The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order"},returns:{amountIn:"The amount of first token required to be paid",gasEstimate:"The estimate of the gas that the swap consumes",initializedTicksCrossedList:"List of the initialized ticks that the swap crossed for each pool in the path",sqrtPriceX96AfterList:"List of the sqrt price after the swap for each pool in the path"},notice:"Returns the amount in required for a given exact output swap without executing the swap"},"quoteExactOutputSingle((address,address,uint256,uint24,uint160))":{inputs:[{components:[{internalType:"address",name:"tokenIn",type:"address"},{internalType:"address",name:"tokenOut",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"}],internalType:"struct IQuoterV2.QuoteExactOutputSingleParams",name:"params",type:"tuple"}],name:"quoteExactOutputSingle",outputs:[{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint160",name:"sqrtPriceX96After",type:"uint160"},{internalType:"uint32",name:"initializedTicksCrossed",type:"uint32"},{internalType:"uint256",name:"gasEstimate",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{params:"The params for the quote, encoded as `QuoteExactOutputSingleParams` tokenIn The token being swapped in tokenOut The token being swapped out fee The fee of the token pool to consider for the pair amountOut The desired output amount sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap"},returns:{amountIn:"The amount required as the input for the swap in order to receive `amountOut`",gasEstimate:"The estimate of the gas that the swap consumes",initializedTicksCrossed:"The number of initialized ticks that the swap crossed",sqrtPriceX96After:"The sqrt price of the pool after the swap"},notice:"Returns the amount in required to receive the given exact output amount but for a swap of a single pool"}}},"contracts/mocks/uniswapV3/periphery/interfaces/ISelfPermit.sol:ISelfPermit":{source:"contracts/mocks/uniswapV3/periphery/interfaces/ISelfPermit.sol",name:"ISelfPermit",title:"Self Permit",notice:"Functionality to call permit on any EIP-2612-compliant token for use in the route",methods:{"selfPermit(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermit",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this).",params:{deadline:"A timestamp, the current blocktime must be less than or equal to this timestamp",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`",value:"The amount that can be spent of token"},notice:"Permits this contract to spend a given token from `msg.sender`"},"selfPermitAllowed(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitAllowed",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this)",params:{expiry:"The timestamp at which the permit is no longer valid",nonce:"The current nonce of the owner",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter"},"selfPermitAllowedIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitAllowedIfNecessary",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this) Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.",params:{expiry:"The timestamp at which the permit is no longer valid",nonce:"The current nonce of the owner",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter"},"selfPermitIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitIfNecessary",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this). Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit",params:{deadline:"A timestamp, the current blocktime must be less than or equal to this timestamp",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`",value:"The amount that can be spent of token"},notice:"Permits this contract to spend a given token from `msg.sender`"}}},"contracts/mocks/uniswapV3/periphery/interfaces/ISwapRouter.sol:ISwapRouter":{source:"contracts/mocks/uniswapV3/periphery/interfaces/ISwapRouter.sol",name:"ISwapRouter",title:"Router token swapping functionality",notice:"Functions for swapping tokens via Uniswap V3",methods:{"exactInput((bytes,address,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"bytes",name:"path",type:"bytes"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint256",name:"amountOutMinimum",type:"uint256"}],internalType:"struct ISwapRouter.ExactInputParams",name:"params",type:"tuple"}],name:"exactInput",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata"},returns:{amountOut:"The amount of the received token"},notice:"Swaps `amountIn` of one token for as much as possible of another along the specified path"},"exactInputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))":{inputs:[{components:[{internalType:"address",name:"tokenIn",type:"address"},{internalType:"address",name:"tokenOut",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint256",name:"amountOutMinimum",type:"uint256"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"}],internalType:"struct ISwapRouter.ExactInputSingleParams",name:"params",type:"tuple"}],name:"exactInputSingle",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata"},returns:{amountOut:"The amount of the received token"},notice:"Swaps `amountIn` of one token for as much as possible of another token"},"exactOutput((bytes,address,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"bytes",name:"path",type:"bytes"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint256",name:"amountInMaximum",type:"uint256"}],internalType:"struct ISwapRouter.ExactOutputParams",name:"params",type:"tuple"}],name:"exactOutput",outputs:[{internalType:"uint256",name:"amountIn",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata"},returns:{amountIn:"The amount of the input token"},notice:"Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)"},"exactOutputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))":{inputs:[{components:[{internalType:"address",name:"tokenIn",type:"address"},{internalType:"address",name:"tokenOut",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint256",name:"amountInMaximum",type:"uint256"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"}],internalType:"struct ISwapRouter.ExactOutputSingleParams",name:"params",type:"tuple"}],name:"exactOutputSingle",outputs:[{internalType:"uint256",name:"amountIn",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata"},returns:{amountIn:"The amount of the input token"},notice:"Swaps as little as possible of one token for `amountOut` of another token"},"uniswapV3SwapCallback(int256,int256,bytes)":{inputs:[{internalType:"int256",name:"amount0Delta",type:"int256"},{internalType:"int256",name:"amount1Delta",type:"int256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"uniswapV3SwapCallback",outputs:[],stateMutability:"nonpayable",type:"function",details:"In the implementation you must pay the pool tokens owed for the swap. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. amount0Delta and amount1Delta can both be 0 if no tokens were swapped.",params:{amount0Delta:"The amount of token0 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token0 to the pool.",amount1Delta:"The amount of token1 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token1 to the pool.",data:"Any data passed through by the caller via the IUniswapV3PoolActions#swap call"},notice:"Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap."}}},"contracts/mocks/uniswapV3/periphery/interfaces/ITickLens.sol:ITickLens":{source:"contracts/mocks/uniswapV3/periphery/interfaces/ITickLens.sol",name:"ITickLens",title:"Tick Lens",details:"This avoids the waterfall of fetching the tick bitmap, parsing the bitmap to know which ticks to fetch, and then sending additional multicalls to fetch the tick data",notice:"Provides functions for fetching chunks of tick data for a pool",methods:{"getPopulatedTicksInWord(address,int16)":{inputs:[{internalType:"address",name:"pool",type:"address"},{internalType:"int16",name:"tickBitmapIndex",type:"int16"}],name:"getPopulatedTicksInWord",outputs:[{components:[{internalType:"int24",name:"tick",type:"int24"},{internalType:"int128",name:"liquidityNet",type:"int128"},{internalType:"uint128",name:"liquidityGross",type:"uint128"}],internalType:"struct ITickLens.PopulatedTick[]",name:"populatedTicks",type:"tuple[]"}],stateMutability:"view",type:"function",params:{pool:"The address of the pool for which to fetch populated tick data",tickBitmapIndex:"The index of the word in the tick bitmap for which to parse the bitmap and fetch all the populated ticks"},returns:{populatedTicks:"An array of tick data for the given word in the tick bitmap"},notice:"Get all the tick data for the populated ticks from a word of the tick bitmap of a pool"}}},"contracts/mocks/uniswapV3/periphery/interfaces/IV3Migrator.sol:IV3Migrator":{source:"contracts/mocks/uniswapV3/periphery/interfaces/IV3Migrator.sol",name:"IV3Migrator",title:"V3 Migrator",notice:"Enables migration of liqudity from Uniswap v2-compatible pairs into Uniswap v3 pools",methods:{"createAndInitializePoolIfNecessary(address,address,uint24,uint160)":{inputs:[{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"uint160",name:"sqrtPriceX96",type:"uint160"}],name:"createAndInitializePoolIfNecessary",outputs:[{internalType:"address",name:"pool",type:"address"}],stateMutability:"payable",type:"function",details:"This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool",params:{fee:"The fee amount of the v3 pool for the specified token pair",sqrtPriceX96:"The initial square root price of the pool as a Q64.96 value",token0:"The contract address of token0 of the pool",token1:"The contract address of token1 of the pool"},returns:{pool:"Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary"},notice:"Creates a new pool if it does not exist, then initializes if not initialized"},"migrate((address,uint256,uint8,address,address,uint24,int24,int24,uint256,uint256,address,uint256,bool))":{inputs:[{components:[{internalType:"address",name:"pair",type:"address"},{internalType:"uint256",name:"liquidityToMigrate",type:"uint256"},{internalType:"uint8",name:"percentageToMigrate",type:"uint8"},{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint256",name:"amount0Min",type:"uint256"},{internalType:"uint256",name:"amount1Min",type:"uint256"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"bool",name:"refundAsETH",type:"bool"}],internalType:"struct IV3Migrator.MigrateParams",name:"params",type:"tuple"}],name:"migrate",outputs:[],stateMutability:"nonpayable",type:"function",details:"Slippage protection is enforced via `amount{0,1}Min`, which should be a discount of the expected values of the maximum amount of v3 liquidity that the v2 liquidity can get. For the special case of migrating to an out-of-range position, `amount{0,1}Min` may be set to 0, enforcing that the position remains out of range",params:{params:"The params necessary to migrate v2 liquidity, encoded as `MigrateParams` in calldata"},notice:"Migrates liquidity to v3 by burning v2 liquidity and minting a new position for v3"},"multicall(bytes[])":{inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"multicall",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"payable",type:"function",details:"The `msg.value` should not be trusted for any method callable from multicall.",params:{data:"The encoded function data for each of the calls to make to this contract"},returns:{results:"The results from each of the calls passed in via data"},notice:"Call multiple functions in the current contract and return the data from all of them if they all succeed"},"selfPermit(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermit",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this).",params:{deadline:"A timestamp, the current blocktime must be less than or equal to this timestamp",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`",value:"The amount that can be spent of token"},notice:"Permits this contract to spend a given token from `msg.sender`"},"selfPermitAllowed(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitAllowed",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this)",params:{expiry:"The timestamp at which the permit is no longer valid",nonce:"The current nonce of the owner",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter"},"selfPermitAllowedIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitAllowedIfNecessary",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this) Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.",params:{expiry:"The timestamp at which the permit is no longer valid",nonce:"The current nonce of the owner",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter"},"selfPermitIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitIfNecessary",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this). Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit",params:{deadline:"A timestamp, the current blocktime must be less than or equal to this timestamp",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`",value:"The amount that can be spent of token"},notice:"Permits this contract to spend a given token from `msg.sender`"}}},"contracts/mocks/uniswapV3/periphery/interfaces/external/IERC1271.sol:IERC1271":{source:"contracts/mocks/uniswapV3/periphery/interfaces/external/IERC1271.sol",name:"IERC1271",title:"Interface for verifying contract-based account signatures",details:"Interface defined by EIP-1271",notice:"Interface that verifies provided signature for the data",methods:{"isValidSignature(bytes32,bytes)":{inputs:[{internalType:"bytes32",name:"hash",type:"bytes32"},{internalType:"bytes",name:"signature",type:"bytes"}],name:"isValidSignature",outputs:[{internalType:"bytes4",name:"magicValue",type:"bytes4"}],stateMutability:"view",type:"function",details:"MUST return the bytes4 magic value 0x1626ba7e when function passes. MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5). MUST allow external calls.",params:{hash:"Hash of the data to be signed",signature:"Signature byte array associated with _data"},returns:{magicValue:"The bytes4 magic value 0x1626ba7e"},notice:"Returns whether the provided signature is valid for the provided data"}}},"contracts/mocks/uniswapV3/periphery/interfaces/external/IERC20PermitAllowed.sol:IERC20PermitAllowed":{source:"contracts/mocks/uniswapV3/periphery/interfaces/external/IERC20PermitAllowed.sol",name:"IERC20PermitAllowed",title:"Interface for permit",notice:"Interface used by DAI/CHAI for permit",methods:{"permit(address,address,uint256,uint256,bool,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"holder",type:"address"},{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"bool",name:"allowed",type:"bool"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"nonpayable",type:"function",details:"This is the permit interface used by DAI and CHAI",params:{allowed:"Boolean that sets approval amount, true for type(uint256).max and false for 0",expiry:"The timestamp at which the permit is no longer valid",holder:"The address of the token holder, the token owner",nonce:"The holder's nonce, increases at each call to permit",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",spender:"The address of the token spender",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Approve the spender to spend some tokens via the holder signature"}}},"contracts/mocks/uniswapV3/periphery/interfaces/external/IWETH9.sol:IWETH9":{source:"contracts/mocks/uniswapV3/periphery/interfaces/external/IWETH9.sol",name:"IWETH9",title:"Interface for WETH9",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"deposit()":{inputs:[],name:"deposit",outputs:[],stateMutability:"payable",type:"function",notice:"Deposit ether to get wrapped ether"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Withdraw wrapped ether to get ether"}}},"contracts/mocks/uniswapV3/periphery/lens/Quoter.sol:Quoter":{source:"contracts/mocks/uniswapV3/periphery/lens/Quoter.sol",name:"Quoter",title:"Provides quotes for swaps",details:"These functions are not gas efficient and should _not_ be called on chain. Instead, optimistically execute the swap and check the amounts in the callback.",notice:"Allows getting the expected amount out or amount in for a given swap without executing the swap",constructor:{inputs:[{internalType:"address",name:"_factory",type:"address"},{internalType:"address",name:"_WETH9",type:"address"}],stateMutability:"nonpayable",type:"constructor"},methods:{"WETH9()":{inputs:[],name:"WETH9",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"quoteExactInput(bytes,uint256)":{inputs:[{internalType:"bytes",name:"path",type:"bytes"},{internalType:"uint256",name:"amountIn",type:"uint256"}],name:"quoteExactInput",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amountIn:"The amount of the first token to swap",path:"The path of the swap, i.e. each token pair and the pool fee"},returns:{amountOut:"The amount of the last token that would be received"},notice:"Returns the amount out received for a given exact input swap without executing the swap"},"quoteExactInputSingle(address,address,uint24,uint256,uint160)":{inputs:[{internalType:"address",name:"tokenIn",type:"address"},{internalType:"address",name:"tokenOut",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"}],name:"quoteExactInputSingle",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amountIn:"The desired input amount",fee:"The fee of the token pool to consider for the pair",sqrtPriceLimitX96:"The price limit of the pool that cannot be exceeded by the swap",tokenIn:"The token being swapped in",tokenOut:"The token being swapped out"},returns:{amountOut:"The amount of `tokenOut` that would be received"},notice:"Returns the amount out received for a given exact input but for a swap of a single pool"},"quoteExactOutput(bytes,uint256)":{inputs:[{internalType:"bytes",name:"path",type:"bytes"},{internalType:"uint256",name:"amountOut",type:"uint256"}],name:"quoteExactOutput",outputs:[{internalType:"uint256",name:"amountIn",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amountOut:"The amount of the last token to receive",path:"The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order"},returns:{amountIn:"The amount of first token required to be paid"},notice:"Returns the amount in required for a given exact output swap without executing the swap"},"quoteExactOutputSingle(address,address,uint24,uint256,uint160)":{inputs:[{internalType:"address",name:"tokenIn",type:"address"},{internalType:"address",name:"tokenOut",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"}],name:"quoteExactOutputSingle",outputs:[{internalType:"uint256",name:"amountIn",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amountOut:"The desired output amount",fee:"The fee of the token pool to consider for the pair",sqrtPriceLimitX96:"The price limit of the pool that cannot be exceeded by the swap",tokenIn:"The token being swapped in",tokenOut:"The token being swapped out"},returns:{amountIn:"The amount required as the input for the swap in order to receive `amountOut`"},notice:"Returns the amount in required to receive the given exact output amount but for a swap of a single pool"},"uniswapV3SwapCallback(int256,int256,bytes)":{inputs:[{internalType:"int256",name:"amount0Delta",type:"int256"},{internalType:"int256",name:"amount1Delta",type:"int256"},{internalType:"bytes",name:"path",type:"bytes"}],name:"uniswapV3SwapCallback",outputs:[],stateMutability:"view",type:"function",details:"In the implementation you must pay the pool tokens owed for the swap. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. amount0Delta and amount1Delta can both be 0 if no tokens were swapped.",params:{amount0Delta:"The amount of token0 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token0 to the pool.",amount1Delta:"The amount of token1 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token1 to the pool.",data:"Any data passed through by the caller via the IUniswapV3PoolActions#swap call"},notice:"Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap."}}},"contracts/mocks/uniswapV3/periphery/lens/QuoterV2.sol:QuoterV2":{source:"contracts/mocks/uniswapV3/periphery/lens/QuoterV2.sol",name:"QuoterV2",title:"Provides quotes for swaps",details:"These functions are not gas efficient and should _not_ be called on chain. Instead, optimistically execute the swap and check the amounts in the callback.",notice:"Allows getting the expected amount out or amount in for a given swap without executing the swap",constructor:{inputs:[{internalType:"address",name:"_factory",type:"address"},{internalType:"address",name:"_WETH9",type:"address"}],stateMutability:"nonpayable",type:"constructor"},methods:{"WETH9()":{inputs:[],name:"WETH9",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"quoteExactInput(bytes,uint256)":{inputs:[{internalType:"bytes",name:"path",type:"bytes"},{internalType:"uint256",name:"amountIn",type:"uint256"}],name:"quoteExactInput",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint160[]",name:"sqrtPriceX96AfterList",type:"uint160[]"},{internalType:"uint32[]",name:"initializedTicksCrossedList",type:"uint32[]"},{internalType:"uint256",name:"gasEstimate",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amountIn:"The amount of the first token to swap",path:"The path of the swap, i.e. each token pair and the pool fee"},returns:{amountOut:"The amount of the last token that would be received",gasEstimate:"The estimate of the gas that the swap consumes",initializedTicksCrossedList:"List of the initialized ticks that the swap crossed for each pool in the path",sqrtPriceX96AfterList:"List of the sqrt price after the swap for each pool in the path"},notice:"Returns the amount out received for a given exact input swap without executing the swap"},"quoteExactInputSingle((address,address,uint256,uint24,uint160))":{inputs:[{components:[{internalType:"address",name:"tokenIn",type:"address"},{internalType:"address",name:"tokenOut",type:"address"},{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"}],internalType:"struct IQuoterV2.QuoteExactInputSingleParams",name:"params",type:"tuple"}],name:"quoteExactInputSingle",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint160",name:"sqrtPriceX96After",type:"uint160"},{internalType:"uint32",name:"initializedTicksCrossed",type:"uint32"},{internalType:"uint256",name:"gasEstimate",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{params:"The params for the quote, encoded as `QuoteExactInputSingleParams` tokenIn The token being swapped in tokenOut The token being swapped out fee The fee of the token pool to consider for the pair amountIn The desired input amount sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap"},returns:{amountOut:"The amount of `tokenOut` that would be received",gasEstimate:"The estimate of the gas that the swap consumes",initializedTicksCrossed:"The number of initialized ticks that the swap crossed",sqrtPriceX96After:"The sqrt price of the pool after the swap"},notice:"Returns the amount out received for a given exact input but for a swap of a single pool"},"quoteExactOutput(bytes,uint256)":{inputs:[{internalType:"bytes",name:"path",type:"bytes"},{internalType:"uint256",name:"amountOut",type:"uint256"}],name:"quoteExactOutput",outputs:[{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint160[]",name:"sqrtPriceX96AfterList",type:"uint160[]"},{internalType:"uint32[]",name:"initializedTicksCrossedList",type:"uint32[]"},{internalType:"uint256",name:"gasEstimate",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amountOut:"The amount of the last token to receive",path:"The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order"},returns:{amountIn:"The amount of first token required to be paid",gasEstimate:"The estimate of the gas that the swap consumes",initializedTicksCrossedList:"List of the initialized ticks that the swap crossed for each pool in the path",sqrtPriceX96AfterList:"List of the sqrt price after the swap for each pool in the path"},notice:"Returns the amount in required for a given exact output swap without executing the swap"},"quoteExactOutputSingle((address,address,uint256,uint24,uint160))":{inputs:[{components:[{internalType:"address",name:"tokenIn",type:"address"},{internalType:"address",name:"tokenOut",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"}],internalType:"struct IQuoterV2.QuoteExactOutputSingleParams",name:"params",type:"tuple"}],name:"quoteExactOutputSingle",outputs:[{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint160",name:"sqrtPriceX96After",type:"uint160"},{internalType:"uint32",name:"initializedTicksCrossed",type:"uint32"},{internalType:"uint256",name:"gasEstimate",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{params:"The params for the quote, encoded as `QuoteExactOutputSingleParams` tokenIn The token being swapped in tokenOut The token being swapped out fee The fee of the token pool to consider for the pair amountOut The desired output amount sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap"},returns:{amountIn:"The amount required as the input for the swap in order to receive `amountOut`",gasEstimate:"The estimate of the gas that the swap consumes",initializedTicksCrossed:"The number of initialized ticks that the swap crossed",sqrtPriceX96After:"The sqrt price of the pool after the swap"},notice:"Returns the amount in required to receive the given exact output amount but for a swap of a single pool"},"uniswapV3SwapCallback(int256,int256,bytes)":{inputs:[{internalType:"int256",name:"amount0Delta",type:"int256"},{internalType:"int256",name:"amount1Delta",type:"int256"},{internalType:"bytes",name:"path",type:"bytes"}],name:"uniswapV3SwapCallback",outputs:[],stateMutability:"view",type:"function",details:"In the implementation you must pay the pool tokens owed for the swap. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. amount0Delta and amount1Delta can both be 0 if no tokens were swapped.",params:{amount0Delta:"The amount of token0 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token0 to the pool.",amount1Delta:"The amount of token1 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token1 to the pool.",data:"Any data passed through by the caller via the IUniswapV3PoolActions#swap call"},notice:"Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap."}}},"contracts/mocks/uniswapV3/periphery/lens/TickLens.sol:TickLens":{source:"contracts/mocks/uniswapV3/periphery/lens/TickLens.sol",name:"TickLens",title:"Tick Lens contract",methods:{"getPopulatedTicksInWord(address,int16)":{inputs:[{internalType:"address",name:"pool",type:"address"},{internalType:"int16",name:"tickBitmapIndex",type:"int16"}],name:"getPopulatedTicksInWord",outputs:[{components:[{internalType:"int24",name:"tick",type:"int24"},{internalType:"int128",name:"liquidityNet",type:"int128"},{internalType:"uint128",name:"liquidityGross",type:"uint128"}],internalType:"struct ITickLens.PopulatedTick[]",name:"populatedTicks",type:"tuple[]"}],stateMutability:"view",type:"function",params:{pool:"The address of the pool for which to fetch populated tick data",tickBitmapIndex:"The index of the word in the tick bitmap for which to parse the bitmap and fetch all the populated ticks"},returns:{populatedTicks:"An array of tick data for the given word in the tick bitmap"},notice:"Get all the tick data for the populated ticks from a word of the tick bitmap of a pool"}}},"contracts/mocks/uniswapV3/periphery/lens/UniswapInterfaceMulticall.sol:UniswapInterfaceMulticall":{source:"contracts/mocks/uniswapV3/periphery/lens/UniswapInterfaceMulticall.sol",name:"UniswapInterfaceMulticall",notice:"A fork of Multicall2 specifically tailored for the Uniswap Interface",methods:{"getCurrentBlockTimestamp()":{inputs:[],name:"getCurrentBlockTimestamp",outputs:[{internalType:"uint256",name:"timestamp",type:"uint256"}],stateMutability:"view",type:"function"},"getEthBalance(address)":{inputs:[{internalType:"address",name:"addr",type:"address"}],name:"getEthBalance",outputs:[{internalType:"uint256",name:"balance",type:"uint256"}],stateMutability:"view",type:"function"},"multicall((address,uint256,bytes)[])":{inputs:[{components:[{internalType:"address",name:"target",type:"address"},{internalType:"uint256",name:"gasLimit",type:"uint256"},{internalType:"bytes",name:"callData",type:"bytes"}],internalType:"struct UniswapInterfaceMulticall.Call[]",name:"calls",type:"tuple[]"}],name:"multicall",outputs:[{internalType:"uint256",name:"blockNumber",type:"uint256"},{components:[{internalType:"bool",name:"success",type:"bool"},{internalType:"uint256",name:"gasUsed",type:"uint256"},{internalType:"bytes",name:"returnData",type:"bytes"}],internalType:"struct UniswapInterfaceMulticall.Result[]",name:"returnData",type:"tuple[]"}],stateMutability:"nonpayable",type:"function"}}},"contracts/mocks/uniswapV3/periphery/libraries/BytesLib.sol:BytesLib":{source:"contracts/mocks/uniswapV3/periphery/libraries/BytesLib.sol",name:"BytesLib"},"contracts/mocks/uniswapV3/periphery/libraries/CallbackValidation.sol:CallbackValidation":{source:"contracts/mocks/uniswapV3/periphery/libraries/CallbackValidation.sol",name:"CallbackValidation",notice:"Provides validation for callbacks from Uniswap V3 Pools"},"contracts/mocks/uniswapV3/periphery/libraries/ChainId.sol:ChainId":{source:"contracts/mocks/uniswapV3/periphery/libraries/ChainId.sol",name:"ChainId",title:"Function for getting the current chain ID"},"contracts/mocks/uniswapV3/periphery/libraries/HexStrings.sol:HexStrings":{source:"contracts/mocks/uniswapV3/periphery/libraries/HexStrings.sol",name:"HexStrings"},"contracts/mocks/uniswapV3/periphery/libraries/LiquidityAmounts.sol:LiquidityAmounts":{source:"contracts/mocks/uniswapV3/periphery/libraries/LiquidityAmounts.sol",name:"LiquidityAmounts",title:"Liquidity amount functions",notice:"Provides functions for computing liquidity amounts from token amounts and prices"},"contracts/mocks/uniswapV3/periphery/libraries/NFTDescriptor.sol:NFTDescriptor":{source:"contracts/mocks/uniswapV3/periphery/libraries/NFTDescriptor.sol",name:"NFTDescriptor",methods:{"constructTokenURI((uint256,address,address,string,string,uint8,uint8,bool,int24,int24,int24,int24,uint24,address))":{inputs:[{components:[{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"address",name:"quoteTokenAddress",type:"address"},{internalType:"address",name:"baseTokenAddress",type:"address"},{internalType:"string",name:"quoteTokenSymbol",type:"string"},{internalType:"string",name:"baseTokenSymbol",type:"string"},{internalType:"uint8",name:"quoteTokenDecimals",type:"uint8"},{internalType:"uint8",name:"baseTokenDecimals",type:"uint8"},{internalType:"bool",name:"flipRatio",type:"bool"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"int24",name:"tickCurrent",type:"int24"},{internalType:"int24",name:"tickSpacing",type:"int24"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"address",name:"poolAddress",type:"address"}],internalType:"struct NFTDescriptor.ConstructTokenURIParams",name:"params",type:"tuple"}],name:"constructTokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"}}},"contracts/mocks/uniswapV3/periphery/libraries/NFTSVG.sol:NFTSVG":{source:"contracts/mocks/uniswapV3/periphery/libraries/NFTSVG.sol",name:"NFTSVG",title:"NFTSVG",notice:"Provides a function for generating an SVG associated with a Uniswap NFT"},"contracts/mocks/uniswapV3/periphery/libraries/OracleLibrary.sol:OracleLibrary":{source:"contracts/mocks/uniswapV3/periphery/libraries/OracleLibrary.sol",name:"OracleLibrary",title:"Oracle library",notice:"Provides functions to integrate with V3 pool oracle"},"contracts/mocks/uniswapV3/periphery/libraries/Path.sol:Path":{source:"contracts/mocks/uniswapV3/periphery/libraries/Path.sol",name:"Path",title:"Functions for manipulating path data for multihop swaps"},"contracts/mocks/uniswapV3/periphery/libraries/PoolAddress.sol:PoolAddress":{source:"contracts/mocks/uniswapV3/periphery/libraries/PoolAddress.sol",name:"PoolAddress",title:"Provides functions for deriving a pool address from the factory, tokens, and the fee"},"contracts/mocks/uniswapV3/periphery/libraries/PoolTicksCounter.sol:PoolTicksCounter":{source:"contracts/mocks/uniswapV3/periphery/libraries/PoolTicksCounter.sol",name:"PoolTicksCounter"},"contracts/mocks/uniswapV3/periphery/libraries/PositionKey.sol:PositionKey":{source:"contracts/mocks/uniswapV3/periphery/libraries/PositionKey.sol",name:"PositionKey"},"contracts/mocks/uniswapV3/periphery/libraries/PositionValue.sol:PositionValue":{source:"contracts/mocks/uniswapV3/periphery/libraries/PositionValue.sol",name:"PositionValue",title:"Returns information about the token value held in a Uniswap V3 NFT"},"contracts/mocks/uniswapV3/periphery/libraries/SqrtPriceMathPartial.sol:SqrtPriceMathPartial":{source:"contracts/mocks/uniswapV3/periphery/libraries/SqrtPriceMathPartial.sol",name:"SqrtPriceMathPartial",title:"Functions based on Q64.96 sqrt price and liquidity",notice:"Exposes two functions from @uniswap/v3-core SqrtPriceMath that use square root of price as a Q64.96 and liquidity to compute deltas"},"contracts/mocks/uniswapV3/periphery/libraries/TokenRatioSortOrder.sol:TokenRatioSortOrder":{source:"contracts/mocks/uniswapV3/periphery/libraries/TokenRatioSortOrder.sol",name:"TokenRatioSortOrder"},"contracts/mocks/uniswapV3/periphery/libraries/TransferHelper.sol:TransferHelper":{source:"contracts/mocks/uniswapV3/periphery/libraries/TransferHelper.sol",name:"TransferHelper"},"contracts/mocks/uniswapv2/UniswapV2ERC20.sol:UniswapV2ERC20":{source:"contracts/mocks/uniswapv2/UniswapV2ERC20.sol",name:"UniswapV2ERC20",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"DOMAIN_SEPARATOR()":{inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"PERMIT_TYPEHASH()":{inputs:[],name:"PERMIT_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"balanceOf(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"nonces(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"nonces",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"nonpayable",type:"function"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"}}},"contracts/mocks/uniswapv2/UniswapV2Factory.sol:UniswapV2Factory":{source:"contracts/mocks/uniswapv2/UniswapV2Factory.sol",name:"UniswapV2Factory",constructor:{inputs:[{internalType:"address",name:"_feeToSetter",type:"address"}],stateMutability:"nonpayable",type:"constructor"},events:{"PairCreated(address,address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token0",type:"address"},{indexed:!0,internalType:"address",name:"token1",type:"address"},{indexed:!1,internalType:"address",name:"pair",type:"address"},{indexed:!1,internalType:"uint256",name:"",type:"uint256"}],name:"PairCreated",type:"event"}},methods:{"allPairs(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"allPairs",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"allPairsLength()":{inputs:[],name:"allPairsLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"createPair(address,address)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"}],name:"createPair",outputs:[{internalType:"address",name:"pair",type:"address"}],stateMutability:"nonpayable",type:"function"},"feeTo()":{inputs:[],name:"feeTo",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeToSetter()":{inputs:[],name:"feeToSetter",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getPair(address,address)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"}],name:"getPair",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pairCodeHash()":{inputs:[],name:"pairCodeHash",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"pure",type:"function"},"setFeeTo(address)":{inputs:[{internalType:"address",name:"_feeTo",type:"address"}],name:"setFeeTo",outputs:[],stateMutability:"nonpayable",type:"function"},"setFeeToSetter(address)":{inputs:[{internalType:"address",name:"_feeToSetter",type:"address"}],name:"setFeeToSetter",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/mocks/uniswapv2/UniswapV2Pair.sol:UniswapV2Pair":{source:"contracts/mocks/uniswapv2/UniswapV2Pair.sol",name:"UniswapV2Pair",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Burn(address,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"},{indexed:!0,internalType:"address",name:"to",type:"address"}],name:"Burn",type:"event"},"Mint(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"Mint",type:"event"},"Swap(address,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!1,internalType:"uint256",name:"amount0In",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1In",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount0Out",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1Out",type:"uint256"},{indexed:!0,internalType:"address",name:"to",type:"address"}],name:"Swap",type:"event"},"Sync(uint112,uint112)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint112",name:"reserve0",type:"uint112"},{indexed:!1,internalType:"uint112",name:"reserve1",type:"uint112"}],name:"Sync",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"DOMAIN_SEPARATOR()":{inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"MINIMUM_LIQUIDITY()":{inputs:[],name:"MINIMUM_LIQUIDITY",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"PERMIT_TYPEHASH()":{inputs:[],name:"PERMIT_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"balanceOf(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"burn(address)":{inputs:[{internalType:"address",name:"to",type:"address"}],name:"burn",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getReserves()":{inputs:[],name:"getReserves",outputs:[{internalType:"uint112",name:"_reserve0",type:"uint112"},{internalType:"uint112",name:"_reserve1",type:"uint112"},{internalType:"uint32",name:"_blockTimestampLast",type:"uint32"}],stateMutability:"view",type:"function"},"initialize(address,address)":{inputs:[{internalType:"address",name:"_token0",type:"address"},{internalType:"address",name:"_token1",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function"},"kLast()":{inputs:[],name:"kLast",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mint(address)":{inputs:[{internalType:"address",name:"to",type:"address"}],name:"mint",outputs:[{internalType:"uint256",name:"liquidity",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"nonces(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"nonces",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"nonpayable",type:"function"},"price0CumulativeLast()":{inputs:[],name:"price0CumulativeLast",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"price1CumulativeLast()":{inputs:[],name:"price1CumulativeLast",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"skim(address)":{inputs:[{internalType:"address",name:"to",type:"address"}],name:"skim",outputs:[],stateMutability:"nonpayable",type:"function"},"swap(uint256,uint256,address,bytes)":{inputs:[{internalType:"uint256",name:"amount0Out",type:"uint256"},{internalType:"uint256",name:"amount1Out",type:"uint256"},{internalType:"address",name:"to",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"swap",outputs:[],stateMutability:"nonpayable",type:"function"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"sync()":{inputs:[],name:"sync",outputs:[],stateMutability:"nonpayable",type:"function"},"token0()":{inputs:[],name:"token0",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"token1()":{inputs:[],name:"token1",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"}}},"contracts/mocks/uniswapv2/UniswapV2Router02.sol:UniswapV2Router02":{source:"contracts/mocks/uniswapv2/UniswapV2Router02.sol",name:"UniswapV2Router02",constructor:{inputs:[{internalType:"address",name:"_factory",type:"address"}],stateMutability:"nonpayable",type:"constructor"},methods:{"addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"},{internalType:"uint256",name:"amountADesired",type:"uint256"},{internalType:"uint256",name:"amountBDesired",type:"uint256"},{internalType:"uint256",name:"amountAMin",type:"uint256"},{internalType:"uint256",name:"amountBMin",type:"uint256"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"addLiquidity",outputs:[{internalType:"uint256",name:"amountA",type:"uint256"},{internalType:"uint256",name:"amountB",type:"uint256"},{internalType:"uint256",name:"liquidity",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getAmountIn(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint256",name:"reserveIn",type:"uint256"},{internalType:"uint256",name:"reserveOut",type:"uint256"}],name:"getAmountIn",outputs:[{internalType:"uint256",name:"amountIn",type:"uint256"}],stateMutability:"pure",type:"function"},"getAmountOut(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint256",name:"reserveIn",type:"uint256"},{internalType:"uint256",name:"reserveOut",type:"uint256"}],name:"getAmountOut",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"}],stateMutability:"pure",type:"function"},"getAmountsIn(uint256,address[])":{inputs:[{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"}],name:"getAmountsIn",outputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],stateMutability:"view",type:"function"},"getAmountsOut(uint256,address[])":{inputs:[{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"}],name:"getAmountsOut",outputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],stateMutability:"view",type:"function"},"pairFor(address,address)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"}],name:"pairFor",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"quote(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"amountA",type:"uint256"},{internalType:"uint256",name:"reserveA",type:"uint256"},{internalType:"uint256",name:"reserveB",type:"uint256"}],name:"quote",outputs:[{internalType:"uint256",name:"amountB",type:"uint256"}],stateMutability:"pure",type:"function"},"removeLiquidity(address,address,uint256,uint256,uint256,address,uint256)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"},{internalType:"uint256",name:"liquidity",type:"uint256"},{internalType:"uint256",name:"amountAMin",type:"uint256"},{internalType:"uint256",name:"amountBMin",type:"uint256"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidity",outputs:[{internalType:"uint256",name:"amountA",type:"uint256"},{internalType:"uint256",name:"amountB",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"removeLiquidityWithPermit(address,address,uint256,uint256,uint256,address,uint256,bool,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"},{internalType:"uint256",name:"liquidity",type:"uint256"},{internalType:"uint256",name:"amountAMin",type:"uint256"},{internalType:"uint256",name:"amountBMin",type:"uint256"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"bool",name:"approveMax",type:"bool"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"removeLiquidityWithPermit",outputs:[{internalType:"uint256",name:"amountA",type:"uint256"},{internalType:"uint256",name:"amountB",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)":{inputs:[{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint256",name:"amountOutMin",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swapExactTokensForTokens",outputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"},"swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256)":{inputs:[{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint256",name:"amountOutMin",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swapExactTokensForTokensSupportingFeeOnTransferTokens",outputs:[],stateMutability:"nonpayable",type:"function"},"swapTokensForExactTokens(uint256,uint256,address[],address,uint256)":{inputs:[{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint256",name:"amountInMax",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swapTokensForExactTokens",outputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"}}},"contracts/mocks/uniswapv2/interfaces/IERC20.sol:IERC20Uniswap":{source:"contracts/mocks/uniswapv2/interfaces/IERC20.sol",name:"IERC20Uniswap",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"}}},"contracts/mocks/uniswapv2/interfaces/IUniswapV2Callee.sol:IUniswapV2Callee":{source:"contracts/mocks/uniswapv2/interfaces/IUniswapV2Callee.sol",name:"IUniswapV2Callee",methods:{"uniswapV2Call(address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"uniswapV2Call",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/mocks/uniswapv2/interfaces/IUniswapV2ERC20.sol:IUniswapV2ERC20":{source:"contracts/mocks/uniswapv2/interfaces/IUniswapV2ERC20.sol",name:"IUniswapV2ERC20",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"DOMAIN_SEPARATOR()":{inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"PERMIT_TYPEHASH()":{inputs:[],name:"PERMIT_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"pure",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"pure",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"},"nonces(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"nonces",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"nonpayable",type:"function"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"}}},"contracts/mocks/uniswapv2/interfaces/IUniswapV2Factory.sol:IUniswapV2Factory":{source:"contracts/mocks/uniswapv2/interfaces/IUniswapV2Factory.sol",name:"IUniswapV2Factory",events:{"PairCreated(address,address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token0",type:"address"},{indexed:!0,internalType:"address",name:"token1",type:"address"},{indexed:!1,internalType:"address",name:"pair",type:"address"},{indexed:!1,internalType:"uint256",name:"",type:"uint256"}],name:"PairCreated",type:"event"}},methods:{"allPairs(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"allPairs",outputs:[{internalType:"address",name:"pair",type:"address"}],stateMutability:"view",type:"function"},"allPairsLength()":{inputs:[],name:"allPairsLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"createPair(address,address)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"}],name:"createPair",outputs:[{internalType:"address",name:"pair",type:"address"}],stateMutability:"nonpayable",type:"function"},"feeTo()":{inputs:[],name:"feeTo",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeToSetter()":{inputs:[],name:"feeToSetter",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getPair(address,address)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"}],name:"getPair",outputs:[{internalType:"address",name:"pair",type:"address"}],stateMutability:"view",type:"function"},"setFeeTo(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"setFeeTo",outputs:[],stateMutability:"nonpayable",type:"function"},"setFeeToSetter(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"setFeeToSetter",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/mocks/uniswapv2/interfaces/IUniswapV2Pair.sol:IUniswapV2Pair":{source:"contracts/mocks/uniswapv2/interfaces/IUniswapV2Pair.sol",name:"IUniswapV2Pair",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Burn(address,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"},{indexed:!0,internalType:"address",name:"to",type:"address"}],name:"Burn",type:"event"},"Mint(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"Mint",type:"event"},"Swap(address,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!1,internalType:"uint256",name:"amount0In",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1In",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount0Out",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1Out",type:"uint256"},{indexed:!0,internalType:"address",name:"to",type:"address"}],name:"Swap",type:"event"},"Sync(uint112,uint112)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint112",name:"reserve0",type:"uint112"},{indexed:!1,internalType:"uint112",name:"reserve1",type:"uint112"}],name:"Sync",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"DOMAIN_SEPARATOR()":{inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"MINIMUM_LIQUIDITY()":{inputs:[],name:"MINIMUM_LIQUIDITY",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"PERMIT_TYPEHASH()":{inputs:[],name:"PERMIT_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"pure",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"burn(address)":{inputs:[{internalType:"address",name:"to",type:"address"}],name:"burn",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"pure",type:"function"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getReserves()":{inputs:[],name:"getReserves",outputs:[{internalType:"uint112",name:"reserve0",type:"uint112"},{internalType:"uint112",name:"reserve1",type:"uint112"},{internalType:"uint32",name:"blockTimestampLast",type:"uint32"}],stateMutability:"view",type:"function"},"initialize(address,address)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function"},"kLast()":{inputs:[],name:"kLast",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mint(address)":{inputs:[{internalType:"address",name:"to",type:"address"}],name:"mint",outputs:[{internalType:"uint256",name:"liquidity",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"},"nonces(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"nonces",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"nonpayable",type:"function"},"price0CumulativeLast()":{inputs:[],name:"price0CumulativeLast",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"price1CumulativeLast()":{inputs:[],name:"price1CumulativeLast",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"skim(address)":{inputs:[{internalType:"address",name:"to",type:"address"}],name:"skim",outputs:[],stateMutability:"nonpayable",type:"function"},"swap(uint256,uint256,address,bytes)":{inputs:[{internalType:"uint256",name:"amount0Out",type:"uint256"},{internalType:"uint256",name:"amount1Out",type:"uint256"},{internalType:"address",name:"to",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"swap",outputs:[],stateMutability:"nonpayable",type:"function"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"},"sync()":{inputs:[],name:"sync",outputs:[],stateMutability:"nonpayable",type:"function"},"token0()":{inputs:[],name:"token0",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"token1()":{inputs:[],name:"token1",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"}}},"contracts/mocks/uniswapv2/interfaces/IUniswapV2Router01.sol:IUniswapV2Router01":{source:"contracts/mocks/uniswapv2/interfaces/IUniswapV2Router01.sol",name:"IUniswapV2Router01",methods:{"addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"},{internalType:"uint256",name:"amountADesired",type:"uint256"},{internalType:"uint256",name:"amountBDesired",type:"uint256"},{internalType:"uint256",name:"amountAMin",type:"uint256"},{internalType:"uint256",name:"amountBMin",type:"uint256"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"addLiquidity",outputs:[{internalType:"uint256",name:"amountA",type:"uint256"},{internalType:"uint256",name:"amountB",type:"uint256"},{internalType:"uint256",name:"liquidity",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"},"getAmountIn(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint256",name:"reserveIn",type:"uint256"},{internalType:"uint256",name:"reserveOut",type:"uint256"}],name:"getAmountIn",outputs:[{internalType:"uint256",name:"amountIn",type:"uint256"}],stateMutability:"pure",type:"function"},"getAmountOut(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint256",name:"reserveIn",type:"uint256"},{internalType:"uint256",name:"reserveOut",type:"uint256"}],name:"getAmountOut",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"}],stateMutability:"pure",type:"function"},"getAmountsIn(uint256,address[])":{inputs:[{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"}],name:"getAmountsIn",outputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],stateMutability:"view",type:"function"},"getAmountsOut(uint256,address[])":{inputs:[{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"}],name:"getAmountsOut",outputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],stateMutability:"view",type:"function"},"quote(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"amountA",type:"uint256"},{internalType:"uint256",name:"reserveA",type:"uint256"},{internalType:"uint256",name:"reserveB",type:"uint256"}],name:"quote",outputs:[{internalType:"uint256",name:"amountB",type:"uint256"}],stateMutability:"pure",type:"function"},"removeLiquidity(address,address,uint256,uint256,uint256,address,uint256)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"},{internalType:"uint256",name:"liquidity",type:"uint256"},{internalType:"uint256",name:"amountAMin",type:"uint256"},{internalType:"uint256",name:"amountBMin",type:"uint256"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidity",outputs:[{internalType:"uint256",name:"amountA",type:"uint256"},{internalType:"uint256",name:"amountB",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"removeLiquidityWithPermit(address,address,uint256,uint256,uint256,address,uint256,bool,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"},{internalType:"uint256",name:"liquidity",type:"uint256"},{internalType:"uint256",name:"amountAMin",type:"uint256"},{internalType:"uint256",name:"amountBMin",type:"uint256"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"bool",name:"approveMax",type:"bool"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"removeLiquidityWithPermit",outputs:[{internalType:"uint256",name:"amountA",type:"uint256"},{internalType:"uint256",name:"amountB",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)":{inputs:[{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint256",name:"amountOutMin",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swapExactTokensForTokens",outputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"},"swapTokensForExactTokens(uint256,uint256,address[],address,uint256)":{inputs:[{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint256",name:"amountInMax",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swapTokensForExactTokens",outputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"}}},"contracts/mocks/uniswapv2/interfaces/IUniswapV2Router02.sol:IUniswapV2Router02":{source:"contracts/mocks/uniswapv2/interfaces/IUniswapV2Router02.sol",name:"IUniswapV2Router02",methods:{"addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"},{internalType:"uint256",name:"amountADesired",type:"uint256"},{internalType:"uint256",name:"amountBDesired",type:"uint256"},{internalType:"uint256",name:"amountAMin",type:"uint256"},{internalType:"uint256",name:"amountBMin",type:"uint256"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"addLiquidity",outputs:[{internalType:"uint256",name:"amountA",type:"uint256"},{internalType:"uint256",name:"amountB",type:"uint256"},{internalType:"uint256",name:"liquidity",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"},"getAmountIn(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint256",name:"reserveIn",type:"uint256"},{internalType:"uint256",name:"reserveOut",type:"uint256"}],name:"getAmountIn",outputs:[{internalType:"uint256",name:"amountIn",type:"uint256"}],stateMutability:"pure",type:"function"},"getAmountOut(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint256",name:"reserveIn",type:"uint256"},{internalType:"uint256",name:"reserveOut",type:"uint256"}],name:"getAmountOut",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"}],stateMutability:"pure",type:"function"},"getAmountsIn(uint256,address[])":{inputs:[{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"}],name:"getAmountsIn",outputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],stateMutability:"view",type:"function"},"getAmountsOut(uint256,address[])":{inputs:[{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"}],name:"getAmountsOut",outputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],stateMutability:"view",type:"function"},"pairFor(address,address)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"}],name:"pairFor",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"quote(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"amountA",type:"uint256"},{internalType:"uint256",name:"reserveA",type:"uint256"},{internalType:"uint256",name:"reserveB",type:"uint256"}],name:"quote",outputs:[{internalType:"uint256",name:"amountB",type:"uint256"}],stateMutability:"pure",type:"function"},"removeLiquidity(address,address,uint256,uint256,uint256,address,uint256)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"},{internalType:"uint256",name:"liquidity",type:"uint256"},{internalType:"uint256",name:"amountAMin",type:"uint256"},{internalType:"uint256",name:"amountBMin",type:"uint256"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidity",outputs:[{internalType:"uint256",name:"amountA",type:"uint256"},{internalType:"uint256",name:"amountB",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"removeLiquidityWithPermit(address,address,uint256,uint256,uint256,address,uint256,bool,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"},{internalType:"uint256",name:"liquidity",type:"uint256"},{internalType:"uint256",name:"amountAMin",type:"uint256"},{internalType:"uint256",name:"amountBMin",type:"uint256"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"bool",name:"approveMax",type:"bool"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"removeLiquidityWithPermit",outputs:[{internalType:"uint256",name:"amountA",type:"uint256"},{internalType:"uint256",name:"amountB",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)":{inputs:[{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint256",name:"amountOutMin",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swapExactTokensForTokens",outputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"},"swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256)":{inputs:[{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint256",name:"amountOutMin",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swapExactTokensForTokensSupportingFeeOnTransferTokens",outputs:[],stateMutability:"nonpayable",type:"function"},"swapTokensForExactTokens(uint256,uint256,address[],address,uint256)":{inputs:[{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint256",name:"amountInMax",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swapTokensForExactTokens",outputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"}}},"contracts/mocks/uniswapv2/libraries/Math.sol:Math":{source:"contracts/mocks/uniswapv2/libraries/Math.sol",name:"Math"},"contracts/mocks/uniswapv2/libraries/SafeMath.sol:SafeMathUniswap":{source:"contracts/mocks/uniswapv2/libraries/SafeMath.sol",name:"SafeMathUniswap"},"contracts/mocks/uniswapv2/libraries/TransferHelper.sol:TransferHelper":{source:"contracts/mocks/uniswapv2/libraries/TransferHelper.sol",name:"TransferHelper"},"contracts/mocks/uniswapv2/libraries/UQ112x112.sol:UQ112x112":{source:"contracts/mocks/uniswapv2/libraries/UQ112x112.sol",name:"UQ112x112"},"contracts/mocks/uniswapv2/libraries/UniswapV2Library.sol:UniswapV2Library":{source:"contracts/mocks/uniswapv2/libraries/UniswapV2Library.sol",name:"UniswapV2Library"},"contracts/staking/StakingImplementation.sol:StakingImplementation":{source:"contracts/staking/StakingImplementation.sol",name:"StakingImplementation",events:{"Claimed(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"holder",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Claimed",type:"event",params:{amount:"Claim amount",holder:"Address of the holder"},notice:"Triggered when some tokens have been claimed"},"ClaimedPartial(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"holder",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"lastUnstakeId",type:"uint256"}],name:"ClaimedPartial",type:"event",params:{amount:"Claim amount",holder:"Address of the holder",lastUnstakeId:"Last unstake is to be claimed (if possible)"},notice:"Triggered when some tokens have been partially claimed"},"CooldownUpdated(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldCooldown",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newCooldown",type:"uint256"}],name:"CooldownUpdated",type:"event",params:{newCooldown:"New cooldown value",oldCooldown:"Old cooldown value"},notice:"Triggered when the cooldown value has been updated"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"Staked(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"holder",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Staked",type:"event",params:{amount:"Stake amount",holder:"Address of the holder"},notice:"Triggered when some tokens have been staked"},"Unstaked(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"holder",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Unstaked",type:"event",params:{amount:"Unstake amount",holder:"Address of the holder"},notice:"Triggered when some tokens have been unstaked"}},methods:{"PACT()":{inputs:[],name:"PACT",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"SPACT()":{inputs:[],name:"SPACT",outputs:[{internalType:"contract IMintableERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"claim()":{inputs:[],name:"claim",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Claim all unstakes that are older than cooldown"},"claimAmount(address)":{inputs:[{internalType:"address",name:"_holderAddress",type:"address"}],name:"claimAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimPartial(uint256)":{inputs:[{internalType:"uint256",name:"_lastUnstakeId",type:"uint256"}],name:"claimPartial",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Claim all unstakes until _lastUnstakeId"},"cooldown()":{inputs:[],name:"cooldown",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"currentTotalAmount()":{inputs:[],name:"currentTotalAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donationMiner()":{inputs:[],name:"donationMiner",outputs:[{internalType:"contract IDonationMiner",name:"",type:"address"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function",notice:"Returns the current implementation version"},"initialize(address,address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_PACT",type:"address"},{internalType:"contract IMintableERC20",name:"_SPACT",type:"address"},{internalType:"contract IDonationMiner",name:"_donationMiner",type:"address"},{internalType:"uint256",name:"_cooldown",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_PACT:"Address of the PACT Token",_SPACT:"Address of the SPACT Token",_cooldown:"Number of blocks after a user can claim an unstake",_donationMiner:"Address of the DonationMiner"},notice:"Used to initialize a new DonationMiner contract"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"stake(address,uint256)":{inputs:[{internalType:"address",name:"_holderAddress",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"Amount of cUSD tokens to stake",_holderAddress:"Address of the holder"},notice:"Stakes new founds for the holder"},"stakeholder(address)":{inputs:[{internalType:"address",name:"_holderAddress",type:"address"}],name:"stakeholder",outputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"nextUnstakeId",type:"uint256"},{internalType:"uint256",name:"unstakeListLength",type:"uint256"},{internalType:"uint256",name:"unstakedAmount",type:"uint256"}],stateMutability:"view",type:"function"},"stakeholderAmount(address)":{inputs:[{internalType:"address",name:"_holderAddress",type:"address"}],name:"stakeholderAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"stakeholderUnstakeAt(address,uint256)":{inputs:[{internalType:"address",name:"_holderAddress",type:"address"},{internalType:"uint256",name:"_unstakeIndex",type:"uint256"}],name:"stakeholderUnstakeAt",outputs:[{components:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"cooldownBlock",type:"uint256"}],internalType:"struct IStaking.Unstake",name:"",type:"tuple"}],stateMutability:"view",type:"function"},"stakeholdersListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"stakeholdersListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{_index:"index of the stakeholder"},returns:{_0:"address of the stakeholder"},notice:"Returns the address of a stakeholder from stakeholdersList"},"stakeholdersListLength()":{inputs:[],name:"stakeholdersListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"uint256 number of stakeholders"},notice:"Returns the number of stakeholders"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"unstake(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"unstake",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"number of tokens to be unstaked"},notice:"Unstake"},"updateCooldown(uint256)":{inputs:[{internalType:"uint256",name:"_newCooldown",type:"uint256"}],name:"updateCooldown",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newCooldown:"Number of blocks after a user can claim an unstake"},notice:"Updates cooldown value"}}},"contracts/staking/StakingProxy.sol:StakingProxy":{source:"contracts/staking/StakingProxy.sol",name:"StakingProxy",constructor:{inputs:[{internalType:"address",name:"_logic",type:"address"},{internalType:"address",name:"_proxyAdmin",type:"address"}],stateMutability:"nonpayable",type:"constructor"},fallback:{stateMutability:"payable",type:"fallback"},receive:{stateMutability:"payable",type:"receive"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"admin()":{inputs:[],name:"admin",outputs:[{internalType:"address",name:"admin_",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Returns the current admin. NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}. TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`"},"changeAdmin(address)":{inputs:[{internalType:"address",name:"newAdmin",type:"address"}],name:"changeAdmin",outputs:[],stateMutability:"nonpayable",type:"function",details:"Changes the admin of the proxy. Emits an {AdminChanged} event. NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}."},"implementation()":{inputs:[],name:"implementation",outputs:[{internalType:"address",name:"implementation_",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Returns the current implementation. NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}. TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy. NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy, and then call a function from the new implementation as specified by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the proxied contract. NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}."}}},"contracts/staking/interfaces/IStaking.sol:IStaking":{source:"contracts/staking/interfaces/IStaking.sol",name:"IStaking",methods:{"PACT()":{inputs:[],name:"PACT",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"SPACT()":{inputs:[],name:"SPACT",outputs:[{internalType:"contract IMintableERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"claim()":{inputs:[],name:"claim",outputs:[],stateMutability:"nonpayable",type:"function"},"claimAmount(address)":{inputs:[{internalType:"address",name:"_holderAddress",type:"address"}],name:"claimAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimPartial(uint256)":{inputs:[{internalType:"uint256",name:"_lastUnstakeId",type:"uint256"}],name:"claimPartial",outputs:[],stateMutability:"nonpayable",type:"function"},"cooldown()":{inputs:[],name:"cooldown",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"currentTotalAmount()":{inputs:[],name:"currentTotalAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donationMiner()":{inputs:[],name:"donationMiner",outputs:[{internalType:"contract IDonationMiner",name:"",type:"address"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"stake(address,uint256)":{inputs:[{internalType:"address",name:"_holder",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function"},"stakeholder(address)":{inputs:[{internalType:"address",name:"_holderAddress",type:"address"}],name:"stakeholder",outputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"nextUnstakeId",type:"uint256"},{internalType:"uint256",name:"unstakeListLength",type:"uint256"},{internalType:"uint256",name:"unstakedAmount",type:"uint256"}],stateMutability:"view",type:"function"},"stakeholderAmount(address)":{inputs:[{internalType:"address",name:"_holderAddress",type:"address"}],name:"stakeholderAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"stakeholderUnstakeAt(address,uint256)":{inputs:[{internalType:"address",name:"_holderAddress",type:"address"},{internalType:"uint256",name:"_unstakeIndex",type:"uint256"}],name:"stakeholderUnstakeAt",outputs:[{components:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"cooldownBlock",type:"uint256"}],internalType:"struct IStaking.Unstake",name:"",type:"tuple"}],stateMutability:"view",type:"function"},"stakeholdersListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"stakeholdersListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"stakeholdersListLength()":{inputs:[],name:"stakeholdersListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"unstake(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"unstake",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCooldown(uint256)":{inputs:[{internalType:"uint256",name:"_newCooldown",type:"uint256"}],name:"updateCooldown",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/staking/interfaces/StakingStorageV1.sol:StakingStorageV1":{source:"contracts/staking/interfaces/StakingStorageV1.sol",name:"StakingStorageV1",title:"Storage for DonationMiner",notice:"For future upgrades, do not change DonationMinerStorageV1. Create a new contract which implements DonationMinerStorageV1 and following the naming convention DonationMinerStorageVX.",methods:{"PACT()":{inputs:[],name:"PACT",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"SPACT()":{inputs:[],name:"SPACT",outputs:[{internalType:"contract IMintableERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"claim()":{inputs:[],name:"claim",outputs:[],stateMutability:"nonpayable",type:"function"},"claimAmount(address)":{inputs:[{internalType:"address",name:"_holderAddress",type:"address"}],name:"claimAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimPartial(uint256)":{inputs:[{internalType:"uint256",name:"_lastUnstakeId",type:"uint256"}],name:"claimPartial",outputs:[],stateMutability:"nonpayable",type:"function"},"cooldown()":{inputs:[],name:"cooldown",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"currentTotalAmount()":{inputs:[],name:"currentTotalAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"donationMiner()":{inputs:[],name:"donationMiner",outputs:[{internalType:"contract IDonationMiner",name:"",type:"address"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"stake(address,uint256)":{inputs:[{internalType:"address",name:"_holder",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function"},"stakeholder(address)":{inputs:[{internalType:"address",name:"_holderAddress",type:"address"}],name:"stakeholder",outputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"nextUnstakeId",type:"uint256"},{internalType:"uint256",name:"unstakeListLength",type:"uint256"},{internalType:"uint256",name:"unstakedAmount",type:"uint256"}],stateMutability:"view",type:"function"},"stakeholderAmount(address)":{inputs:[{internalType:"address",name:"_holderAddress",type:"address"}],name:"stakeholderAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"stakeholderUnstakeAt(address,uint256)":{inputs:[{internalType:"address",name:"_holderAddress",type:"address"},{internalType:"uint256",name:"_unstakeIndex",type:"uint256"}],name:"stakeholderUnstakeAt",outputs:[{components:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"cooldownBlock",type:"uint256"}],internalType:"struct IStaking.Unstake",name:"",type:"tuple"}],stateMutability:"view",type:"function"},"stakeholdersListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"stakeholdersListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"stakeholdersListLength()":{inputs:[],name:"stakeholdersListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"unstake(uint256)":{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"unstake",outputs:[],stateMutability:"nonpayable",type:"function"},"updateCooldown(uint256)":{inputs:[{internalType:"uint256",name:"_newCooldown",type:"uint256"}],name:"updateCooldown",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/token/PACTToken.sol:PACTToken":{source:"contracts/token/PACTToken.sol",name:"PACTToken",constructor:{inputs:[{internalType:"address",name:"_initialOwner",type:"address"}],stateMutability:"nonpayable",type:"constructor"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Approval",type:"event",notice:"The standard EIP-20 approval event"},"DelegateChanged(address,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"delegator",type:"address"},{indexed:!0,internalType:"address",name:"fromDelegate",type:"address"},{indexed:!0,internalType:"address",name:"toDelegate",type:"address"}],name:"DelegateChanged",type:"event",notice:"An event thats emitted when an account changes its delegate"},"DelegateVotesChanged(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"delegate",type:"address"},{indexed:!1,internalType:"uint256",name:"previousBalance",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newBalance",type:"uint256"}],name:"DelegateVotesChanged",type:"event",notice:"An event thats emitted when a delegate account's vote balance changes"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Transfer",type:"event",notice:"An event emitted when an account's voting power is transferred."}},methods:{"DELEGATION_TYPEHASH()":{inputs:[],name:"DELEGATION_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"The EIP-712 typehash for the delegation struct used by the contract"},"DOMAIN_TYPEHASH()":{inputs:[],name:"DOMAIN_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"The EIP-712 typehash for the contract's domain"},"MAX_SUPPLY()":{inputs:[],name:"MAX_SUPPLY",outputs:[{internalType:"uint96",name:"",type:"uint96"}],stateMutability:"view",type:"function",notice:"The maximum supply of PACT Tokens."},"PERMIT_TYPEHASH()":{inputs:[],name:"PERMIT_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"The EIP-712 typehash for the permit struct used by the contract"},"allowance(address,address)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{account:"The address of the account holding the funds",spender:"The address of the account spending the funds"},returns:{_0:"The number of tokens approved"},notice:"Get the number of tokens `spender` is approved to spend on behalf of `account`"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"rawAmount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"This will overwrite the approval amount for `spender`  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)",params:{rawAmount:"The number of tokens that are approved (2^256-1 means infinite)",spender:"The address of the account which may transfer tokens"},returns:{_0:"Whether or not the approval succeeded"},notice:"Approve `spender` to transfer up to `amount` from `src`"},"balanceOf(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"checkpoints(address,uint32)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"uint32",name:"",type:"uint32"}],name:"checkpoints",outputs:[{internalType:"uint32",name:"fromBlock",type:"uint32"},{internalType:"uint96",name:"votes",type:"uint96"}],stateMutability:"view",type:"function",notice:"A record of votes checkpoints for each account, by index"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"delegate(address)":{inputs:[{internalType:"address",name:"delegatee",type:"address"}],name:"delegate",outputs:[],stateMutability:"nonpayable",type:"function",params:{delegatee:"The address to delegate votes to"},notice:"Delegate votes from `msg.sender` to `delegatee`"},"delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"delegatee",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"delegateBySig",outputs:[],stateMutability:"nonpayable",type:"function",params:{delegatee:"The address to delegate votes to",expiry:"The time at which to expire the signature",nonce:"The contract state required to match the signature",r:"Half of the ECDSA signature pair",s:"Half of the ECDSA signature pair",v:"The recovery byte of the signature"},notice:"Delegates votes from signatory to `delegatee`"},"delegates(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"delegates",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"A record of each accounts delegate"},"getCurrentVotes(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getCurrentVotes",outputs:[{internalType:"uint96",name:"",type:"uint96"}],stateMutability:"view",type:"function",params:{account:"The address to get votes balance"},returns:{_0:"The number of current votes for `account`"},notice:"Gets the current votes balance for `account`"},"getPriorVotes(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"blockNumber",type:"uint256"}],name:"getPriorVotes",outputs:[{internalType:"uint96",name:"",type:"uint96"}],stateMutability:"view",type:"function",details:"Block number must be a finalized block or else this function will revert to prevent misinformation.",params:{account:"The address of the account to check",blockNumber:"The block number to get the vote balance at"},returns:{_0:"The number of votes the account had as of the given block"},notice:"Determine the prior number of votes for an account as of a block number"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"nonces(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"nonces",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"A record of states for signing / validating signatures"},"numCheckpoints(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"numCheckpoints",outputs:[{internalType:"uint32",name:"",type:"uint32"}],stateMutability:"view",type:"function",notice:"The number of checkpoints for each account"},"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"rawAmount",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"nonpayable",type:"function",params:{deadline:"The time at which to expire the signature",owner:"The address to approve from",r:"Half of the ECDSA signature pair",rawAmount:"The number of tokens that are approved (2^256-1 means infinite)",s:"Half of the ECDSA signature pair",spender:"The address to be approved",v:"The recovery byte of the signature"},notice:"Triggers an approval from owner to spends"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalVotingPower()":{inputs:[],name:"totalVotingPower",outputs:[{internalType:"uint96",name:"",type:"uint96"}],stateMutability:"view",type:"function",notice:"Total voting power in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"dst",type:"address"},{internalType:"uint256",name:"rawAmount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",params:{dst:"The address of the destination account",rawAmount:"The number of tokens to transfer"},returns:{_0:"Whether or not the transfer succeeded"},notice:"Transfer `amount` tokens from `msg.sender` to `dst`"},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"src",type:"address"},{internalType:"address",name:"dst",type:"address"},{internalType:"uint256",name:"rawAmount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",params:{dst:"The address of the destination account",rawAmount:"The number of tokens to transfer",src:"The address of the source account"},returns:{_0:"Whether or not the transfer succeeded"},notice:"Transfer `amount` tokens from `src` to `dst`"},"votingPower(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"votingPower",outputs:[{internalType:"uint96",name:"",type:"uint96"}],stateMutability:"view",type:"function",params:{account:"The address of the account to get the balance of"},returns:{_0:"The amount of voting power held"},notice:"Get the amount of voting power of an account"}}},"contracts/token/SPACTToken.sol:SPACTToken":{source:"contracts/token/SPACTToken.sol",name:"SPACTToken",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"DelegateChanged(address,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"delegator",type:"address"},{indexed:!0,internalType:"address",name:"fromDelegate",type:"address"},{indexed:!0,internalType:"address",name:"toDelegate",type:"address"}],name:"DelegateChanged",type:"event",notice:"An event thats emitted when an account changes its delegate"},"DelegateVotesChanged(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"delegate",type:"address"},{indexed:!1,internalType:"uint256",name:"previousBalance",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newBalance",type:"uint256"}],name:"DelegateVotesChanged",type:"event",notice:"An event thats emitted when a delegate account's vote balance changes"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Transfer",type:"event",notice:"An event emitted when an account's voting power is transferred."}},methods:{"DELEGATION_TYPEHASH()":{inputs:[],name:"DELEGATION_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"The EIP-712 typehash for the delegation struct used by the contract"},"DOMAIN_TYPEHASH()":{inputs:[],name:"DOMAIN_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"The EIP-712 typehash for the contract's domain"},"balanceOf(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"burn(address,uint96)":{inputs:[{internalType:"address",name:"_account",type:"address"},{internalType:"uint96",name:"_amount",type:"uint96"}],name:"burn",outputs:[],stateMutability:"nonpayable",type:"function",params:{_account:"The address of the source account",_amount:"The amount of voting power to be burned"},notice:"Burn voting power"},"checkpoints(address,uint32)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"uint32",name:"",type:"uint32"}],name:"checkpoints",outputs:[{internalType:"uint32",name:"fromBlock",type:"uint32"},{internalType:"uint96",name:"votes",type:"uint96"}],stateMutability:"view",type:"function",notice:"A record of votes checkpoints for each account, by index"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"delegate(address)":{inputs:[{internalType:"address",name:"delegatee",type:"address"}],name:"delegate",outputs:[],stateMutability:"nonpayable",type:"function",params:{delegatee:"The address to delegate votes to"},notice:"Delegate votes from `msg.sender` to `delegatee`"},"delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"delegatee",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"delegateBySig",outputs:[],stateMutability:"nonpayable",type:"function",params:{delegatee:"The address to delegate votes to",expiry:"The time at which to expire the signature",nonce:"The contract state required to match the signature",r:"Half of the ECDSA signature pair",s:"Half of the ECDSA signature pair",v:"The recovery byte of the signature"},notice:"Delegates votes from signatory to `delegatee`"},"delegates(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"delegates",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"A record of each accounts delegate"},"getCurrentVotes(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getCurrentVotes",outputs:[{internalType:"uint96",name:"",type:"uint96"}],stateMutability:"view",type:"function",params:{account:"The address to get votes balance"},returns:{_0:"The number of current votes for `account`"},notice:"Gets the current votes balance for `account`"},"getPriorVotes(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"blockNumber",type:"uint256"}],name:"getPriorVotes",outputs:[{internalType:"uint96",name:"",type:"uint96"}],stateMutability:"view",type:"function",details:"Block number must be a finalized block or else this function will revert to prevent misinformation.",params:{account:"The address of the account to check",blockNumber:"The block number to get the vote balance at"},returns:{_0:"The number of votes the account had as of the given block"},notice:"Determine the prior number of votes for an account as of a block number"},"mint(address,uint96)":{inputs:[{internalType:"address",name:"_account",type:"address"},{internalType:"uint96",name:"_amount",type:"uint96"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function",params:{_account:"The address of the destination account",_amount:"The amount of voting power to be minted"},notice:"Mint new voting power"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"nonces(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"nonces",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"A record of states for signing / validating signatures"},"numCheckpoints(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"numCheckpoints",outputs:[{internalType:"uint32",name:"",type:"uint32"}],stateMutability:"view",type:"function",notice:"The number of checkpoints for each account"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalVotingPower()":{inputs:[],name:"totalVotingPower",outputs:[{internalType:"uint96",name:"",type:"uint96"}],stateMutability:"view",type:"function",notice:"Total voting power in existence."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"votingPower(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"votingPower",outputs:[{internalType:"uint96",name:"",type:"uint96"}],stateMutability:"view",type:"function",params:{account:"The address of the account to get the balance of"},returns:{_0:"The amount of voting power held"},notice:"Get the amount of voting power of an account"}}},"contracts/token/interfaces/IMintableToken.sol:IMintableToken":{source:"contracts/token/interfaces/IMintableToken.sol",name:"IMintableToken",methods:{"burn(address,uint96)":{inputs:[{internalType:"address",name:"_account",type:"address"},{internalType:"uint96",name:"_amount",type:"uint96"}],name:"burn",outputs:[],stateMutability:"nonpayable",type:"function"},"mint(address,uint96)":{inputs:[{internalType:"address",name:"_account",type:"address"},{internalType:"uint96",name:"_amount",type:"uint96"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/treasury/TreasuryImplementation.sol:TreasuryImplementation":{source:"contracts/treasury/TreasuryImplementation.sol",name:"TreasuryImplementation",events:{"AmountConverted(address,uint256,uint256,address[],uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tokenAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"amountIn",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amountOutMin",type:"uint256"},{indexed:!1,internalType:"address[]",name:"exchangePath",type:"address[]"},{indexed:!1,internalType:"uint256",name:"approximateAmountsOut",type:"uint256"}],name:"AmountConverted",type:"event",params:{amountIn:"Amount changed",amountOutMin:"Minimum amount out",approximateAmountsOut:"Approximate value of the final amount out",exchangePath:"Exchange path",tokenAddress:"Address of the token"},notice:"Triggered when a token has been set"},"CommunityAdminUpdated(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldCommunityAdmin",type:"address"},{indexed:!0,internalType:"address",name:"newCommunityAdmin",type:"address"}],name:"CommunityAdminUpdated",type:"event",params:{newCommunityAdmin:"New communityAdmin address",oldCommunityAdmin:"Old communityAdmin address"},notice:"Triggered when CommunityAdmin has been updated"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"TokenRemoved(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tokenAddress",type:"address"}],name:"TokenRemoved",type:"event",params:{tokenAddress:"Address of the token"},notice:"Triggered when a token has been removed"},"TokenSet(address,uint256,address[],uint256,address[])":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tokenAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"oldRate",type:"uint256"},{indexed:!1,internalType:"address[]",name:"oldExchangePath",type:"address[]"},{indexed:!1,internalType:"uint256",name:"newRate",type:"uint256"},{indexed:!1,internalType:"address[]",name:"newExchangePath",type:"address[]"}],name:"TokenSet",type:"event",params:{newExchangePath:"New token exchange path",newRate:"New token rate value",oldExchangePath:"Old token exchange path",oldRate:"Old token rate value",tokenAddress:"Address of the token"},notice:"Triggered when a token has been set"},"TransferERC20(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"TransferERC20",type:"event",params:{amount:"Amount of the transaction",to:"Address of the receiver",token:"ERC20 token address"},notice:"Triggered when an amount of an ERC20 has been transferred from this contract to an address"},"UniswapRouterUpdated(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldUniswapRouter",type:"address"},{indexed:!0,internalType:"address",name:"newUniswapRouter",type:"address"}],name:"UniswapRouterUpdated",type:"event",params:{newUniswapRouter:"New uniswapRouter address",oldUniswapRouter:"Old uniswapRouter address"},notice:"Triggered when UniswapRouter has been updated"}},methods:{"communityAdmin()":{inputs:[],name:"communityAdmin",outputs:[{internalType:"contract ICommunityAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"convertAmount(address,uint256,uint256,address[],uint256)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_amountIn",type:"uint256"},{internalType:"uint256",name:"_amountOutMin",type:"uint256"},{internalType:"address[]",name:"_exchangePath",type:"address[]"},{internalType:"uint256",name:"_deadline",type:"uint256"}],name:"convertAmount",outputs:[],stateMutability:"nonpayable",type:"function"},"getConvertedAmount(address,uint256)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"getConvertedAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function",notice:"Returns the current implementation version"},"initialize(address)":{inputs:[{internalType:"contract ICommunityAdmin",name:"_communityAdmin",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_communityAdmin:"Address of the CommunityAdmin contract"},notice:"Used to initialize a new Treasury contract"},"isToken(address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"}],name:"isToken",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_tokenAddress:"token address to be checked"},returns:{_0:"bool true if the tokenAddress is an accepted token"},notice:"Returns if an address is an accepted token"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"removeToken(address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"}],name:"removeToken",outputs:[],stateMutability:"nonpayable",type:"function"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"setToken(address,uint256,address[])":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_rate",type:"uint256"},{internalType:"address[]",name:"_exchangePath",type:"address[]"}],name:"setToken",outputs:[],stateMutability:"nonpayable",type:"function"},"tokenListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"tokenListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{_index:"index of the token"},returns:{_0:"address of the token"},notice:"Returns the address of a token from tokenList"},"tokenListLength()":{inputs:[],name:"tokenListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"uint256 number of tokens"},notice:"Returns the number of tokens"},"tokens(address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"}],name:"tokens",outputs:[{internalType:"uint256",name:"rate",type:"uint256"},{internalType:"address[]",name:"exchangePath",type:"address[]"}],stateMutability:"view",type:"function",params:{_tokenAddress:"address of the token"},returns:{exchangePath:"of the token",rate:"of the token"},notice:"Returns the details of a token"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"amount of the transaction",_to:"address of the receiver",_token:"address of the ERC20 token"},notice:"Transfers an amount of an ERC20 from this contract to an address"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"uniswapRouter()":{inputs:[],name:"uniswapRouter",outputs:[{internalType:"contract IUniswapV2Router",name:"",type:"address"}],stateMutability:"view",type:"function"},"updateCommunityAdmin(address)":{inputs:[{internalType:"contract ICommunityAdmin",name:"_newCommunityAdmin",type:"address"}],name:"updateCommunityAdmin",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newCommunityAdmin:"address of the new CommunityAdmin contract"},notice:"Updates the CommunityAdmin contract address"},"updateUniswapRouter(address)":{inputs:[{internalType:"contract IUniswapV2Router",name:"_newUniswapRouter",type:"address"}],name:"updateUniswapRouter",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newUniswapRouter:"address of the new UniswapRouter contract"},notice:"Updates the UniswapRouter contract address"}}},"contracts/treasury/TreasuryProxy.sol:TreasuryProxy":{source:"contracts/treasury/TreasuryProxy.sol",name:"TreasuryProxy",constructor:{inputs:[{internalType:"address",name:"_logic",type:"address"},{internalType:"address",name:"_proxyAdmin",type:"address"}],stateMutability:"nonpayable",type:"constructor"},fallback:{stateMutability:"payable",type:"fallback"},receive:{stateMutability:"payable",type:"receive"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"admin()":{inputs:[],name:"admin",outputs:[{internalType:"address",name:"admin_",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Returns the current admin. NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}. TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`"},"changeAdmin(address)":{inputs:[{internalType:"address",name:"newAdmin",type:"address"}],name:"changeAdmin",outputs:[],stateMutability:"nonpayable",type:"function",details:"Changes the admin of the proxy. Emits an {AdminChanged} event. NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}."},"implementation()":{inputs:[],name:"implementation",outputs:[{internalType:"address",name:"implementation_",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Returns the current implementation. NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}. TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy. NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy, and then call a function from the new implementation as specified by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the proxied contract. NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}."}}},"contracts/treasury/interfaces/ITreasury.sol:ITreasury":{source:"contracts/treasury/interfaces/ITreasury.sol",name:"ITreasury",methods:{"communityAdmin()":{inputs:[],name:"communityAdmin",outputs:[{internalType:"contract ICommunityAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"convertAmount(address,uint256,uint256,address[],uint256)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_amountIn",type:"uint256"},{internalType:"uint256",name:"_amountOutMin",type:"uint256"},{internalType:"address[]",name:"_exchangePath",type:"address[]"},{internalType:"uint256",name:"_deadline",type:"uint256"}],name:"convertAmount",outputs:[],stateMutability:"nonpayable",type:"function"},"getConvertedAmount(address,uint256)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"getConvertedAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"isToken(address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"}],name:"isToken",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"removeToken(address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"}],name:"removeToken",outputs:[],stateMutability:"nonpayable",type:"function"},"setToken(address,uint256,address[])":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_rate",type:"uint256"},{internalType:"address[]",name:"_exchangePath",type:"address[]"}],name:"setToken",outputs:[],stateMutability:"nonpayable",type:"function"},"tokenListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"tokenListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tokenListLength()":{inputs:[],name:"tokenListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tokens(address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"}],name:"tokens",outputs:[{internalType:"uint256",name:"rate",type:"uint256"},{internalType:"address[]",name:"exchangePath",type:"address[]"}],stateMutability:"view",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"uniswapRouter()":{inputs:[],name:"uniswapRouter",outputs:[{internalType:"contract IUniswapV2Router",name:"",type:"address"}],stateMutability:"view",type:"function"},"updateCommunityAdmin(address)":{inputs:[{internalType:"contract ICommunityAdmin",name:"_communityAdmin",type:"address"}],name:"updateCommunityAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},"updateUniswapRouter(address)":{inputs:[{internalType:"contract IUniswapV2Router",name:"_uniswapRouter",type:"address"}],name:"updateUniswapRouter",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/treasury/interfaces/IUniswapV2Router.sol:IUniswapV2Router":{source:"contracts/treasury/interfaces/IUniswapV2Router.sol",name:"IUniswapV2Router",methods:{"addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"},{internalType:"uint256",name:"amountADesired",type:"uint256"},{internalType:"uint256",name:"amountBDesired",type:"uint256"},{internalType:"uint256",name:"amountAMin",type:"uint256"},{internalType:"uint256",name:"amountBMin",type:"uint256"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"addLiquidity",outputs:[{internalType:"uint256",name:"amountA",type:"uint256"},{internalType:"uint256",name:"amountB",type:"uint256"},{internalType:"uint256",name:"liquidity",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"pure",type:"function"},"getAmountIn(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint256",name:"reserveIn",type:"uint256"},{internalType:"uint256",name:"reserveOut",type:"uint256"}],name:"getAmountIn",outputs:[{internalType:"uint256",name:"amountIn",type:"uint256"}],stateMutability:"pure",type:"function"},"getAmountOut(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint256",name:"reserveIn",type:"uint256"},{internalType:"uint256",name:"reserveOut",type:"uint256"}],name:"getAmountOut",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"}],stateMutability:"pure",type:"function"},"getAmountsIn(uint256,address[])":{inputs:[{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"}],name:"getAmountsIn",outputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],stateMutability:"view",type:"function"},"getAmountsOut(uint256,address[])":{inputs:[{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"}],name:"getAmountsOut",outputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],stateMutability:"view",type:"function"},"pairFor(address,address)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"}],name:"pairFor",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"quote(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"amountA",type:"uint256"},{internalType:"uint256",name:"reserveA",type:"uint256"},{internalType:"uint256",name:"reserveB",type:"uint256"}],name:"quote",outputs:[{internalType:"uint256",name:"amountB",type:"uint256"}],stateMutability:"pure",type:"function"},"removeLiquidity(address,address,uint256,uint256,uint256,address,uint256)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"},{internalType:"uint256",name:"liquidity",type:"uint256"},{internalType:"uint256",name:"amountAMin",type:"uint256"},{internalType:"uint256",name:"amountBMin",type:"uint256"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidity",outputs:[{internalType:"uint256",name:"amountA",type:"uint256"},{internalType:"uint256",name:"amountB",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"removeLiquidityWithPermit(address,address,uint256,uint256,uint256,address,uint256,bool,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"},{internalType:"uint256",name:"liquidity",type:"uint256"},{internalType:"uint256",name:"amountAMin",type:"uint256"},{internalType:"uint256",name:"amountBMin",type:"uint256"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"bool",name:"approveMax",type:"bool"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"removeLiquidityWithPermit",outputs:[{internalType:"uint256",name:"amountA",type:"uint256"},{internalType:"uint256",name:"amountB",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)":{inputs:[{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint256",name:"amountOutMin",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swapExactTokensForTokens",outputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"},"swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256)":{inputs:[{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint256",name:"amountOutMin",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swapExactTokensForTokensSupportingFeeOnTransferTokens",outputs:[],stateMutability:"nonpayable",type:"function"},"swapTokensForExactTokens(uint256,uint256,address[],address,uint256)":{inputs:[{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint256",name:"amountInMax",type:"uint256"},{internalType:"address[]",name:"path",type:"address[]"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swapTokensForExactTokens",outputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"}}},"contracts/treasury/interfaces/TreasuryStorageV1.sol:TreasuryStorageV1":{source:"contracts/treasury/interfaces/TreasuryStorageV1.sol",name:"TreasuryStorageV1",title:"Storage for Treasury",notice:"For future upgrades, do not change TreasuryStorageV1. Create a new contract which implements TreasuryStorageV1 and following the naming convention TreasuryStorageVX.",methods:{"communityAdmin()":{inputs:[],name:"communityAdmin",outputs:[{internalType:"contract ICommunityAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"convertAmount(address,uint256,uint256,address[],uint256)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_amountIn",type:"uint256"},{internalType:"uint256",name:"_amountOutMin",type:"uint256"},{internalType:"address[]",name:"_exchangePath",type:"address[]"},{internalType:"uint256",name:"_deadline",type:"uint256"}],name:"convertAmount",outputs:[],stateMutability:"nonpayable",type:"function"},"getConvertedAmount(address,uint256)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"getConvertedAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"isToken(address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"}],name:"isToken",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"removeToken(address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"}],name:"removeToken",outputs:[],stateMutability:"nonpayable",type:"function"},"setToken(address,uint256,address[])":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_rate",type:"uint256"},{internalType:"address[]",name:"_exchangePath",type:"address[]"}],name:"setToken",outputs:[],stateMutability:"nonpayable",type:"function"},"tokenListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"tokenListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tokenListLength()":{inputs:[],name:"tokenListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tokens(address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"}],name:"tokens",outputs:[{internalType:"uint256",name:"rate",type:"uint256"},{internalType:"address[]",name:"exchangePath",type:"address[]"}],stateMutability:"view",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"uniswapRouter()":{inputs:[],name:"uniswapRouter",outputs:[{internalType:"contract IUniswapV2Router",name:"",type:"address"}],stateMutability:"view",type:"function"},"updateCommunityAdmin(address)":{inputs:[{internalType:"contract ICommunityAdmin",name:"_communityAdmin",type:"address"}],name:"updateCommunityAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},"updateUniswapRouter(address)":{inputs:[{internalType:"contract IUniswapV2Router",name:"_uniswapRouter",type:"address"}],name:"updateUniswapRouter",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/treasury/interfaces/TreasuryStorageV2.sol:TreasuryStorageV2":{source:"contracts/treasury/interfaces/TreasuryStorageV2.sol",name:"TreasuryStorageV2",title:"Storage for Treasury",notice:"For future upgrades, do not change TreasuryStorageV2. Create a new contract which implements TreasuryStorageV2 and following the naming convention TreasuryStorageVX.",methods:{"communityAdmin()":{inputs:[],name:"communityAdmin",outputs:[{internalType:"contract ICommunityAdmin",name:"",type:"address"}],stateMutability:"view",type:"function"},"convertAmount(address,uint256,uint256,address[],uint256)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_amountIn",type:"uint256"},{internalType:"uint256",name:"_amountOutMin",type:"uint256"},{internalType:"address[]",name:"_exchangePath",type:"address[]"},{internalType:"uint256",name:"_deadline",type:"uint256"}],name:"convertAmount",outputs:[],stateMutability:"nonpayable",type:"function"},"getConvertedAmount(address,uint256)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"getConvertedAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"isToken(address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"}],name:"isToken",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"removeToken(address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"}],name:"removeToken",outputs:[],stateMutability:"nonpayable",type:"function"},"setToken(address,uint256,address[])":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"},{internalType:"uint256",name:"_rate",type:"uint256"},{internalType:"address[]",name:"_exchangePath",type:"address[]"}],name:"setToken",outputs:[],stateMutability:"nonpayable",type:"function"},"tokenListAt(uint256)":{inputs:[{internalType:"uint256",name:"_index",type:"uint256"}],name:"tokenListAt",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tokenListLength()":{inputs:[],name:"tokenListLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tokens(address)":{inputs:[{internalType:"address",name:"_tokenAddress",type:"address"}],name:"tokens",outputs:[{internalType:"uint256",name:"rate",type:"uint256"},{internalType:"address[]",name:"exchangePath",type:"address[]"}],stateMutability:"view",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"},"uniswapRouter()":{inputs:[],name:"uniswapRouter",outputs:[{internalType:"contract IUniswapV2Router",name:"",type:"address"}],stateMutability:"view",type:"function"},"updateCommunityAdmin(address)":{inputs:[{internalType:"contract ICommunityAdmin",name:"_communityAdmin",type:"address"}],name:"updateCommunityAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},"updateUniswapRouter(address)":{inputs:[{internalType:"contract IUniswapV2Router",name:"_uniswapRouter",type:"address"}],name:"updateUniswapRouter",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/vesting/ImpactLabsVestingImplementation.sol:ImpactLabsVestingImplementation":{source:"contracts/vesting/ImpactLabsVestingImplementation.sol",name:"ImpactLabsVestingImplementation",events:{"AdvancePaymentDecreased(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"advancePaymentLeft",type:"uint256"}],name:"AdvancePaymentDecreased",type:"event",params:{advancePaymentLeft:"Value of the advancePayment left",amount:"Value of the decrease"},notice:"Triggered when advancePayment has been decreased"},"Claimed(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Claimed",type:"event",params:{amount:"Value of the claim"},notice:"Triggered when ImpactLabs has claimed"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"TransferERC20(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"TransferERC20",type:"event",params:{amount:"Amount of the transaction",to:"Address of the receiver",token:"ERC20 token address"},notice:"Triggered when an amount of an ERC20 has been transferred from this contract to an address"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"}},methods:{"PACT()":{inputs:[],name:"PACT",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"advancePayment()":{inputs:[],name:"advancePayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claim()":{inputs:[],name:"claim",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Transfers PACT to ImpactLabs it will not be transferred PACTs to ImpactLabs until the entire amount payed in advance will be covered"},"donationMiner()":{inputs:[],name:"donationMiner",outputs:[{internalType:"contract IDonationMiner",name:"",type:"address"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function",notice:"Returns the current implementation version"},"impactLabs()":{inputs:[],name:"impactLabs",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"initialize(address,address,address,uint256)":{inputs:[{internalType:"address",name:"_impactLabs",type:"address"},{internalType:"contract IERC20Upgradeable",name:"_PACT",type:"address"},{internalType:"contract IDonationMiner",name:"_donationMiner",type:"address"},{internalType:"uint256",name:"_advancePayment",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_PACT:"Address of the PACT Token",_advancePayment:"The amount of PACT that will be given in advance to ImpactLabs",_impactLabs:"Address of the ImpactLabs"},notice:"Used to initialize a new ImpactLabsVesting contract !!! before calling this method, you must ensure that there is enough PACTs on the contract address"},"nextRewardPeriod()":{inputs:[],name:"nextRewardPeriod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if the contract is paused, and false otherwise."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"amount of the transaction",_to:"address of the receiver",_token:"address of the ERC20 token"},notice:"Transfers an amount of an ERC20 from this contract to an address"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},"contracts/vesting/ImpactLabsVestingProxy.sol:ImpactLabsVestingProxy":{source:"contracts/vesting/ImpactLabsVestingProxy.sol",name:"ImpactLabsVestingProxy",constructor:{inputs:[{internalType:"address",name:"_logic",type:"address"},{internalType:"address",name:"_proxyAdmin",type:"address"}],stateMutability:"nonpayable",type:"constructor"},fallback:{stateMutability:"payable",type:"fallback"},receive:{stateMutability:"payable",type:"receive"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"admin()":{inputs:[],name:"admin",outputs:[{internalType:"address",name:"admin_",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Returns the current admin. NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}. TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`"},"changeAdmin(address)":{inputs:[{internalType:"address",name:"newAdmin",type:"address"}],name:"changeAdmin",outputs:[],stateMutability:"nonpayable",type:"function",details:"Changes the admin of the proxy. Emits an {AdminChanged} event. NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}."},"implementation()":{inputs:[],name:"implementation",outputs:[{internalType:"address",name:"implementation_",type:"address"}],stateMutability:"nonpayable",type:"function",details:"Returns the current implementation. NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}. TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy. NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy, and then call a function from the new implementation as specified by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the proxied contract. NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}."}}},"contracts/vesting/interfaces/IImpactLabsVesting.sol:IImpactLabsVesting":{source:"contracts/vesting/interfaces/IImpactLabsVesting.sol",name:"IImpactLabsVesting",methods:{"PACT()":{inputs:[],name:"PACT",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"advancePayment()":{inputs:[],name:"advancePayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claim()":{inputs:[],name:"claim",outputs:[],stateMutability:"nonpayable",type:"function"},"donationMiner()":{inputs:[],name:"donationMiner",outputs:[{internalType:"contract IDonationMiner",name:"",type:"address"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"impactLabs()":{inputs:[],name:"impactLabs",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"nextRewardPeriod()":{inputs:[],name:"nextRewardPeriod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/vesting/interfaces/ImpactLabsVestingStorageV1.sol:ImpactLabsVestingStorageV1":{source:"contracts/vesting/interfaces/ImpactLabsVestingStorageV1.sol",name:"ImpactLabsVestingStorageV1",title:"Storage for ImpactLabsVesting",notice:"For future upgrades, do not change ImpactLabsVestingStorageV1. Create a new contract which implements ImpactLabsVestingStorageV1 and following the naming convention ImpactLabsVestingStorageVx.",methods:{"PACT()":{inputs:[],name:"PACT",outputs:[{internalType:"contract IERC20Upgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"},"advancePayment()":{inputs:[],name:"advancePayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claim()":{inputs:[],name:"claim",outputs:[],stateMutability:"nonpayable",type:"function"},"donationMiner()":{inputs:[],name:"donationMiner",outputs:[{internalType:"contract IDonationMiner",name:"",type:"address"}],stateMutability:"view",type:"function"},"getVersion()":{inputs:[],name:"getVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"impactLabs()":{inputs:[],name:"impactLabs",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"nextRewardPeriod()":{inputs:[],name:"nextRewardPeriod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,address,uint256)":{inputs:[{internalType:"contract IERC20Upgradeable",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[],stateMutability:"nonpayable",type:"function"}}}};new bo({el:"#app",router:new op({routes:[{path:"/",component:Up,props:()=>({json:Vp})},{path:"*",component:Pp,props:e=>({json:Vp[e.path.slice(1)]})}]}),mounted(){document.dispatchEvent(new Event("render-event"))},render:e=>e(yp)})},387:(e,t,n)=>{var a=n(268);a.__esModule&&(a=a.default),"string"==typeof a&&(a=[[e.id,a,""]]),a.locals&&(e.exports=a.locals),(0,n(346).Z)("0b345cf4",a,!1,{})},346:(e,t,n)=>{"use strict";function a(e,t){for(var n=[],a={},i=0;i<t.length;i++){var s=t[i],r=s[0],o={id:e+":"+i,css:s[1],media:s[2],sourceMap:s[3]};a[r]?a[r].parts.push(o):n.push(a[r]={id:r,parts:[o]})}return n}n.d(t,{Z:()=>c});var i="undefined"!=typeof document;if("undefined"!=typeof DEBUG&&DEBUG&&!i)throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");var s={},r=i&&(document.head||document.getElementsByTagName("head")[0]),o=null,u=0,p=!1,d=function(){},y=null,l="data-vue-ssr-id",m="undefined"!=typeof navigator&&/msie [6-9]\b/.test(navigator.userAgent.toLowerCase());function c(e,t,n,i){p=n,y=i||{};var r=a(e,t);return f(r),function(t){for(var n=[],i=0;i<r.length;i++){var o=r[i];(u=s[o.id]).refs--,n.push(u)}for(t?f(r=a(e,t)):r=[],i=0;i<n.length;i++){var u;if(0===(u=n[i]).refs){for(var p=0;p<u.parts.length;p++)u.parts[p]();delete s[u.id]}}}}function f(e){for(var t=0;t<e.length;t++){var n=e[t],a=s[n.id];if(a){a.refs++;for(var i=0;i<a.parts.length;i++)a.parts[i](n.parts[i]);for(;i<n.parts.length;i++)a.parts.push(T(n.parts[i]));a.parts.length>n.parts.length&&(a.parts.length=n.parts.length)}else{var r=[];for(i=0;i<n.parts.length;i++)r.push(T(n.parts[i]));s[n.id]={id:n.id,refs:1,parts:r}}}}function h(){var e=document.createElement("style");return e.type="text/css",r.appendChild(e),e}function T(e){var t,n,a=document.querySelector("style["+l+'~="'+e.id+'"]');if(a){if(p)return d;a.parentNode.removeChild(a)}if(m){var i=u++;a=o||(o=h()),t=w.bind(null,a,i,!1),n=w.bind(null,a,i,!0)}else a=h(),t=g.bind(null,a),n=function(){a.parentNode.removeChild(a)};return t(e),function(a){if(a){if(a.css===e.css&&a.media===e.media&&a.sourceMap===e.sourceMap)return;t(e=a)}else n()}}var b,v=(b=[],function(e,t){return b[e]=t,b.filter(Boolean).join("\n")});function w(e,t,n,a){var i=n?"":a.css;if(e.styleSheet)e.styleSheet.cssText=v(t,i);else{var s=document.createTextNode(i),r=e.childNodes;r[t]&&e.removeChild(r[t]),r.length?e.insertBefore(s,r[t]):e.appendChild(s)}}function g(e,t){var n=t.css,a=t.media,i=t.sourceMap;if(a&&e.setAttribute("media",a),y.ssrId&&e.setAttribute(l,t.id),i&&(n+="\n/*# sourceURL="+i.sources[0]+" */",n+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(i))))+" */"),e.styleSheet)e.styleSheet.cssText=n;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(n))}}}},t={};function n(a){var i=t[a];if(void 0!==i)return i.exports;var s=t[a]={id:a,exports:{}};return e[a](s,s.exports,n),s.exports}n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var a in t)n.o(t,a)&&!n.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n(267)})();